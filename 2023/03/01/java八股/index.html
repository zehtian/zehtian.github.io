<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>java八股 - 田泽豪的学习笔记</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="田泽豪的学习笔记"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="田泽豪的学习笔记"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本篇文章为java后台开发的八股文，主要设计java基础和数据库基础，正在持续更新中，目前包括：java基础（java特性，java集合，java并发编程），数据库基础（MySQL，Redis），和计算机基础知识。"><meta property="og:type" content="blog"><meta property="og:title" content="java八股"><meta property="og:url" content="http://example.com/2023/03/01/java%E5%85%AB%E8%82%A1/"><meta property="og:site_name" content="田泽豪的学习笔记"><meta property="og:description" content="本篇文章为java后台开发的八股文，主要设计java基础和数据库基础，正在持续更新中，目前包括：java基础（java特性，java集合，java并发编程），数据库基础（MySQL，Redis），和计算机基础知识。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/2023/03/01/java%E5%85%AB%E8%82%A1/jmm2.png"><meta property="og:image" content="http://example.com/2023/03/01/java%E5%85%AB%E8%82%A1/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg"><meta property="article:published_time" content="2023-03-01T12:57:45.000Z"><meta property="article:modified_time" content="2023-03-01T13:01:16.656Z"><meta property="article:author" content="Zehao Tian"><meta property="article:tag" content="java"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/2023/03/01/java%E5%85%AB%E8%82%A1/jmm2.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2023/03/01/java%E5%85%AB%E8%82%A1/"},"headline":"java八股","image":["http://example.com/2023/03/01/java%E5%85%AB%E8%82%A1/jmm2.png","http://example.com/2023/03/01/java%E5%85%AB%E8%82%A1/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg"],"datePublished":"2023-03-01T12:57:45.000Z","dateModified":"2023-03-01T13:01:16.656Z","author":{"@type":"Person","name":"Zehao Tian"},"publisher":{"@type":"Organization","name":"田泽豪的学习笔记","logo":{"@type":"ImageObject","url":{"text":"Blackpride"}}},"description":"本篇文章为java后台开发的八股文，主要设计java基础和数据库基础，正在持续更新中，目前包括：java基础（java特性，java集合，java并发编程），数据库基础（MySQL，Redis），和计算机基础知识。"}</script><link rel="canonical" href="http://example.com/2023/03/01/java%E5%85%AB%E8%82%A1/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Blackpride</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-01T12:57:45.000Z" title="2023/3/1 20:57:45">2023-03-01</time>发表</span><span class="level-item"><time dateTime="2023-03-01T13:01:16.656Z" title="2023/3/1 21:01:16">2023-03-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">2 小时读完 (大约18035个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">java八股</h1><div class="content"><p>本篇文章为java后台开发的八股文，主要设计java基础和数据库基础，正在持续更新中，目前包括：java基础（java特性，java集合，java并发编程），数据库基础（MySQL，Redis），和计算机基础知识。</p>
<span id="more"></span>



<h2 id="1-java基础"><a href="#1-java基础" class="headerlink" title="1. java基础"></a>1. java基础</h2><h3 id="1-1-java特性"><a href="#1-1-java特性" class="headerlink" title="1.1 java特性"></a>1.1 java特性</h3><h4 id="1-1-1-接口和抽象类的区别"><a href="#1-1-1-接口和抽象类的区别" class="headerlink" title="1.1.1 接口和抽象类的区别"></a>1.1.1 接口和抽象类的区别</h4><ul>
<li><p>相同点：</p>
<ul>
<li>都不能被实例化；</li>
<li>接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</li>
</ul>
</li>
<li><p>不同点：</p>
<ul>
<li><p>抽象类可以有构造方法（构造器），而接口没有；</p>
</li>
<li><p>抽象类可以有抽象方法和具体方法，接口只能有抽象方法（也就是说，抽象类可以有方法的实现，接口没有）；</p>
</li>
<li><p>抽象类的成员可以用public protected default修饰，接口只能用public（不写就是public）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="1-1-2-重载和重写的区别"><a href="#1-1-2-重载和重写的区别" class="headerlink" title="1.1.2 重载和重写的区别"></a>1.1.2 重载和重写的区别</h4><ul>
<li>重载发生在同一个类中，方法名相同、参数列表、返回类型、权限修饰符可以不同；</li>
<li>重写发生在子类中，方法名、参数列表、返回类型都相同，<strong>权限修饰符要大于父类方法</strong>，声明异常范围要小于父类方法，但是final和private修饰的方法不可重写</li>
</ul>
<h4 id="1-1-3-x3D-x3D-和equals的区别"><a href="#1-1-3-x3D-x3D-和equals的区别" class="headerlink" title="1.1.3 &#x3D;&#x3D;和equals的区别"></a>1.1.3 &#x3D;&#x3D;和equals的区别</h4><ul>
<li>&#x3D;&#x3D;比较基本类型，比较的是值，&#x3D;&#x3D;比较引用类型，比较的是内存地址；</li>
<li>equals是Object类的方法，不能用于比较基本类型，如果没有对 equals 方法进行重写，则相当于&#x3D;&#x3D;，比较的是引用类型的变量<strong>所指向的对象的地址值</strong>；</li>
<li>但是有些类重写了equals方法，就会比较两个对象的内容是否相等，比如String类中的equals()是被重写了，比较的是<strong>对象的值</strong>。</li>
</ul>
<h4 id="1-1-4-Exception-和-Error-的区别"><a href="#1-1-4-Exception-和-Error-的区别" class="headerlink" title="1.1.4 Exception 和 Error 的区别"></a>1.1.4 Exception 和 Error 的区别</h4><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li><strong><code>Exception</code></strong> ：<strong>程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。</strong><code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li><strong><code>Error</code></strong> ：**<code>Error</code> 属于程序无法处理的错误 ，不建议通过<code>catch</code>捕获 。**例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<h4 id="1-1-5-异常处理机制"><a href="#1-1-5-异常处理机制" class="headerlink" title="1.1.5 异常处理机制"></a>1.1.5 异常处理机制</h4><ul>
<li>throws表明方法抛出异常，需要调用者来处理，如果不想处理就一直向外抛，最后会由jvm来处理；</li>
<li>try-catch-finally：捕获别人抛出的异常，并进行处理：<ul>
<li>try： 用于捕获异常；</li>
<li>catch：用于处理异常；</li>
<li>finally：无论是否捕获或处理异常，finally块里的语句都会被执行。try-&gt;finally-&gt;return(finally&#x2F;try中)；</li>
<li>finally中不要放return，当try语句和finally语句中都有return语句时，try语句块中的return语句会被忽略。</li>
</ul>
</li>
<li>finally中的语句不是一定执行的！就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</li>
</ul>
<h4 id="1-1-6-自动拆装箱的原理"><a href="#1-1-6-自动拆装箱的原理" class="headerlink" title="1.1.6 自动拆装箱的原理"></a>1.1.6 <strong>自动拆装箱的原理</strong></h4><p>java为每一种基本数据类型设计了对应的包装类，自动拆装箱反映的就是基本数据类型与其对应包装类的相互转换。</p>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>自动装箱其实就是调用了包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>
</ul>
<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<h4 id="1-1-7-面向对象和面向过程的区别"><a href="#1-1-7-面向对象和面向过程的区别" class="headerlink" title="1.1.7 面向对象和面向过程的区别"></a>1.1.7 面向对象和面向过程的区别</h4><p>两者的主要区别在于解决问题的方式不同：</p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题；</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题；</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<blockquote>
<p>面向过程一定比面向对象的性能要高吗？答案是否定的：</p>
</blockquote>
<ul>
<li>面向对象需要创建对象，类调用时需要实例化，开销比较大，比较消耗资源；</li>
<li>但这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，java性能差的主要原因并不是因为它是面向对象语言，而是java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码；</li>
<li>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比java好。</li>
</ul>
<h4 id="1-1-8-String、StringBuffer、StringBuilder-的区别"><a href="#1-1-8-String、StringBuffer、StringBuilder-的区别" class="headerlink" title="1.1.8 String、StringBuffer、StringBuilder 的区别"></a>1.1.8 String、StringBuffer、StringBuilder 的区别</h4><ul>
<li><p>可变性：</p>
<ul>
<li>String是不可变的（修改后指向了新的引用），StringBuffer和StringBuilder是可变的（在原对象上进行修改）；<ul>
<li>解释：保存String字符串的数组被 final 修饰且为私有的，并且 String 类没有提供修改这个字符串的方法；</li>
<li>String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。</li>
</ul>
</li>
</ul>
</li>
<li><p>线程安全性：</p>
<ul>
<li>String对象不可变，可以理解为常量，线程安全；</li>
<li>StringBuffer对一些字符串的操作添加了同步锁，线程安全；</li>
<li>StringBuilder线程不安全，但性能相对于StringBuffer有着10-15%的提升。</li>
</ul>
</li>
</ul>
<p>补充：字符串拼接”+“的含义：</p>
<ul>
<li>实质上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。</li>
</ul>
<h4 id="1-1-9-类的初始化顺序"><a href="#1-1-9-类的初始化顺序" class="headerlink" title="1.1.9 类的初始化顺序"></a>1.1.9 类的初始化顺序</h4><p>父类静态代码块和静态成员变量 &#x3D;&gt; 子类静态代码块和静态成员变量 &#x3D;&gt; 父类代码块和普通成员变量 &#x3D;&gt; 父类构造方法 &#x3D;&gt; 子类代码块和普成员变量 &#x3D;&gt; 子类构造方法</p>
<h3 id="1-2-java集合"><a href="#1-2-java集合" class="headerlink" title="1.2 java集合"></a>1.2 java集合</h3><h4 id="1-2-1-ArrayList和Vector的区别"><a href="#1-2-1-ArrayList和Vector的区别" class="headerlink" title="1.2.1 ArrayList和Vector的区别"></a>1.2.1 ArrayList和Vector的区别</h4><ul>
<li>ArrayList 是 List 的主要实现类，底层使用 Object[] 存储，<strong>适用于频繁的查找工作，线程不安全</strong>；</li>
<li>Vector 是 List 的古老实现类，底层使用 Object[] 存储，<strong>线程安全</strong>的（方法之间线程同步，即多个线程访问时能保证同步）；</li>
</ul>
<ul>
<li><strong>ArrayList的默认扩容是扩容到原来的1.5倍，而Vector是扩容到原来的2倍</strong>，且Vector提供了扩容的方法。</li>
</ul>
<h4 id="1-2-2-ArrayList与LinkedList的区别"><a href="#1-2-2-ArrayList与LinkedList的区别" class="headerlink" title="1.2.2 ArrayList与LinkedList的区别"></a>1.2.2 ArrayList与LinkedList的区别</h4><ul>
<li>二者<strong>都不是线程安全</strong>的；</li>
<li><strong>ArrayList底层是 Object[] 数组存储，而LinkedList是双向链表存储</strong>；</li>
<li>ArrayList 插入和删除元素的时间复杂度受元素位置的影响，且插入和删除时，需要移动元素的位置，而LinkedList不受影响，只需要移动指针就行。因此<strong>对于插入和删除操作来说，LinkedList要优于ArrayList</strong>；</li>
<li>LinkedList不支持高效的随机元素访问，而 ArrayList（实现了RandomAccess接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象（get 方法）。<strong>因此对于查找来说，ArrayList要优于LinkedList</strong>。</li>
</ul>
<h4 id="1-2-3-ArrayList与Array的区别"><a href="#1-2-3-ArrayList与Array的区别" class="headerlink" title="1.2.3 ArrayList与Array的区别"></a>1.2.3 ArrayList与Array的区别</h4><ul>
<li>Array 可以包含基本数据类型和引用类型，ArrayList只能包含引用类型（包装类）；</li>
<li><strong>ArrayList是基于数组实现的，Array大小不可以调整大小，但ArrayList可以通过内部方法自动调整容量</strong>；</li>
<li>ArrayList是List接口的实现类，相比Array支持更多的方法和特性。</li>
</ul>
<h4 id="1-2-4-ArrayList扩容机制"><a href="#1-2-4-ArrayList扩容机制" class="headerlink" title="1.2.4 ArrayList扩容机制"></a>1.2.4 ArrayList扩容机制</h4><p>ArrayList添加元素的操作add（JDK1.8之后）：</p>
<ul>
<li><p>无参数构造方法创建ArrayList：</p>
<ul>
<li>初始化了一个空数组 Object[] elementData；</li>
<li>当开始添加第一个元素时，将数组容量扩容到10（默认的初始容量），并进行元素的复制；<ul>
<li>解释：此时elementData.length（容量）为0（因为还是一个空的list），而minCapacity为10 &gt; elementData.length，因此进入grow方法进行扩容，扩容到10；</li>
</ul>
</li>
<li>添加第2…10个元素时，不会进行扩容；<ul>
<li>解释：此时minCapacity为2…10 ≤ elementData.length（10）；</li>
</ul>
</li>
<li>添加到第11个元素时，扩容到原来的1.5倍，并进行元素的复制；<ul>
<li>解释：此时minCapacity为11 &gt; elementData.length（10）；</li>
<li>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1)</li>
</ul>
</li>
</ul>
</li>
<li><p>有参构造方法创建ArrayList(len)（构建指定长度的列表）：</p>
<ul>
<li>初始化一个空数组 Object[len]；</li>
<li>当添加第len+1个元素时，开始扩容，扩容到原来的1.5倍；</li>
<li>其它与无参相同。</li>
</ul>
</li>
<li><p>有参构造方法创建ArrayList（构建包含指定元素的列表）：</p>
<ul>
<li>初始化一个包含这些元素的数组 Object[]；</li>
<li>当添加元素时，开始扩容，同上。</li>
</ul>
</li>
</ul>
<p>如果是JDK1.7之前：</p>
<ul>
<li>会初始化一个容量为10的数组elementData[10]；</li>
<li>其余与JDK1.8相同。</li>
</ul>
<h4 id="1-2-5-如何保证ArrayList的线程安全"><a href="#1-2-5-如何保证ArrayList的线程安全" class="headerlink" title="1.2.5 如何保证ArrayList的线程安全"></a>1.2.5 如何保证ArrayList的线程安全</h4><ul>
<li><p>线程安全：指当多线程访问时，采用了加锁的机制；即<strong>当一个线程访问该类的某个数据时，会对这个数据进行保护，其他线程不能对其访问，直到该线程读取完之后，其他线程才可以使用</strong>。防止出现数据不一致或者数据被污染等意外情况。</p>
</li>
<li><p>使用Vector；</p>
</li>
<li><p>使用Collections.synchronizedList()方法为ArrayList加锁；</p>
</li>
<li><p>使用CopyOnWriteArrayList，基本原理还是和ArrayList一样，涉及线程安全的部分，是通过写时复制的方式来实现（从名字中就可以看出）。它内部<strong>有个volatile数组来保持数据</strong>。在<strong>“添加&#x2F;修改&#x2F;删除”数据</strong>时，会先<strong>获取互斥锁</strong>，再<strong>新建一个数组</strong>，并<strong>将更新后的数据拷贝到新建的数组</strong>中，最后<strong>再将该数组赋值给volatile数组</strong>，然后<strong>再释放互斥锁</strong>。因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。（锁释放了另外一个线程才能进入）</p>
</li>
</ul>
<h4 id="1-2-6-比较HashSet、LinkedHashSet和TreeSet三者的异同"><a href="#1-2-6-比较HashSet、LinkedHashSet和TreeSet三者的异同" class="headerlink" title="1.2.6 比较HashSet、LinkedHashSet和TreeSet三者的异同"></a>1.2.6 比较HashSet、LinkedHashSet和TreeSet三者的异同</h4><ul>
<li>HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一（无序性和不可重复性），并且都不是线程安全的；</li>
<li>HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现，值为空）。LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序；</li>
<li>底层数据结构不同又导致这三者的应用场景不同。HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h4 id="1-2-7-HashSet-如何检查重复"><a href="#1-2-7-HashSet-如何检查重复" class="headerlink" title="1.2.7 HashSet 如何检查重复?"></a>1.2.7 HashSet 如何检查重复?</h4><ul>
<li>当你把对象加入HashSet时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置；</li>
<li>同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现，进行正常的添加操作；（hashcode不同，肯定不是一个元素）</li>
<li>但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。</li>
</ul>
<h4 id="1-2-8-HashMap-和-Hashtable-的区别"><a href="#1-2-8-HashMap-和-Hashtable-的区别" class="headerlink" title="1.2.8 HashMap 和 Hashtable 的区别"></a>1.2.8 HashMap 和 Hashtable 的区别</h4><ul>
<li><p>线程是否安全： HashMap 是非线程安全的，Hashtable 是线程安全的，因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</p>
</li>
<li><p>效率： 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；</p>
</li>
<li><p>对 Null key 和 Null value 的支持：<strong>HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</strong>；Hashtable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</p>
</li>
<li><p>初始容量大小和每次扩充容量大小的不同 ：</p>
<ul>
<li>创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1；</li>
<li>HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的 2 倍；</li>
<li>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小HashMap 总是使用 2 的幂作为哈希表的大小。（如果length是 2 的 n 次方，hash%length&#x3D;&#x3D;hash&amp;(length-1)，而采用二进制位操作 &amp;，相对于 % 能够提高运算效率。）</li>
</ul>
</li>
<li><p>底层数据结构： </p>
<ul>
<li>Hashtable 和 JDK1.8 之前的 HashMap底层结构都是数组+链表，且链表采用头插法； </li>
<li>JDK1.8 以后的 HashMap 采用数组+链表+红黑树，链表采用尾插法，因为要统计长度，都需要遍历； </li>
<li>具体的，JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。Hashtable 没有这样的机制。</li>
</ul>
</li>
</ul>
<h4 id="1-2-9-HashMap的底层实现"><a href="#1-2-9-HashMap的底层实现" class="headerlink" title="1.2.9 HashMap的底层实现"></a>1.2.9 HashMap的底层实现</h4><ul>
<li><p>JDK1.8 之前：数组+链表</p>
<ul>
<li>HashMap map &#x3D; new HashMap()：在实例化以后，底层了<strong>创建了一个长度是16（容量）的一维数组Entry[] table</strong>；<ul>
<li>如果设置了初始值，则自动补充到2的幂次的容量大小；</li>
</ul>
</li>
<li>某次执行了put(key, value)时：<ul>
<li>将 key 的 hashcode 经过扰动函数处理过后得到 hash 值；</li>
<li>然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度）；</li>
<li>如果当前位置没有元素，直接正常添加；</li>
<li>如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值，如果不同，则正常添加；</li>
<li>如果 hash 值相同的话，使用equals比较，如果相同，则直接替换，不相同就进行插入，并通过拉链法解决冲突。</li>
</ul>
</li>
<li>添加键值对的过程中，会出现扩容问题，当<strong>元素个数超过了容量的0.75的时候，会进行扩容，扩容到原来容量的两倍</strong>，并将数据复制。</li>
</ul>
</li>
<li><p>JDK1.8 之后：数组+链表+红黑树</p>
<ul>
<li>new HashMap()：底层没有创建一个长度为16的数组；</li>
<li>jdk 8底层的数组是：Node[]，而非Entry[]；</li>
<li><strong>首次调用put()方法时，底层创建长度为16的数组</strong>；</li>
<li>jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树；</li>
<li>当数组的某一个索引上的元素以链表形式存在的个数&gt;8，且当前数组的长度&gt;64时，此时此索引位置上的数据改为红黑树存储。</li>
</ul>
</li>
</ul>
<h4 id="1-2-10-ConcurrentHashMap-是如何实现线程安全的"><a href="#1-2-10-ConcurrentHashMap-是如何实现线程安全的" class="headerlink" title="1.2.10 ConcurrentHashMap 是如何实现线程安全的"></a>1.2.10 ConcurrentHashMap 是如何实现线程安全的</h4><ul>
<li>JDK 1.7 采用 Segment 分段锁来保证安全，Segment 是继承自 ReentrantLock；</li>
<li>JDK1.8 放弃了 Segment 分段锁的设计，采用 Node + CAS + synchronized 保证线程安全，锁粒度更细，synchronized 只锁定当前链表或红黑二叉树的首节点。</li>
</ul>
<h3 id="1-3-JUC并发编程"><a href="#1-3-JUC并发编程" class="headerlink" title="1.3 JUC并发编程"></a>1.3 JUC并发编程</h3><h4 id="1-3-1-线程和进程"><a href="#1-3-1-线程和进程" class="headerlink" title="1.3.1 线程和进程"></a>1.3.1 线程和进程</h4><ul>
<li><strong>进程是程序的一次执行过程，是系统运行程序的基本单位</strong>，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。例如，从Windows任务管理器中可以看到当前运行的进程（.exe 文件的运行）；</li>
<li>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程；</li>
<li><strong>线程与进程相似，但线程是一个比进程更小的执行单位，是独立运行的最小单位，是进程的实体，多个线程可以共享同一进程内的系统资源</strong>。一个进程在其执行的过程中可以产生多个线程；</li>
<li>与进程不同的是，同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程</li>
</ul>
<p>总结：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<h4 id="1-3-2-线程的生命周期和状态"><a href="#1-3-2-线程的生命周期和状态" class="headerlink" title="1.3.2 线程的生命周期和状态"></a>1.3.2 线程的生命周期和状态</h4><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p>
<ul>
<li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li>
<li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li>
<li>BLOCKED ：<strong>阻塞状态，需要等待锁释放</strong>。</li>
<li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>TIME_WAITING：超时等待状态，可以在<strong>指定的时间后自行返回</strong>而不是像 WAITING 那样一直等待。</li>
<li>TERMINATED：终止状态，表示该线程已经运行完毕。</li>
</ul>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p>
<h4 id="1-3-3-什么是上下文切换"><a href="#1-3-3-什么是上下文切换" class="headerlink" title="1.3.3 什么是上下文切换?"></a>1.3.3 什么是上下文切换?</h4><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，等待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的上下文切换。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<p>一句话：<strong>线程切换运行状态，从占用CPU到不占用，和从不占用CPU到占用的过程</strong>。</p>
<h4 id="1-3-4-线程死锁"><a href="#1-3-4-线程死锁" class="headerlink" title="1.3.4 线程死锁"></a>1.3.4 线程死锁</h4><p>线程死锁：</p>
<ul>
<li><p><strong>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止</strong>。</p>
</li>
<li><p>如：线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
</li>
</ul>
<p>线程死锁的四个条件：</p>
<ul>
<li><p>互斥条件：该资源任意一个时刻只由一个线程占用；</p>
</li>
<li><p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；</p>
</li>
<li><p>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源；</p>
</li>
<li><p>循环等待条件：若干线程之间形成一种头尾相接的<strong>循环等待资源</strong>关系。</p>
</li>
</ul>
<h4 id="1-3-5-sleep-方法和-wait-方法对比"><a href="#1-3-5-sleep-方法和-wait-方法对比" class="headerlink" title="1.3.5 sleep() 方法和 wait() 方法对比"></a>1.3.5 sleep() 方法和 wait() 方法对比</h4><p><strong>共同点</strong> ：两者都可以暂停线程的执行。</p>
<p><strong>区别</strong> ：</p>
<ul>
<li><strong>sleep() 方法没有释放锁，而 wait() 方法释放了锁</strong> 。（wait了之后，其它线程可以占用此资源）</li>
<li>wait() 通常被用于线程间交互&#x2F;通信，sleep() 通常被用于暂停执行。</li>
<li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒，或者也可以使用 wait(long timeout) 超时后线程会自动苏醒。</li>
<li>sleep()是Thread类的静态方法，而wait()是Object类中的方法。</li>
</ul>
<p>可以理解为：sleep就是线程睡一会，睡一会起来了接着执行；而wait就是等待状态，需要某些指令来唤醒。</p>
<h4 id="1-3-6-yield-方法和-join-方法对比"><a href="#1-3-6-yield-方法和-join-方法对比" class="headerlink" title="1.3.6 yield() 方法和 join() 方法对比"></a>1.3.6 yield() 方法和 join() 方法对比</h4><ul>
<li><p>yield()方法：让当前运行线程回到就绪状态，以允许具有相同优先级的其他线程获得运行机会。</p>
</li>
<li><p>join()方法：join()方法可以使得一个线程在另一个线程运行结束后再执行，在另一个线程结束前一直处于阻塞状态。如：如果在线程B中调用了线程A的join()方法，这时直到线程A执行完毕后，才会继续执行线程B。</p>
</li>
</ul>
<h4 id="1-3-7-可以直接调用-Thread-类的-run-方法吗？"><a href="#1-3-7-可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="1.3.7 可以直接调用 Thread 类的 run 方法吗？"></a>1.3.7 可以直接调用 Thread 类的 run 方法吗？</h4><ul>
<li>new 一个 Thread，线程进入了新建状态。调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <strong>start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容</strong>，这是真正的多线程工作。；</li>
<li>但是，<strong>直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行</strong>，<strong>并不会在某个线程中执行它</strong>，所以这并不是多线程工作。</li>
</ul>
<p><strong>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p>
<h4 id="1-3-8-JMM"><a href="#1-3-8-JMM" class="headerlink" title="1.3.8 JMM"></a>1.3.8 JMM</h4><ul>
<li>JMM （java内存模型）可以看作是 Java 定义的并发编程相关的一组规范；</li>
<li>抽象了线程和主内存之间的关系；</li>
<li>规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守的和并发相关的原则和规范；</li>
<li>其主要目的是为了简化多线程编程，增强程序的可移植性。</li>
</ul>
<h4 id="1-3-9-指令重排和volatile"><a href="#1-3-9-指令重排和volatile" class="headerlink" title="1.3.9 指令重排和volatile"></a>1.3.9 指令重排和volatile</h4><ul>
<li>为了<strong>提升执行速度&#x2F;性能</strong>，计算机在执行程序代码的时候，会对指令进行重排序；</li>
<li>简单来说，就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行；</li>
<li><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题；</li>
<li>在 Java 中，volatile 关键字可以禁止指令进行重排序优化。</li>
</ul>
<p><strong>volatile：保证变量的可见性。</strong></p>
<p>如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主内存中进行读取。</p>
<p>volatile 关键字能保证数据的可见性，但不能保证数据的原子性，synchronized 关键字两者都能保证。</p>
<p><img src="/2023/03/01/java%E5%85%AB%E8%82%A1/jmm2.png"></p>
<h4 id="1-3-10-乐观锁和悲观锁"><a href="#1-3-10-乐观锁和悲观锁" class="headerlink" title="1.3.10 乐观锁和悲观锁"></a>1.3.10 乐观锁和悲观锁</h4><ul>
<li><p>悲观锁：</p>
<ul>
<li>总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题（比如共享数据被修改）；</li>
<li>所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放；</li>
<li>也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>；</li>
<li>Java 中，synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现；</li>
<li>悲观锁通常多用于写多比较多的情况下（多写场景），避免频繁失败和重试影响性能。</li>
</ul>
</li>
<li><p>乐观锁：</p>
<ul>
<li>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题；</li>
<li>线程可以不停地执行，无需加锁也无需等待，只是<strong>在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了</strong>（具体方法可以使用版本号机制或 CAS 算法）；</li>
<li>在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的；</li>
<li>乐观锁通常多于写比较少的情况下（多读场景），避免频繁加锁影响性能，大大提升了系统的吞吐量。</li>
</ul>
</li>
</ul>
<h4 id="1-3-11-乐观锁的实现——CAS算法"><a href="#1-3-11-乐观锁的实现——CAS算法" class="headerlink" title="1.3.11 乐观锁的实现——CAS算法"></a>1.3.11 乐观锁的实现——CAS算法</h4><ul>
<li><p>CAS（Compare And Swap）的思想很简单：就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p>
</li>
<li><p>CAS 是一个原子操作，即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p>
</li>
</ul>
<p>CAS 涉及到三个操作数：</p>
<ul>
<li><strong>V</strong> ：要更新的变量值(Var)</li>
<li><strong>E</strong> ：预期值(Expected)</li>
<li><strong>N</strong> ：拟写入的新值(New)</li>
</ul>
<p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p>
<p><strong>举一个简单的例子</strong> ：线程 A 要修改变量 i 的值为 6，i 原值为 1（V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题）。</p>
<ol>
<li>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。</li>
<li>i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</li>
</ol>
<p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败（因为要更新的值被一个线程已经改变了），但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>
<h4 id="1-3-12-乐观锁的问题——ABA问题"><a href="#1-3-12-乐观锁的问题——ABA问题" class="headerlink" title="1.3.12 乐观锁的问题——ABA问题"></a>1.3.12 乐观锁的问题——ABA问题</h4><ul>
<li>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 ABA问题。</li>
<li>解决方法：在变量前面追加上<strong>版本号或者时间戳</strong>，需要更新变量时，<strong>检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</strong></li>
</ul>
<h4 id="1-3-13-synchronized-和-volatile-的区别"><a href="#1-3-13-synchronized-和-volatile-的区别" class="headerlink" title="1.3.13 synchronized 和 volatile 的区别"></a>1.3.13 synchronized 和 volatile 的区别</h4><ul>
<li>synchronized 和 volatile 是互补的存在，而不是对立的存在；</li>
</ul>
<ul>
<li>volatile 关键字是线程同步的轻量级实现，所以 volatile 性能肯定比 synchronized 关键字要好；</li>
<li>volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块；</li>
<li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性，synchronized 关键字两者都能保证。</li>
<li><strong>volatile 关键字主要用于解决变量在多个线程之间的可见性</strong>，而 <strong>synchronized 关键字解决的是多个线程之间访问资源的同步性</strong>。</li>
</ul>
<h4 id="1-3-14-Synchronized和Lock（ReentrantLock）的区别"><a href="#1-3-14-Synchronized和Lock（ReentrantLock）的区别" class="headerlink" title="1.3.14 Synchronized和Lock（ReentrantLock）的区别"></a>1.3.14 Synchronized和Lock（ReentrantLock）的区别</h4><ul>
<li>synchronized是关键字，Lock是一个类；</li>
<li><strong>synchronized在发生异常时会自动释放锁，Lock需要手动释放锁</strong>；</li>
<li>synchronized 依赖于 JVM（虚拟机层面，我们看不到方法的使用） 而 ReentrantLock 依赖于 API（也算jdk层面，需要使用 lock() 和 unlock() 方法来完成）；</li>
<li>synchronized是可重入锁、非公平锁、不可中断锁，Lock是可重入锁，可中断锁，可以是公平锁；<ul>
<li>可重入锁：也叫递归锁，指的是<strong>线程可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁；</li>
<li>公平锁：<strong>锁被释放之后，先申请的线程先得到锁</strong>。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁；</li>
<li>可中断锁：获取锁的过程中可以被中断，不需要一直等到获取锁之后才能进行其他逻辑处理。</li>
</ul>
</li>
</ul>
<h4 id="1-3-15-ThreadLocal原理"><a href="#1-3-15-ThreadLocal原理" class="headerlink" title="1.3.15 ThreadLocal原理"></a>1.3.15 ThreadLocal原理</h4><ul>
<li>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的，如果想实现每一个线程都有自己的专属本地变量，就需要ThreadLocal；</li>
<li>ThreadLocal 类主要解决的就是让每个线程绑定自己的值，不同线程之间不可见，保证线程安全。可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据；</li>
<li>具体的，每个线程内部都维护了一个ThreadLocalMap，key为 ThreadLocal的实例，value为要保存的副本。</li>
</ul>
<h4 id="1-3-16-ThreadLocal的内存泄露问题是怎么导致的？"><a href="#1-3-16-ThreadLocal的内存泄露问题是怎么导致的？" class="headerlink" title="1.3.16 ThreadLocal的内存泄露问题是怎么导致的？"></a>1.3.16 ThreadLocal的内存泄露问题是怎么导致的？</h4><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉，从而产生内存泄漏。</p>
<h4 id="1-3-17-线程池的参数有哪些？"><a href="#1-3-17-线程池的参数有哪些？" class="headerlink" title="1.3.17 线程池的参数有哪些？"></a>1.3.17 线程池的参数有哪些？</h4><p>线程池：管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>
<p>ThreadPoolExecutor 3 个最重要的参数：</p>
<ul>
<li><strong>corePoolSize</strong>：任务队列未达到队列容量时，最大可以同时运行的线程数量，即<strong>核心线程数</strong>；</li>
<li><strong>maximumPoolSize</strong>：任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为<strong>最大线程数</strong>；</li>
<li><strong>workQueue</strong>：新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在<strong>队列</strong>中。</li>
</ul>
<p>ThreadPoolExecutor 其他常见参数 :</p>
<ul>
<li><strong>keepAliveTime</strong>：线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime 才会被回收销毁；</li>
<li><strong>unit</strong>：keepAliveTime 参数的时间单位。</li>
<li><strong>threadFactory</strong> ：executor 创建新线程的时候会用到。</li>
<li><strong>handler</strong>：饱和策略。关于饱和策略下面单独介绍一下。</li>
</ul>
<h3 id="1-4-设计模式"><a href="#1-4-设计模式" class="headerlink" title="1.4 设计模式"></a>1.4 设计模式</h3><h3 id="1-5-JVM"><a href="#1-5-JVM" class="headerlink" title="1.5 JVM"></a>1.5 JVM</h3><h2 id="2-MySQL"><a href="#2-MySQL" class="headerlink" title="2. MySQL"></a>2. MySQL</h2><h3 id="2-1-数据源"><a href="#2-1-数据源" class="headerlink" title="2.1 数据源"></a>2.1 数据源</h3><h4 id="2-1-1-MyISAM-和-InnoDB-有什么区别"><a href="#2-1-1-MyISAM-和-InnoDB-有什么区别" class="headerlink" title="2.1.1 MyISAM 和 InnoDB 有什么区别"></a>2.1.1 MyISAM 和 InnoDB 有什么区别</h4><ul>
<li>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，MySQL5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎；</li>
<li>MyISAM 只有表级锁，而 InnoDB 支持行级锁，也就是说，<strong>MyISAM 一锁就是锁住了整张表，而 InnoDB 可以只锁住某几行数据，并发时性能更好</strong>；</li>
<li>MyISAM 不提供事务支持，<strong>InnoDB 提供事务支持</strong>；</li>
<li>MyISAM 不支持外键，而 <strong>InnoDB 支持外键</strong>，外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗；</li>
<li><strong>数据库异常崩溃后，InnoDB 能够安全恢复</strong>，而MyISAM不能。使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态；</li>
<li>MyISAM不支持MVCC，而InnoDB支持（MVVC是行级锁的优化）；<ul>
<li>MVCC是多版本并发控制，为每次事务生成一个新版本数据，每个事务都由自己的版本，从而不加锁就决绝读写冲突；</li>
</ul>
</li>
<li>索引实现方式不同，虽然都是B+ Tree，但 <strong>InnoDB 引擎中，其数据文件本身就是索引文件</strong>，而 MyISAM 的索引文件和数据文件是分离的；</li>
<li>InnoDB 的性能比 MyISAM 更强大。</li>
</ul>
<h3 id="2-2-MySQL索引"><a href="#2-2-MySQL索引" class="headerlink" title="2.2 MySQL索引"></a>2.2 MySQL索引</h3><h4 id="2-2-1-MySQL索引介绍"><a href="#2-2-1-MySQL索引介绍" class="headerlink" title="2.2.1 MySQL索引介绍"></a>2.2.1 MySQL索引介绍</h4><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构，Mysql中底层都为B+ Tree。</p>
<ul>
<li><p>优点：</p>
<ul>
<li><strong>使用索引可以大大加快数据的检索速度</strong>（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率；</p>
</li>
<li><p>索引需要使用物理文件存储，也会耗费一定空间。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-2-MySQL有哪些索引"><a href="#2-2-2-MySQL有哪些索引" class="headerlink" title="2.2.2 MySQL有哪些索引"></a>2.2.2 MySQL有哪些索引</h4><ul>
<li><p>主键索引：一张表只能有一个主键索引，<strong>主键索引列不能有空值和重复值</strong></p>
<ul>
<li>对于InnoDB：若没有设置主键索引，会自动找没有空值和重复值的列，作为主键索引；</li>
<li>若还是没有，则会自动创建一个6Byte的自增主键。</li>
</ul>
</li>
<li><p>唯一索引：唯一索引不能有相同值，但允许为空</p>
</li>
<li><p>普通索引：允许出现重复值</p>
</li>
<li><p>组合索引：对多个字段建立一个联合索引，减少索引开销，遵循最左匹配原则</p>
</li>
<li><p>全文索引：myisam引擎支持，通过建立倒排索引提升检索效率，广泛用于搜索引擎</p>
</li>
</ul>
<h4 id="2-2-3-MySQL索引的数据结构"><a href="#2-2-3-MySQL索引的数据结构" class="headerlink" title="2.2.3 MySQL索引的数据结构"></a>2.2.3 MySQL索引的数据结构</h4><ul>
<li><p>为什么不用hash表进行存储：</p>
<ul>
<li>hash表进行查找很快，但是： <strong>Hash 索引不支持顺序和范围查询</strong>。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。<ul>
<li>即：如果要查找一个范围，hash索引需要对范围内的每一个数进行hash地址计算，查找… 这一系列计算，效率较低；</li>
</ul>
</li>
</ul>
</li>
<li><p>B+树和B树的对比：</p>
<ul>
<li>B（Balance） 树也称 B-树，全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构；</li>
<li><strong>B 树的所有节点既存放键（key）也存放数据（data）</strong>，而<strong>B+树只有叶子节点存放 key 和 data，其他节点只存放 key</strong>；</li>
<li>B 树的叶子节点都是独立的，B+树的叶子节点有一条引用链指向与它相邻的叶子节点；</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做<strong>二分查找，可能还没有到达叶子节点，检索就结束了</strong>。而 B+树的检索效率就很稳定了，<strong>任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显</strong>。</li>
</ul>
</li>
</ul>
<h4 id="2-2-4-聚簇索引和非聚簇索引的区别"><a href="#2-2-4-聚簇索引和非聚簇索引的区别" class="headerlink" title="2.2.4 聚簇索引和非聚簇索引的区别"></a>2.2.4 聚簇索引和非聚簇索引的区别</h4><ul>
<li><p>聚簇索引（InnoDB中的索引）：将索引和值放在了一起，根据索引可以直接获取值，如果主键值很大的话，辅助索引也会变得很大</p>
<ul>
<li>InnoDB 表数据文件本身就是主索引，而其余的索引都作为辅助索引 ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。<strong>根据主索引搜索时，直接找到 key 所在的节点即可取出数据</strong>；在<strong>根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引</strong></li>
</ul>
</li>
<li><p>非聚簇索引（MyISAM中的索引）：叶子节点存放的是数据行地址，先根据索引找到数据地址，再根据地址去找数据</p>
<ul>
<li>在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。</li>
</ul>
</li>
<li><p>二者底层都是B+ Tree。</p>
</li>
</ul>
<h4 id="2-2-5-索引什么时候会失效"><a href="#2-2-5-索引什么时候会失效" class="headerlink" title="2.2.5 索引什么时候会失效"></a>2.2.5 索引什么时候会失效</h4><p>索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：</p>
<ul>
<li>使用 SELECT * 进行查询;</li>
<li>创建了组合索引，但查询条件未准守最左匹配原则;</li>
<li>在索引列上进行计算、函数、类型转换等操作;</li>
<li>以 % 开头的 LIKE 查询比如 like ‘%abc’;</li>
<li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li>
<li>发生隐式转换</li>
</ul>
<h3 id="2-3-MySQL日志"><a href="#2-3-MySQL日志" class="headerlink" title="2.3 MySQL日志"></a>2.3 MySQL日志</h3><h4 id="2-3-1-binlog-和-redolog-有什么区别？"><a href="#2-3-1-binlog-和-redolog-有什么区别？" class="headerlink" title="2.3.1 binlog 和 redolog 有什么区别？"></a>2.3.1 binlog 和 redolog 有什么区别？</h4><ul>
<li>binlog是一个二进制格式的文件，用于<strong>记录用户对数据库更新的SQL语句信息</strong>，例如更改数据库表和更改内容的SQL语句都会记录到binlog里，但是对库表等内容的<strong>查询不会记录</strong>。<ul>
<li>即：只记录update&#x2F;insert&#x2F;delete&#x2F;truncate，不记录select</li>
<li>作用：做数据恢复和主从复制</li>
</ul>
</li>
<li>redolog是记录数据的变化，当执行update操作时，mysql底层会把这条数据所在的页加载到内存，然后在内存中将对应记录进行修改，<strong>内存写完之后其实会写redolog，这份redolog记录着这次在某个页上做了什么修改。</strong><ul>
<li>作用：我们修改数据，写完内存，但是数据还没有真正写到磁盘的时候，此时我们的<strong>数据库挂掉了</strong>，我们就<strong>可以根据redo log对数据进行恢复；</strong></li>
</ul>
</li>
<li>binlog和redolog的对比：<ul>
<li>存储的内容不同，binlog记录的是实实在在的sql语句（数据的逻辑变化），而redolog记录的是xx页做了xx修改（数据的物理变化）;</li>
<li>功能不同， binlog主要是为了数据的复制和恢复来使用，如果说整个数据库不小心被删除了，而binlog存储着所有数据的变更情况，这个时候其实是可以通过binlog来恢复数据的；</li>
<li>redolog它的作用主要是用来恢复内存当中还没来得及刷入磁盘的数据，将redolog加载到内存里面，内存就能恢复到挂掉之前的数据；</li>
<li>那么redo log可以用来恢复数据库误删的数据吗？不可以，因为redolog它其实只是记录着物理数据的变化，<strong>如果内存中的数据已经刷入到磁盘，那其实redolog的数据就无效了</strong>，所以redo log其实并不会存储历史所有数据的变化，文件的内容会被覆盖的。</li>
</ul>
</li>
<li>undolog：<ul>
<li>存储的也是逻辑日志，比如说我们要insert一条语句，那么undolog就记录着一条delete语句，所以说它可以用来做回滚；</li>
<li>作用：用来回滚和mvcc多版本控制。</li>
</ul>
</li>
</ul>
<h3 id="2-4-MySQL事务"><a href="#2-4-MySQL事务" class="headerlink" title="2.4 MySQL事务"></a>2.4 MySQL事务</h3><h4 id="2-4-1-事务的特性"><a href="#2-4-1-事务的特性" class="headerlink" title="2.4.1 事务的特性"></a>2.4.1 事务的特性</h4><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行</strong></p>
<p>关系型数据库（例如：MySQL、SQL Server、Oracle等）事务都有 <strong>ACID</strong> 特性：</p>
<ul>
<li><strong>原子性</strong>（<code>Atomicity</code>） ：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>（<code>Consistency</code>）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不被其他事务所干扰，<strong>各并发事务之间数据库是独立的</strong>；</li>
<li><strong>持久性</strong>（<code>Durability</code>）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h4 id="2-4-2-并发的事务会导致哪些问题？"><a href="#2-4-2-并发的事务会导致哪些问题？" class="headerlink" title="2.4.2 并发的事务会导致哪些问题？"></a>2.4.2 并发的事务会导致哪些问题？</h4><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题:</p>
<ul>
<li>脏读（Dirty read）<ul>
<li><strong>一个事务读取数据并且对数据进行了修改</strong>，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时<strong>另外一个事务读取了这个还未提交的数据</strong>，但<strong>第一个事务突然回滚（出现故障）</strong>，导致<strong>数据并没有被提交到数据库</strong>，那<strong>第二个事务读取到的就是脏数据</strong>，这也就是脏读的由来。</li>
<li>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 读取到 A&#x3D;19，事务 1 回滚导致对 A 的修改并未提交到数据库， A 的值还是 20。</li>
</ul>
</li>
<li>不可重复读（Unrepeatable read）<ul>
<li>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了<strong>在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</strong></li>
<li>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 再次读取 A &#x3D;19，此时读取的结果和第一次读取的结果不同。</li>
</ul>
</li>
<li>幻读（Phantom read）<ul>
<li>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现<strong>多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读</strong>。</li>
<li>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</li>
</ul>
</li>
</ul>
<h4 id="2-4-3-不可重复读和幻读有什么区别？"><a href="#2-4-3-不可重复读和幻读有什么区别？" class="headerlink" title="2.4.3 不可重复读和幻读有什么区别？"></a>2.4.3 不可重复读和幻读有什么区别？</h4><ul>
<li>不可重复读的重点是<strong>内容修改</strong>或者<strong>记录减少</strong>，比如多次读取一条记录发现其中某些记录的值被修改；</li>
<li>幻读的重点在于<strong>记录新增</strong>，比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了</li>
</ul>
<h3 id="2-5-MySQL锁"><a href="#2-5-MySQL锁" class="headerlink" title="2.5 MySQL锁"></a>2.5 MySQL锁</h3><h4 id="2-5-1-Mysql锁的类型"><a href="#2-5-1-Mysql锁的类型" class="headerlink" title="2.5.1 Mysql锁的类型"></a>2.5.1 Mysql锁的类型</h4><ul>
<li><p>基于粒度：</p>
<ul>
<li>表级锁：对整张表加锁，粒度大并发小；</li>
<li>行级锁：对行加锁，粒度小并发大</li>
<li>间隙锁：间隙锁，锁住表的一个区间，间隙锁之间不会冲突只在可重复读下才生效，解决了幻读</li>
</ul>
</li>
<li><p>基于属性：</p>
<ul>
<li>共享锁：又称读锁，一个事务为表加了读锁，其它事务只能加读锁，不能加写锁<ul>
<li>即：允许多个事务同时获取</li>
</ul>
</li>
<li>排他锁：又称写锁，一个事务加写锁之后，其他事务不能再加任何锁，避免脏读问题<ul>
<li>即：事务在修改记录的时候获取排他锁，不允许多个事务同时获取</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>MVCC</strong>：是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来<strong>为每一行数据设置版本号</strong>，版本号是唯一的。MVCC可以理解为乐观锁，<strong>更新时与版本对应就能够完成更新。</strong></p>
</li>
</ul>
<h4 id="2-5-2-InnoDB-有哪几类行锁？"><a href="#2-5-2-InnoDB-有哪几类行锁？" class="headerlink" title="2.5.2 InnoDB 有哪几类行锁？"></a>2.5.2 InnoDB 有哪几类行锁？</h4><p>InnoDB 行锁是通过<strong>对索引数据页上的记录加锁实现的</strong>，MySQL InnoDB 支持三种行锁定方式：</p>
<ul>
<li><strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</li>
<li><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</li>
<li><strong>临键锁（Next-Key Lock）</strong> ：Record Lock+Gap Lock，<strong>锁定一个范围，包含记录本身</strong>，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
<p>在 InnoDB 行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</p>
<h3 id="2-6-MySQL调优"><a href="#2-6-MySQL调优" class="headerlink" title="2.6 MySQL调优"></a>2.6 MySQL调优</h3><h4 id="2-6-1-MySQL有哪些调优方法"><a href="#2-6-1-MySQL有哪些调优方法" class="headerlink" title="2.6.1 MySQL有哪些调优方法"></a>2.6.1 MySQL有哪些调优方法</h4><ul>
<li>避免使用select *：select *会查询所有字段，实际业务场景中不需要所有的字段，可以不进行查询；</li>
<li>高效的分页：分页时找到上次分页最大id，并进行查找；<ul>
<li>如：select id,name,age from user limit 10000, 20：mysql会查询10020条，然后丢弃前面10000条，这个比较浪费资源；</li>
<li>可以优化为：select id,name,age from user id&gt;10000 limit 20：找到上次分页最大id，并查询20条；</li>
</ul>
</li>
<li>适当避免多表做join：join表不宜超过3个，如果<strong>join太多，MySQL在选择索引时会非常复杂</strong>，很容易选错索引；</li>
<li>尽量不要使用外键和级联；</li>
<li>选择合理的字段类型：能用数字类型就不用字符串，字符串处理速度比数字类型慢；</li>
<li>进行批量操作：当然一次插入量也不能太大，可以分批插入。</li>
<li>用union all 代替union：union会排重，排重过程需要遍历，排序，比较，更消耗cpu资源。在确定唯一，没有重复数据的情况下，尽量用union all。（union all就是一次执行多条语句）</li>
</ul>
<h4 id="2-6-2-如何优化慢查询？"><a href="#2-6-2-如何优化慢查询？" class="headerlink" title="2.6.2 如何优化慢查询？"></a>2.6.2 如何优化慢查询？</h4><ul>
<li>超过指定时间的SQL语句查询称为慢查询；</li>
<li>慢查询的优化方法：<ul>
<li>分析sql语句，是否加载了不需要的数据列</li>
<li>分析sql执行计划，字段有没有索引，索引是否失效，是否用对索引</li>
<li>表中数据是否太大，是不是要分库分表</li>
</ul>
</li>
</ul>
<h2 id="3-Redis"><a href="#3-Redis" class="headerlink" title="3. Redis"></a>3. Redis</h2><h3 id="3-1-与Mysql的对比"><a href="#3-1-与Mysql的对比" class="headerlink" title="3.1 与Mysql的对比"></a>3.1 与Mysql的对比</h3><h4 id="3-1-1-Redis和Mysql的区别"><a href="#3-1-1-Redis和Mysql的区别" class="headerlink" title="3.1.1 Redis和Mysql的区别"></a>3.1.1 Redis和Mysql的区别</h4><ul>
<li><p>mysql是关系型数据库，数据都存储在硬盘中，读取速度慢，但可以长期存放；</p>
</li>
<li><p>redis是非关系型数据库，数据存储在缓存中，读取速度快，但保存时间有限；</p>
</li>
<li><p>redis数据库性能更好，mysql数据库安全性更高，在实际开发中，经常会配合使用两种数据库。</p>
</li>
</ul>
<p>补充：</p>
<ul>
<li><p>关系型数据库：列+行（一对一，一对多，多对一），同一个表下数据的结构是一样的；</p>
</li>
<li><p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展；</p>
</li>
<li><p>Redis的读写速度：2W&#x2F;s，1s能读取上万条；</p>
</li>
<li><p>MySql的读写速度：读5K&#x2F;s，写3K&#x2F;s</p>
</li>
</ul>
<h4 id="3-1-2-Redis和Mysql数据一致性问题"><a href="#3-1-2-Redis和Mysql数据一致性问题" class="headerlink" title="3.1.2 Redis和Mysql数据一致性问题"></a>3.1.2 Redis和Mysql数据一致性问题</h4><ul>
<li><p><strong>在满足实时性的条件下，不存在两者完全保存一致的方案，只有最终一致性方案</strong>；</p>
</li>
<li><p><strong>先写Mysql，再写Redis：</strong>对于并发量、一致性要求不高的项目，可以这样做；</p>
<ul>
<li>如果并发量大了，会出现一致性问题，如果数据更新了，多个线程读取的数据会不一样；</li>
</ul>
</li>
<li><p><strong>先写Mysql，再删除Redis：</strong>是实时性最好的方案，比较推荐；</p>
<ul>
<li>在高并发的场景下，比较推荐，因为把缓存删掉了，不会出现不同步的问题；</li>
<li>会出现一次不同步的情况，就是在删除redis之前进行查询，因为没有对redis进行操作，因此如果是强一致性要求的业务，不建议使用。</li>
</ul>
</li>
<li><p>延时双删：先删除缓存，再更新数据库，然后休眠1s（根据具体的业务合理设置，比如几百毫秒），再删除缓存，有可能第二次删除失败，还是会导致数据不一致；</p>
<ul>
<li>延时会导致服务器阻塞，不适用于高并发场景；</li>
</ul>
</li>
<li><p><strong>先写 MySQL，通过 Binlog，异步更新 Redis：</strong>这种方案，主要是监听 MySQL 的 Binlog，然后通过异步的方式，将数据更新到 Redis。适用于高并发场景。</p>
<ul>
<li>本质：设置一个消息队列，监听Mysql的更新变化，一旦更新，就更新redis</li>
</ul>
</li>
</ul>
<p>补充：面试时，就按加粗的方式说，可以补充说明延时双删，但都要指出缺点。</p>
<h3 id="3-2-Redis的数据结构"><a href="#3-2-Redis的数据结构" class="headerlink" title="3.2 Redis的数据结构"></a>3.2 Redis的数据结构</h3><h4 id="3-2-1-Redis-常用的数据结构有哪些"><a href="#3-2-1-Redis-常用的数据结构有哪些" class="headerlink" title="3.2.1 Redis 常用的数据结构有哪些"></a>3.2.1 Redis 常用的数据结构有哪些</h4><ul>
<li><strong>5 种基础数据结构</strong> ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>
<li><strong>3 种特殊数据结构</strong> ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li>
</ul>
<h4 id="3-2-2-Redis中String和Hash存放对象数据的区别"><a href="#3-2-2-Redis中String和Hash存放对象数据的区别" class="headerlink" title="3.2.2 Redis中String和Hash存放对象数据的区别"></a>3.2.2 Redis中String和Hash存放对象数据的区别</h4><ul>
<li>Redis hash 本质是一个string类型的field和value的映射表，类型也是String类型；</li>
<li>String 存储的是序列化后的对象数据，<strong>存放的是整个对象</strong>；Hash 是对<strong>对象的每个字段单独存储，可以获取部分字段的信息</strong>；</li>
<li>String 存储相对来说<strong>更加节省内存</strong>，缓存相同数量的对象数据，<strong>String 消耗的内存约是 Hash 的一半</strong>；</li>
<li>在绝大部分情况，我们建议使用 String 来存储对象数据即可。</li>
</ul>
<h3 id="3-3-Redis持久化机制"><a href="#3-3-Redis持久化机制" class="headerlink" title="3.3 Redis持久化机制"></a>3.3 Redis持久化机制</h3><h4 id="3-3-1-怎么保证-Redis-挂掉之后再重启数据可以进行恢复？"><a href="#3-3-1-怎么保证-Redis-挂掉之后再重启数据可以进行恢复？" class="headerlink" title="3.3.1 怎么保证 Redis 挂掉之后再重启数据可以进行恢复？"></a>3.3.1 怎么保证 Redis 挂掉之后再重启数据可以进行恢复？</h4><ul>
<li><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>
</li>
<li><p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。</p>
</li>
</ul>
<h4 id="3-3-2-什么是RDB持久化？"><a href="#3-3-2-什么是RDB持久化？" class="headerlink" title="3.3.2 什么是RDB持久化？"></a>3.3.2 什么是RDB持久化？</h4><ul>
<li><p>在<strong>指定时间间隔</strong>后，将<strong>内存中的数据集快照写入数据库（RDB二进制文件，保存在硬盘中）</strong> ；在恢复的时候，直接读取快照文件，进行数据的恢复 ；</p>
</li>
<li><p>具体步骤：</p>
<ul>
<li>Redis 调用forks，同时拥有父进程和子进程；</li>
<li>子进程将数据集写入到一个临时 RDB 文件中；</li>
<li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li>
</ul>
</li>
</ul>
<h4 id="3-3-3-什么是AOF持久化？"><a href="#3-3-3-什么是AOF持久化？" class="headerlink" title="3.3.3 什么是AOF持久化？"></a>3.3.3 什么是AOF持久化？</h4><ul>
<li><strong>将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍；</strong></li>
<li>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据；</li>
<li>换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</li>
</ul>
<h4 id="3-3-4-如何选择使用哪种持久化方式？"><a href="#3-3-4-如何选择使用哪种持久化方式？" class="headerlink" title="3.3.4 如何选择使用哪种持久化方式？"></a>3.3.4 如何选择使用哪种持久化方式？</h4><ul>
<li>一般来说， 如果想达到足以媲美 PostgreSQL 的<strong>数据安全性， 你应该同时使用两种持久化功能</strong>；</li>
<li>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化；</li>
<li>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</li>
</ul>
<h3 id="3-4-Redis生产问题"><a href="#3-4-Redis生产问题" class="headerlink" title="3.4 Redis生产问题"></a>3.4 Redis生产问题</h3><h4 id="3-4-1-缓存穿透（查不到）"><a href="#3-4-1-缓存穿透（查不到）" class="headerlink" title="3.4.1 缓存穿透（查不到）"></a>3.4.1 缓存穿透（查不到）</h4><p>缓存穿透说简单点就是<strong>大量请求的 key 是不合理的</strong>，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>布隆过滤器</strong></p>
<p>对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。</p>
<p><strong>缓存空对象</strong></p>
<p>一次请求若在缓存和数据库中都没找到，就在缓存中创建一个空对象用于处理后续这个请求。</p>
<h4 id="3-4-2-缓存击穿（量太大，缓存过期）"><a href="#3-4-2-缓存击穿（量太大，缓存过期）" class="headerlink" title="3.4.2 缓存击穿（量太大，缓存过期）"></a>3.4.2 缓存击穿（量太大，缓存过期）</h4><ul>
<li><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
</li>
<li><p>比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p>
</li>
</ul>
<blockquote>
<p>解决方案</p>
</blockquote>
<ol>
<li><p><strong>设置热点数据永不过期</strong></p>
<p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。</p>
</li>
<li><p><strong>加互斥锁(分布式锁)</strong></p>
<p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。（注意：这个也是Redis设计分布式锁的方法）</p>
</li>
</ol>
<h4 id="3-4-3-缓存雪崩"><a href="#3-4-3-缓存雪崩" class="headerlink" title="3.4.3 缓存雪崩"></a>3.4.3 缓存雪崩</h4><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时数据库请求量大、压力骤增，引起雪崩。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<ul>
<li><p>redis高可用</p>
<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</p>
</li>
<li><p>限流降级</p>
<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对<strong>某个key只允许一个线程查询数据和写缓存，其他线程等待</strong>。</p>
</li>
<li><p>数据预热</p>
<p>数据加热的含义就是在正式部署之前，我先<strong>把可能的数据先预先访问一遍</strong>，这样部分可能大量访问的数据就会加载到缓存中。在即将<strong>发生大并发访问前</strong>手动触发加载缓存不同的key，<strong>设置不同的过期时间</strong>，让缓存失效的时间点尽量均匀。</p>
</li>
</ul>
<h2 id="4-计算机基础"><a href="#4-计算机基础" class="headerlink" title="4. 计算机基础"></a>4. 计算机基础</h2><h3 id="4-1-网络分层模型"><a href="#4-1-网络分层模型" class="headerlink" title="4.1 网络分层模型"></a>4.1 网络分层模型</h3><h4 id="4-1-1-OSI七层模型"><a href="#4-1-1-OSI七层模型" class="headerlink" title="4.1.1 OSI七层模型"></a>4.1.1 OSI七层模型</h4><p>OSI 七层模型 是<strong>国际标准化组织</strong>提出一个网络分层模型，其大体结构以及每一层提供的功能如下：（从高到低）</p>
<ul>
<li><p>应用层：为计算机用户提供<strong>服务</strong>；</p>
</li>
<li><p>表示层：数据的处理，<strong>信息的语义转换</strong>；</p>
</li>
<li><p>会话层：管理<strong>程序间的通话</strong>；</p>
</li>
<li><p>传输层：为两台主机进程之间的通信提供<strong>数据传输服务</strong>；</p>
</li>
<li><p>网络层：控制<strong>子网的运行</strong>（路由和寻址）；</p>
</li>
<li><p>数据链路层：物理寻址，将比特流转换为逻辑传输线路；</p>
</li>
<li><p>物理层：原始比特流传输</p>
</li>
</ul>
<h4 id="4-1-2-TCP-x2F-IP四层模型"><a href="#4-1-2-TCP-x2F-IP四层模型" class="headerlink" title="4.1.2 TCP&#x2F;IP四层模型"></a>4.1.2 TCP&#x2F;IP四层模型</h4><p><strong>TCP&#x2F;IP 四层模型</strong> 是目前被广泛采用的一种模型，我们可以将 TCP &#x2F; IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p>
<ul>
<li>应用层：<strong>终端设备上的应用程序</strong>之间信息交换的服务——应用层，表示层，会话层</li>
<li>传输层：负责向两台终端设备进程之间的通信提供通用的<strong>数据传输服务</strong>——传输层</li>
<li>网络层：为分组交换网上的不同主机<strong>提供通信服务</strong>——网络层</li>
<li>网络接口层：提供网络接口——数据链路层，物理层</li>
</ul>
<h4 id="4-1-3-为什么要进行网络分层？"><a href="#4-1-3-为什么要进行网络分层？" class="headerlink" title="4.1.3 为什么要进行网络分层？"></a>4.1.3 为什么要进行网络分层？</h4><ul>
<li>各层相互独立；</li>
<li>提高整体灵活性；</li>
<li>每一层只专注于做一类事情，大事化小。</li>
</ul>
<h3 id="4-2-传输层协议——TCP和UDP"><a href="#4-2-传输层协议——TCP和UDP" class="headerlink" title="4.2 传输层协议——TCP和UDP"></a>4.2 传输层协议——TCP和UDP</h3><h4 id="4-2-1-TCP和UDP的区别"><a href="#4-2-1-TCP和UDP的区别" class="headerlink" title="4.2.1 TCP和UDP的区别"></a>4.2.1 TCP和UDP的区别</h4><ul>
<li><p>是否面向连接：<strong>UDP 在传送数据之前不需要先建立连接</strong>。<strong>TCP 在传送数据之前必须先建立连接，数据传送结束后要释放连接</strong>；</p>
</li>
<li><p>是否是可靠传输：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，<strong>TCP 在传递数据之前，会有三次握手来建立连接</strong>，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p>
</li>
<li><p>是否有状态：TCP 传输是有状态的，这个有状态说的是 <strong>TCP 会去记录自己发送消息的状态</strong>比如消息是否发送了、是否被接收了等等。而 UDP 是无状态服务，简单来说就是<strong>不管发出去之后的事情了</strong>。</p>
</li>
<li><p>传输效率：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 <strong>TCP 的传输效率要比 UDP 低</strong>很多。</p>
</li>
<li><p>传输形式： TCP 是面向字节流的，UDP 是面向报文的。</p>
</li>
<li><p>首部开销：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</p>
</li>
<li><p>是否提供广播或多播服务：<strong>TCP 只支持点对点通信</strong>，UDP 支持一对一、一对多、多对一、多对多；</p>
</li>
</ul>
<h4 id="4-2-2-什么时候选择-TCP，什么时候选-UDP"><a href="#4-2-2-什么时候选择-TCP，什么时候选-UDP" class="headerlink" title="4.2.2  什么时候选择 TCP，什么时候选 UDP?"></a>4.2.2  什么时候选择 TCP，什么时候选 UDP?</h4><ul>
<li><strong>UDP 一般用于即时通信</strong>，比如：语音、视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大；</li>
<li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</li>
</ul>
<h4 id="4-2-3-TCP-三次握手"><a href="#4-2-3-TCP-三次握手" class="headerlink" title="4.2.3 TCP 三次握手"></a>4.2.3 TCP 三次握手</h4><p>建立一个 TCP 连接需要“三次握手”，缺一不可 ：</p>
<ul>
<li><strong>一次握手</strong>：客户端发送带有 <strong>SYN</strong>（SEQ&#x3D;x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</li>
<li><strong>二次握手</strong>：服务端发送带有 SYN+<strong>ACK</strong>（SEQ&#x3D;y,ACK&#x3D;x+1）标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</li>
<li><strong>三次握手</strong>：客户端发送带有 ACK（ACK&#x3D;y+1）标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成TCP三次握手。</li>
</ul>
<p><strong>当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！</strong></p>
<p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<ol>
<li><strong>第一次握手</strong> ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li><strong>第二次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li><strong>第三次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ol>
<p>三次握手就能确认双方收发功能都正常，缺一不可。</p>
<h4 id="4-2-4-TCP四次挥手"><a href="#4-2-4-TCP四次挥手" class="headerlink" title="4.2.4 TCP四次挥手"></a>4.2.4 TCP四次挥手</h4><p>断开一个 TCP 连接则需要“四次挥手”，缺一不可 ：</p>
<ol>
<li><strong>第一次挥手</strong> ：客户端发送一个 <strong>FIN</strong>（SEQ&#x3D;X）标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li>
<li><strong>第二次挥手</strong> ：服务器收到这个 FIN（SEQ&#x3D;X）标志的数据包，它发送一个 <strong>ACK</strong>（SEQ&#x3D;X+1）标志的数据包-&gt;客户端 。然后，此时服务端进入<strong>CLOSE-WAIT</strong>状态，客户端进入<strong>FIN-WAIT-2</strong>状态。</li>
<li><strong>第三次挥手</strong> ：服务端关闭与客户端的连接并发送一个 FIN（SEQ&#x3D;y）标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入<strong>LAST-ACK</strong>状态。</li>
<li><strong>第四次挥手</strong> ：客户端发送 ACK （SEQ&#x3D;y+1）标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK（SEQ&#x3D;y+1）标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</li>
</ol>
<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p>
<p>TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后。</p>
<ol>
<li><strong>第一次挥手</strong> ： A 说“我没啥要说的了”</li>
<li><strong>第二次挥手</strong> ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li>
<li><strong>第三次挥手</strong> ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li>
<li><strong>第四次挥手</strong> ：A 回答“知道了”，这样通话才算结束。</li>
</ol>
<h4 id="4-2-5-为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？"><a href="#4-2-5-为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？" class="headerlink" title="4.2.5 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？"></a>4.2.5 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h4><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>
<h4 id="4-2-6-如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？"><a href="#4-2-6-如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？" class="headerlink" title="4.2.6 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？"></a>4.2.6 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h4><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p>
<h4 id="4-2-7-为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？"><a href="#4-2-7-为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？" class="headerlink" title="4.2.7 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？"></a>4.2.7 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h4><p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>
<blockquote>
<p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p>
</blockquote>
<h3 id="4-3-网络层协议——HTTP"><a href="#4-3-网络层协议——HTTP" class="headerlink" title="4.3 网络层协议——HTTP"></a>4.3 网络层协议——HTTP</h3><h4 id="4-3-1-从输入URL-到页面展示到底发生了什么？"><a href="#4-3-1-从输入URL-到页面展示到底发生了什么？" class="headerlink" title="4.3.1 从输入URL 到页面展示到底发生了什么？"></a>4.3.1 从输入URL 到页面展示到底发生了什么？</h4><p>也即：打开一个网页，整个过程会使用哪些协议？</p>
<p><img src="/2023/03/01/java%E5%85%AB%E8%82%A1/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg"></p>
<blockquote>
<p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p>
</blockquote>
<p>总体来说分为以下几个过程:</p>
<ol>
<li><p>DNS 解析</p>
</li>
<li><p>TCP 连接</p>
</li>
<li><p>发送 HTTP 请求</p>
</li>
<li><p>服务器处理请求并返回 HTTP 报文</p>
</li>
<li><p>浏览器解析渲染页面</p>
</li>
<li><p>连接结束</p>
</li>
</ol>
<h4 id="4-3-2-HTTP-和-HTTPS-有什么区别？"><a href="#4-3-2-HTTP-和-HTTPS-有什么区别？" class="headerlink" title="4.3.2 HTTP 和 HTTPS 有什么区别？"></a>4.3.2 HTTP 和 HTTPS 有什么区别？</h4><ul>
<li><p><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443；</p>
</li>
<li><p><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 http:&#x2F;&#x2F;，HTTPS 的 URL 前缀是 https:&#x2F;&#x2F;；</p>
</li>
<li><p><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，<strong>HTTP 安全性没有 HTTPS 高</strong>，但是 <strong>HTTPS 比 HTTP 耗费更多服务器资源</strong>。</p>
<ul>
<li>HTTPS多了一层，执行了加密，所以更安全。</li>
</ul>
</li>
</ul>
<h2 id="5-操作系统"><a href="#5-操作系统" class="headerlink" title="5. 操作系统"></a>5. 操作系统</h2><h2 id="6-Mybatis"><a href="#6-Mybatis" class="headerlink" title="6. Mybatis"></a>6. Mybatis</h2></div><div class="article-licensing box"><div class="licensing-title"><p>java八股</p><p><a href="http://example.com/2023/03/01/java八股/">http://example.com/2023/03/01/java八股/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Zehao Tian</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-03-01</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-03-01</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/java/">java</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/02/27/JVM/"><span class="level-item">JVM</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/jetpacktocat.png" alt="田泽豪"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">田泽豪</p><p class="is-size-6 is-block">越努力，越幸运</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>HUST</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">53</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">20</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zehtian" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-java基础"><span class="level-left"><span class="level-item">1</span><span class="level-item">1. java基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-java特性"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">1.1 java特性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-1-接口和抽象类的区别"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">1.1.1 接口和抽象类的区别</span></span></a></li><li><a class="level is-mobile" href="#1-1-2-重载和重写的区别"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">1.1.2 重载和重写的区别</span></span></a></li><li><a class="level is-mobile" href="#1-1-3-x3D-x3D-和equals的区别"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">1.1.3 ==和equals的区别</span></span></a></li><li><a class="level is-mobile" href="#1-1-4-Exception-和-Error-的区别"><span class="level-left"><span class="level-item">1.1.4</span><span class="level-item">1.1.4 Exception 和 Error 的区别</span></span></a></li><li><a class="level is-mobile" href="#1-1-5-异常处理机制"><span class="level-left"><span class="level-item">1.1.5</span><span class="level-item">1.1.5 异常处理机制</span></span></a></li><li><a class="level is-mobile" href="#1-1-6-自动拆装箱的原理"><span class="level-left"><span class="level-item">1.1.6</span><span class="level-item">1.1.6 自动拆装箱的原理</span></span></a></li><li><a class="level is-mobile" href="#1-1-7-面向对象和面向过程的区别"><span class="level-left"><span class="level-item">1.1.7</span><span class="level-item">1.1.7 面向对象和面向过程的区别</span></span></a></li><li><a class="level is-mobile" href="#1-1-8-String、StringBuffer、StringBuilder-的区别"><span class="level-left"><span class="level-item">1.1.8</span><span class="level-item">1.1.8 String、StringBuffer、StringBuilder 的区别</span></span></a></li><li><a class="level is-mobile" href="#1-1-9-类的初始化顺序"><span class="level-left"><span class="level-item">1.1.9</span><span class="level-item">1.1.9 类的初始化顺序</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-2-java集合"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">1.2 java集合</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-2-1-ArrayList和Vector的区别"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">1.2.1 ArrayList和Vector的区别</span></span></a></li><li><a class="level is-mobile" href="#1-2-2-ArrayList与LinkedList的区别"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">1.2.2 ArrayList与LinkedList的区别</span></span></a></li><li><a class="level is-mobile" href="#1-2-3-ArrayList与Array的区别"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item">1.2.3 ArrayList与Array的区别</span></span></a></li><li><a class="level is-mobile" href="#1-2-4-ArrayList扩容机制"><span class="level-left"><span class="level-item">1.2.4</span><span class="level-item">1.2.4 ArrayList扩容机制</span></span></a></li><li><a class="level is-mobile" href="#1-2-5-如何保证ArrayList的线程安全"><span class="level-left"><span class="level-item">1.2.5</span><span class="level-item">1.2.5 如何保证ArrayList的线程安全</span></span></a></li><li><a class="level is-mobile" href="#1-2-6-比较HashSet、LinkedHashSet和TreeSet三者的异同"><span class="level-left"><span class="level-item">1.2.6</span><span class="level-item">1.2.6 比较HashSet、LinkedHashSet和TreeSet三者的异同</span></span></a></li><li><a class="level is-mobile" href="#1-2-7-HashSet-如何检查重复"><span class="level-left"><span class="level-item">1.2.7</span><span class="level-item">1.2.7 HashSet 如何检查重复?</span></span></a></li><li><a class="level is-mobile" href="#1-2-8-HashMap-和-Hashtable-的区别"><span class="level-left"><span class="level-item">1.2.8</span><span class="level-item">1.2.8 HashMap 和 Hashtable 的区别</span></span></a></li><li><a class="level is-mobile" href="#1-2-9-HashMap的底层实现"><span class="level-left"><span class="level-item">1.2.9</span><span class="level-item">1.2.9 HashMap的底层实现</span></span></a></li><li><a class="level is-mobile" href="#1-2-10-ConcurrentHashMap-是如何实现线程安全的"><span class="level-left"><span class="level-item">1.2.10</span><span class="level-item">1.2.10 ConcurrentHashMap 是如何实现线程安全的</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-3-JUC并发编程"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">1.3 JUC并发编程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-3-1-线程和进程"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">1.3.1 线程和进程</span></span></a></li><li><a class="level is-mobile" href="#1-3-2-线程的生命周期和状态"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">1.3.2 线程的生命周期和状态</span></span></a></li><li><a class="level is-mobile" href="#1-3-3-什么是上下文切换"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">1.3.3 什么是上下文切换?</span></span></a></li><li><a class="level is-mobile" href="#1-3-4-线程死锁"><span class="level-left"><span class="level-item">1.3.4</span><span class="level-item">1.3.4 线程死锁</span></span></a></li><li><a class="level is-mobile" href="#1-3-5-sleep-方法和-wait-方法对比"><span class="level-left"><span class="level-item">1.3.5</span><span class="level-item">1.3.5 sleep() 方法和 wait() 方法对比</span></span></a></li><li><a class="level is-mobile" href="#1-3-6-yield-方法和-join-方法对比"><span class="level-left"><span class="level-item">1.3.6</span><span class="level-item">1.3.6 yield() 方法和 join() 方法对比</span></span></a></li><li><a class="level is-mobile" href="#1-3-7-可以直接调用-Thread-类的-run-方法吗？"><span class="level-left"><span class="level-item">1.3.7</span><span class="level-item">1.3.7 可以直接调用 Thread 类的 run 方法吗？</span></span></a></li><li><a class="level is-mobile" href="#1-3-8-JMM"><span class="level-left"><span class="level-item">1.3.8</span><span class="level-item">1.3.8 JMM</span></span></a></li><li><a class="level is-mobile" href="#1-3-9-指令重排和volatile"><span class="level-left"><span class="level-item">1.3.9</span><span class="level-item">1.3.9 指令重排和volatile</span></span></a></li><li><a class="level is-mobile" href="#1-3-10-乐观锁和悲观锁"><span class="level-left"><span class="level-item">1.3.10</span><span class="level-item">1.3.10 乐观锁和悲观锁</span></span></a></li><li><a class="level is-mobile" href="#1-3-11-乐观锁的实现——CAS算法"><span class="level-left"><span class="level-item">1.3.11</span><span class="level-item">1.3.11 乐观锁的实现——CAS算法</span></span></a></li><li><a class="level is-mobile" href="#1-3-12-乐观锁的问题——ABA问题"><span class="level-left"><span class="level-item">1.3.12</span><span class="level-item">1.3.12 乐观锁的问题——ABA问题</span></span></a></li><li><a class="level is-mobile" href="#1-3-13-synchronized-和-volatile-的区别"><span class="level-left"><span class="level-item">1.3.13</span><span class="level-item">1.3.13 synchronized 和 volatile 的区别</span></span></a></li><li><a class="level is-mobile" href="#1-3-14-Synchronized和Lock（ReentrantLock）的区别"><span class="level-left"><span class="level-item">1.3.14</span><span class="level-item">1.3.14 Synchronized和Lock（ReentrantLock）的区别</span></span></a></li><li><a class="level is-mobile" href="#1-3-15-ThreadLocal原理"><span class="level-left"><span class="level-item">1.3.15</span><span class="level-item">1.3.15 ThreadLocal原理</span></span></a></li><li><a class="level is-mobile" href="#1-3-16-ThreadLocal的内存泄露问题是怎么导致的？"><span class="level-left"><span class="level-item">1.3.16</span><span class="level-item">1.3.16 ThreadLocal的内存泄露问题是怎么导致的？</span></span></a></li><li><a class="level is-mobile" href="#1-3-17-线程池的参数有哪些？"><span class="level-left"><span class="level-item">1.3.17</span><span class="level-item">1.3.17 线程池的参数有哪些？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-4-设计模式"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">1.4 设计模式</span></span></a></li><li><a class="level is-mobile" href="#1-5-JVM"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">1.5 JVM</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-MySQL"><span class="level-left"><span class="level-item">2</span><span class="level-item">2. MySQL</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-数据源"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">2.1 数据源</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-1-MyISAM-和-InnoDB-有什么区别"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">2.1.1 MyISAM 和 InnoDB 有什么区别</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-2-MySQL索引"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">2.2 MySQL索引</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-2-1-MySQL索引介绍"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">2.2.1 MySQL索引介绍</span></span></a></li><li><a class="level is-mobile" href="#2-2-2-MySQL有哪些索引"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">2.2.2 MySQL有哪些索引</span></span></a></li><li><a class="level is-mobile" href="#2-2-3-MySQL索引的数据结构"><span class="level-left"><span class="level-item">2.2.3</span><span class="level-item">2.2.3 MySQL索引的数据结构</span></span></a></li><li><a class="level is-mobile" href="#2-2-4-聚簇索引和非聚簇索引的区别"><span class="level-left"><span class="level-item">2.2.4</span><span class="level-item">2.2.4 聚簇索引和非聚簇索引的区别</span></span></a></li><li><a class="level is-mobile" href="#2-2-5-索引什么时候会失效"><span class="level-left"><span class="level-item">2.2.5</span><span class="level-item">2.2.5 索引什么时候会失效</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-3-MySQL日志"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">2.3 MySQL日志</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-3-1-binlog-和-redolog-有什么区别？"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">2.3.1 binlog 和 redolog 有什么区别？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-4-MySQL事务"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">2.4 MySQL事务</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-4-1-事务的特性"><span class="level-left"><span class="level-item">2.4.1</span><span class="level-item">2.4.1 事务的特性</span></span></a></li><li><a class="level is-mobile" href="#2-4-2-并发的事务会导致哪些问题？"><span class="level-left"><span class="level-item">2.4.2</span><span class="level-item">2.4.2 并发的事务会导致哪些问题？</span></span></a></li><li><a class="level is-mobile" href="#2-4-3-不可重复读和幻读有什么区别？"><span class="level-left"><span class="level-item">2.4.3</span><span class="level-item">2.4.3 不可重复读和幻读有什么区别？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-5-MySQL锁"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">2.5 MySQL锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-5-1-Mysql锁的类型"><span class="level-left"><span class="level-item">2.5.1</span><span class="level-item">2.5.1 Mysql锁的类型</span></span></a></li><li><a class="level is-mobile" href="#2-5-2-InnoDB-有哪几类行锁？"><span class="level-left"><span class="level-item">2.5.2</span><span class="level-item">2.5.2 InnoDB 有哪几类行锁？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-6-MySQL调优"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">2.6 MySQL调优</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-6-1-MySQL有哪些调优方法"><span class="level-left"><span class="level-item">2.6.1</span><span class="level-item">2.6.1 MySQL有哪些调优方法</span></span></a></li><li><a class="level is-mobile" href="#2-6-2-如何优化慢查询？"><span class="level-left"><span class="level-item">2.6.2</span><span class="level-item">2.6.2 如何优化慢查询？</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#3-Redis"><span class="level-left"><span class="level-item">3</span><span class="level-item">3. Redis</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-与Mysql的对比"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">3.1 与Mysql的对比</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-1-Redis和Mysql的区别"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">3.1.1 Redis和Mysql的区别</span></span></a></li><li><a class="level is-mobile" href="#3-1-2-Redis和Mysql数据一致性问题"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">3.1.2 Redis和Mysql数据一致性问题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-2-Redis的数据结构"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">3.2 Redis的数据结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-2-1-Redis-常用的数据结构有哪些"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">3.2.1 Redis 常用的数据结构有哪些</span></span></a></li><li><a class="level is-mobile" href="#3-2-2-Redis中String和Hash存放对象数据的区别"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">3.2.2 Redis中String和Hash存放对象数据的区别</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-3-Redis持久化机制"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">3.3 Redis持久化机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-3-1-怎么保证-Redis-挂掉之后再重启数据可以进行恢复？"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">3.3.1 怎么保证 Redis 挂掉之后再重启数据可以进行恢复？</span></span></a></li><li><a class="level is-mobile" href="#3-3-2-什么是RDB持久化？"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">3.3.2 什么是RDB持久化？</span></span></a></li><li><a class="level is-mobile" href="#3-3-3-什么是AOF持久化？"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">3.3.3 什么是AOF持久化？</span></span></a></li><li><a class="level is-mobile" href="#3-3-4-如何选择使用哪种持久化方式？"><span class="level-left"><span class="level-item">3.3.4</span><span class="level-item">3.3.4 如何选择使用哪种持久化方式？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-4-Redis生产问题"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">3.4 Redis生产问题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-4-1-缓存穿透（查不到）"><span class="level-left"><span class="level-item">3.4.1</span><span class="level-item">3.4.1 缓存穿透（查不到）</span></span></a></li><li><a class="level is-mobile" href="#3-4-2-缓存击穿（量太大，缓存过期）"><span class="level-left"><span class="level-item">3.4.2</span><span class="level-item">3.4.2 缓存击穿（量太大，缓存过期）</span></span></a></li><li><a class="level is-mobile" href="#3-4-3-缓存雪崩"><span class="level-left"><span class="level-item">3.4.3</span><span class="level-item">3.4.3 缓存雪崩</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#4-计算机基础"><span class="level-left"><span class="level-item">4</span><span class="level-item">4. 计算机基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-网络分层模型"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">4.1 网络分层模型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-1-OSI七层模型"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">4.1.1 OSI七层模型</span></span></a></li><li><a class="level is-mobile" href="#4-1-2-TCP-x2F-IP四层模型"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">4.1.2 TCP/IP四层模型</span></span></a></li><li><a class="level is-mobile" href="#4-1-3-为什么要进行网络分层？"><span class="level-left"><span class="level-item">4.1.3</span><span class="level-item">4.1.3 为什么要进行网络分层？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-2-传输层协议——TCP和UDP"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">4.2 传输层协议——TCP和UDP</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-2-1-TCP和UDP的区别"><span class="level-left"><span class="level-item">4.2.1</span><span class="level-item">4.2.1 TCP和UDP的区别</span></span></a></li><li><a class="level is-mobile" href="#4-2-2-什么时候选择-TCP，什么时候选-UDP"><span class="level-left"><span class="level-item">4.2.2</span><span class="level-item">4.2.2  什么时候选择 TCP，什么时候选 UDP?</span></span></a></li><li><a class="level is-mobile" href="#4-2-3-TCP-三次握手"><span class="level-left"><span class="level-item">4.2.3</span><span class="level-item">4.2.3 TCP 三次握手</span></span></a></li><li><a class="level is-mobile" href="#4-2-4-TCP四次挥手"><span class="level-left"><span class="level-item">4.2.4</span><span class="level-item">4.2.4 TCP四次挥手</span></span></a></li><li><a class="level is-mobile" href="#4-2-5-为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？"><span class="level-left"><span class="level-item">4.2.5</span><span class="level-item">4.2.5 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</span></span></a></li><li><a class="level is-mobile" href="#4-2-6-如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？"><span class="level-left"><span class="level-item">4.2.6</span><span class="level-item">4.2.6 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</span></span></a></li><li><a class="level is-mobile" href="#4-2-7-为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？"><span class="level-left"><span class="level-item">4.2.7</span><span class="level-item">4.2.7 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-3-网络层协议——HTTP"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">4.3 网络层协议——HTTP</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-3-1-从输入URL-到页面展示到底发生了什么？"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">4.3.1 从输入URL 到页面展示到底发生了什么？</span></span></a></li><li><a class="level is-mobile" href="#4-3-2-HTTP-和-HTTPS-有什么区别？"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">4.3.2 HTTP 和 HTTPS 有什么区别？</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#5-操作系统"><span class="level-left"><span class="level-item">5</span><span class="level-item">5. 操作系统</span></span></a></li><li><a class="level is-mobile" href="#6-Mybatis"><span class="level-left"><span class="level-item">6</span><span class="level-item">6. Mybatis</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/MyBatis/"><span class="level-start"><span class="level-item">MyBatis</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringBoot/"><span class="level-start"><span class="level-item">SpringBoot</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringCloud/"><span class="level-start"><span class="level-item">SpringCloud</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringMVC/"><span class="level-start"><span class="level-item">SpringMVC</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/web%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">web基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">编程基础</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"><span class="level-start"><span class="level-item">论文写作</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">论文阅读笔记</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-01T12:57:45.000Z">2023-03-01</time></p><p class="title"><a href="/2023/03/01/java%E5%85%AB%E8%82%A1/">java八股</a></p><p class="categories"><a href="/categories/java/">java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-27T12:42:01.000Z">2023-02-27</time></p><p class="title"><a href="/2023/02/27/JVM/">JVM</a></p><p class="categories"><a href="/categories/java/">java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-27T12:41:49.000Z">2023-02-27</time></p><p class="title"><a href="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p><p class="categories"><a href="/categories/java/">java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-24T13:17:51.000Z">2023-02-24</time></p><p class="title"><a href="/2023/02/24/java%E6%96%B9%E6%B3%95/">java方法</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-24T13:17:21.000Z">2023-02-24</time></p><p class="title"><a href="/2023/02/24/%E7%AE%97%E6%B3%95/">算法</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">一月 2023</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">十二月 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JDBC/"><span class="tag">JDBC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MyBatis/"><span class="tag">MyBatis</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringBoot/"><span class="tag">SpringBoot</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringCloud/"><span class="tag">SpringCloud</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringMVC/"><span class="tag">SpringMVC</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html/"><span class="tag">html</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jvm/"><span class="tag">jvm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%83%E5%AD%A6%E4%B9%A0/"><span class="tag">元学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%88%90%E5%91%98%E6%8E%A8%E6%96%AD%E6%94%BB%E5%87%BB/"><span class="tag">成员推断攻击</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="tag">数据结构与算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"><span class="tag">机器学习基础</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">联邦学习</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"><span class="tag">论文写作</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><span class="tag">论文阅读笔记</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Blackpride</a><p class="is-size-7"><span>&copy; 2023 Zehao Tian</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>