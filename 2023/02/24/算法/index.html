<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>算法 - 田泽豪的学习笔记</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="田泽豪的学习笔记"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="田泽豪的学习笔记"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本篇文章进行了一些基本算法的学习和实现，这里主要是基于python语言，java语言的见java板块，包括：哈希集合、哈希表的使用，位运算巧解，动态规划算法，贪心算法，KMP算法，双指针算法，递归、回溯算法等。"><meta property="og:type" content="blog"><meta property="og:title" content="算法"><meta property="og:url" content="http://example.com/2023/02/24/%E7%AE%97%E6%B3%95/"><meta property="og:site_name" content="田泽豪的学习笔记"><meta property="og:description" content="本篇文章进行了一些基本算法的学习和实现，这里主要是基于python语言，java语言的见java板块，包括：哈希集合、哈希表的使用，位运算巧解，动态规划算法，贪心算法，KMP算法，双指针算法，递归、回溯算法等。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/2023/02/24/%E7%AE%97%E6%B3%95/clip_image001.png"><meta property="og:image" content="http://example.com/2023/02/24/%E7%AE%97%E6%B3%95/clip_image002.png"><meta property="og:image" content="http://example.com/2023/02/24/%E7%AE%97%E6%B3%95/clip_image003.png"><meta property="og:image" content="http://example.com/2023/02/24/%E7%AE%97%E6%B3%95/clip_image004.png"><meta property="og:image" content="http://example.com/2023/02/24/%E7%AE%97%E6%B3%95/clip_image005.png"><meta property="article:published_time" content="2023-02-24T13:17:21.000Z"><meta property="article:modified_time" content="2023-02-24T14:01:00.068Z"><meta property="article:author" content="Zehao Tian"><meta property="article:tag" content="数据结构与算法"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/2023/02/24/%E7%AE%97%E6%B3%95/clip_image001.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2023/02/24/%E7%AE%97%E6%B3%95/"},"headline":"算法","image":["http://example.com/2023/02/24/%E7%AE%97%E6%B3%95/clip_image001.png","http://example.com/2023/02/24/%E7%AE%97%E6%B3%95/clip_image002.png","http://example.com/2023/02/24/%E7%AE%97%E6%B3%95/clip_image003.png","http://example.com/2023/02/24/%E7%AE%97%E6%B3%95/clip_image004.png","http://example.com/2023/02/24/%E7%AE%97%E6%B3%95/clip_image005.png"],"datePublished":"2023-02-24T13:17:21.000Z","dateModified":"2023-02-24T14:01:00.068Z","author":{"@type":"Person","name":"Zehao Tian"},"publisher":{"@type":"Organization","name":"田泽豪的学习笔记","logo":{"@type":"ImageObject","url":{"text":"Blackpride"}}},"description":"本篇文章进行了一些基本算法的学习和实现，这里主要是基于python语言，java语言的见java板块，包括：哈希集合、哈希表的使用，位运算巧解，动态规划算法，贪心算法，KMP算法，双指针算法，递归、回溯算法等。"}</script><link rel="canonical" href="http://example.com/2023/02/24/%E7%AE%97%E6%B3%95/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Blackpride</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-02-24T13:17:21.000Z" title="2023/2/24 21:17:21">2023-02-24</time>发表</span><span class="level-item"><time dateTime="2023-02-24T14:01:00.068Z" title="2023/2/24 22:01:00">2023-02-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span><span class="level-item">1 小时读完 (大约7322个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">算法</h1><div class="content"><p>本篇文章进行了一些基本算法的学习和实现，这里主要是基于python语言，java语言的见java板块，包括：哈希集合、哈希表的使用，位运算巧解，动态规划算法，贪心算法，KMP算法，双指针算法，递归、回溯算法等。</p>
 <span id="more"></span>



<h2 id="Set-函数"><a href="#Set-函数" class="headerlink" title="Set( )函数"></a><strong>Set( )函数</strong></h2><p>​     set( ) 函数用于创建一个<strong>无序不重复元素</strong>集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。</p>
<p>​    语法：class set([iterable])  其中：iterable – 可迭代对象； 例如：数组、字符串等</p>
<p>​    例子：x &#x3D; set(‘runoob’) y &#x3D; set(‘google’) </p>
<p>&gt;&gt;&gt; x, y ：(set([‘b’, ‘r’, ‘u’, ‘o’, ‘n’]), set([‘e’, ‘o’, ‘g’, ‘l’])) # 重复的被删除 </p>
<p>&gt;&gt;&gt; x &amp; y # 交集：set([‘o’]) </p>
<p>&gt;&gt;&gt; x | y # 并集：set([‘b’, ‘e’, ‘g’, ‘l’, ‘o’, ‘n’, ‘r’, ‘u’])</p>
<p>&gt;&gt;&gt; x - y # 差集：set([‘r’, ‘b’, ‘u’, ‘n’])</p>
<p>集合添加元素：.add()</p>
<p>应用：去除数组重复元素</p>
<p>优势：检查数字是否在集合中需要 O(1) 的时间（’a’ in myset），而对于其他数据结构[向量、列表、数组]，则需要 O(n)的时间。</p>
<p><strong>集合举例：</strong>[leetcode217：存在重复元素。给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false。]</p>
<p>解决方法： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(nums) != <span class="built_in">len</span>(<span class="built_in">set</span>(nums))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="哈希表实现"><a href="#哈希表实现" class="headerlink" title="哈希表实现"></a><strong>哈希表实现</strong></h2><p>​     基于python，采用字典实现哈希表。将键(keys)作为哈希表的地址，将值(values)作为哈希表的关键字内容。</p>
<p>补充：python字典的实现和操作：</p>
<p>创建字典：mydict &#x3D; {‘a’: 1, ‘b’: 2}  nulldict &#x3D; {}</p>
<p>访问字典：x &#x3D; mydict[‘a’]  x &#x3D; mydict.get(‘a’)</p>
<p>遍历字典：for eachkey in mydict: print(eachkey) # 打印的是键</p>
<p>字典的方法：mydict.keys &#x3D; dict_keys[‘a’, ‘b’]；mydict.values &#x3D; dict_values[1, 2]；mydict.items &#x3D; dict_items([(‘a’, 1), (‘b’, 2)])  注意：这些结果以特殊列表的形式存在，不能进行一般操作</p>
<p>返回字典长度：len(mydict)</p>
<p>删除字典键值: dict.pop(key)</p>
<p>添加项目：通过使用新的索引键并为其赋值，可以将项目添加到字典中。如mydict[‘c’]&#x3D;3</p>
<p><strong>哈希表举例：</strong>[leetcode136：只出现一次的数字。给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">    <span class="built_in">hash</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):           </span><br><span class="line">        <span class="built_in">hash</span>[<span class="built_in">str</span>(nums[i])] = <span class="number">0</span>             </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="built_in">hash</span>[<span class="built_in">str</span>(nums[i])] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> keys <span class="keyword">in</span> <span class="built_in">hash</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hash</span>[keys] == <span class="number">1</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">int</span>(keys)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="Collections模块"><a href="#Collections模块" class="headerlink" title="Collections模块"></a><strong>Collections模块</strong></h2><p>​     Collections 是 python 的内置模块，提供了很多方便且高性能的关于集合的操作。是list tuple dict的扩展。采用Collections 模块可以简化代码。</p>
<p>1)namedtuple。namedtuple() 返回一个新的元组子类，且规定了元组的元素的个数，同时除了使用下标获取元素之外，还可以通过属性直接获取。输出为tuple。</p>
<p>相关方法：①._make(): 转换为新的tuple对象；②._asdict(): 返回一个dict</p>
<p>2)ChainMap。ChainMap() 可以将多个字典集合到一个字典中去，对外提供一个统一的视图。注意：该操作并是不将所有字典做了一次拷贝，实际上是在多个字典的上层又进行了一次封装而已。输出为dict。</p>
<p>相关方法：①.maps(): 输出字典组成的列表，如：</p>
<p>user1 &#x3D; {“name”:”admin”, “age”:”20”}</p>
<p>user2 &#x3D; {“name”:”root”, “weight”: 65}</p>
<p>users &#x3D; ChainMap(user1, user2)</p>
<p>print(users.maps) # [{‘name’: ‘admin’, ‘age’: ‘20’}, {‘name’: ‘root’, ‘weight’: 65}]</p>
<p>3)deque。deque()是一种类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop)操作。大大加快了遍历速度。</p>
<p>相关方法：.append()；q.appendleft()；popleft()…字面意思理解</p>
<p>4)Counter。Counter 可以简单理解为一个计数器，可以统计每个元素出现的次数，同样 Counter() 是需要接受**一个可迭代的对象的(数组、字符串、字典…)**。输出为字典，键为每个对象，值为出现次数。如Counter({‘cat’: 3, ‘horse’: 2, ‘dog’: 1, ‘bird’: 1, ‘tiger’: 1})</p>
<p>相关方法：①.most_common(n)，输出出现次数从高往低的前n项，如[(‘cat’, 3), (‘horse’, 2)]，通常用于求 Top k 问题。</p>
<p>注：Counter的运算满足’-‘运算，而字典不满足，如：</p>
<p>Counter(‘aaaabbb’)-Counter(‘aaabbbbbb’)&#x3D;Counter(‘a’:1)-&gt;满足True；</p>
<p>Counter(‘aaabbb’)-Counter(‘aaabbbbbb’)&#x3D;Counter()-&gt;满足False</p>
<p>5)OrderedDict。OrderedDict 是字典的子类，保证了元素的插入顺序。</p>
<p>相关方法：①.move_to_end(“name”, last &#x3D; False) # last&#x3D;True表示移动到开头，False为末尾。</p>
<p>6)defaultdict：defaultdict 是内置 dict 类的子类。它实现了当 key 不存在是返回默认值的功能，除此之外，与内置 dict 功能完全一样。</p>
<p><strong>Collections模块应用举例：</strong>与2中例子相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">    freq = collections.Counter(nums)</span><br><span class="line">    ans = [num <span class="keyword">for</span> num, occ <span class="keyword">in</span> freq.items() <span class="keyword">if</span> occ == <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="位运算巧解"><a href="#位运算巧解" class="headerlink" title="位运算巧解"></a><strong>位运算巧解</strong></h2><p>​     通过找到目标数据中与位运算有关的特殊关系，进而采用位运算进行巧妙解决。</p>
<p>位运算：具有交换性和结合性。优先级：**~** &gt; <strong>&lt;&lt;&#x2F;&gt;&gt;</strong> &gt; <strong>&amp;</strong> &gt; <strong>^</strong> &gt; <strong>|</strong> &gt; **&amp;&#x3D;&#x2F;|&#x3D;**…</p>
<p>1)按位与(&amp;)：1&amp;1&#x3D;1，否则为0；</p>
<p>2)按位或(|)：0|0 &#x3D; 0，否则为1；</p>
<p>3)按位异或(^)：1^1 &#x3D; 0, 0^0 &#x3D; 0, 1^0 &#x3D; 1, 0^1 &#x3D; 0;  </p>
<p>4)按位取反(~): ~1 &#x3D; 0， ~0 &#x3D; 1;</p>
<p>5)左移(&lt;&lt;)：a &lt;&lt; b: 把a转为二进制后左移b位（在后面添b个0）;</p>
<p>6)右移(&gt;&gt;)：a &gt;&gt; b: 把a转化为二进制后右移b位（去掉末b位）；</p>
<p>​     注意：对于部分语言（python），对「有符号整数类型」和「无符号整数类型」没有区分。如-5的二进制表示为1111 1011，用补码表示（即取反加一），而没有符号位。</p>
<p>​     <strong>位运算举例：</strong>[leetcode137：只出现一次的数字Ⅱ。给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现三次。找出那个只出现了一次的元素。]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>): <span class="comment"># int</span></span><br><span class="line">        total = <span class="built_in">sum</span>((each_num &gt;&gt; i &amp; <span class="number">1</span>) <span class="keyword">for</span> each_num <span class="keyword">in</span> nums) <span class="comment"># 求每一位的和</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">31</span>: <span class="comment"># 去掉符号位</span></span><br><span class="line">        	m -= (total % <span class="number">3</span>) &lt;&lt; i</span><br><span class="line">      	<span class="keyword">else</span>: </span><br><span class="line">        	m |= (total % <span class="number">3</span>) &lt;&lt; i</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>位运算某些巧解理论：</strong></p>
<p>Brian Kernighan 算法：对于任意整数 x，令 x&#x3D;x &amp; (x−1)，该运算将 x的二进制表示的最后一个 1变成 0。该算法可以用来进行二进制1的统计</p>
<h2 id="遍历子序列的方式"><a href="#遍历子序列的方式" class="headerlink" title="遍历子序列的方式"></a><strong>遍历子序列的方式</strong></h2><p>示例：[a, b, c, d, e]</p>
<p>1)以不同开头节点进行遍历。遍历以某个节点为开头的所有子序列: 如 [a]，[a, b]，[ a, b, c] … 再从以 b 为开头的子序列开始遍历 [b] [b, c]…。</p>
<p>2)以不同子序列的长度进行遍历。根据子序列的长度为标杆，如先遍历出子序列长度为 1 的子序列[a], [b], …，在遍历出长度为 2 的…。</p>
<p>3)以不同结束节点进行遍历。以子序列的结束节点为基准，先遍历出以某个节点为结束的所有子序列，因为每个节点都可能会是子序列的结束节点，因此要遍历下整个序列，如: 以 b 为结束点的所有子序列: [a , b] [b] 以 c 为结束点的所有子序列: [a, b, c] [b, c] [ c ]。</p>
<p><strong>应用：</strong></p>
<p>第一种遍历方式通常用于暴力解法；</p>
<p>第二种遍历方式用于特殊情况，如 [leetcode5: 最长回文子串];</p>
<p>第三种遍历方式因为可以产生递推关系, 通常用于动态规划。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><strong>动态规划</strong></h2><p>将复杂的问题转化为多个简单的子问题进行求解。</p>
<p><strong>关键一：理解题意</strong></p>
<p>与时刻有关，只需要返回值等等的问题，可以看作动态规划问题。</p>
<p><strong>关键二：定义子问题（定义状态）</strong></p>
<p>设计状态思路：把不确定的因素确定下来，进而把子问题定义清楚，把子问题定义得简单。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。</p>
<p><strong>dp[i]：</strong>表示第i时刻的状态，如表示以 nums[i] 结尾 的 连续 子数组的最大和。根据不同情况，还可以设置为dp[i][j]等。</p>
<p><strong>关键三：设置状态转移方程</strong></p>
<p>即得到dp[i]与之前时刻dp[i-1]或这一时刻值的关系，需要具体讨论每个状态之间的联系。如dp[i] &#x3D; dp[i - 1] + nums[i]。</p>
<p><strong>关键四：思考初始值</strong></p>
<p>根据题意，设置dp[0]。</p>
<p><strong>关键五：思考输出</strong></p>
<p>根据题意，设置输出。注意，有时候状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回。</p>
<p><strong>无后效性：</strong>是动态规划中非常重要的概念。为了保证计算子问题能够按照顺序、不重复地进行，动态规划要求已经求解的子问题不受后续阶段的影响。这个条件也被叫做「无后效性」。换言之，动态规划对状态空间的遍历构成一张有向无环图，遍历就是该有向无环图的一个拓扑序。有向无环图中的节点对应问题中的「状态」，图中的边则对应状态之间的「转移」，转移的选取就是动态规划中的「决策」。</p>
<p>如果之前的阶段求解的子问题的结果包含了一些不确定的信息，导致了后面的阶段求解的子问题无法得到，或者很难得到，这叫<strong>「有后效性」</strong>。</p>
<p>解决「有后效性」的办法是固定住需要分类讨论的地方，记录下更多的结果。在代码层面上表现为：状态数组增加维度，例如：股票系列问题；把状态定义得更细致、准确，例如：[Leetcode124]：状态定义只解决路径来自左右子树的其中一个子树。</p>
<p><strong>随想录总结：</strong></p>
<p><strong>动态规划五部曲：确定dp数组以及下标的含义-&gt;确定递推公式-&gt;dp数组如何初始化-&gt;确定遍历顺序-&gt;举例推导dp数组</strong></p>
<p>调试三部曲：这道题目我举例推导状态转移公式了么？-&gt;我打印dp数组的日志了么？-&gt;打印出来了dp数组和我想的一样么？</p>
<h2 id="双指针遍历"><a href="#双指针遍历" class="headerlink" title="双指针遍历"></a><strong>双指针遍历</strong></h2><p>①指针向同侧移动，形成前后指针或快慢指针。常作用于两个排序好了的数组，分别指向最初的元素，然后依次右移，进行遍历[leetcode88: 最长回文子串; leetcode350: 最长回文子串]</p>
<p>② 指针向中间或两端移动，移动方向始终相对。常作用于交换和排序算法中。</p>
<p>优势：大大减小空间复杂度。</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h2><p>在升序数组 nums 中寻找目标值target，对于特定下标 i，比较nums[i] 和target 的大小：</p>
<p>如果 nums[i]&#x3D;target，则下标 i即为要寻找的下标；</p>
<p>如果nums[i]&gt;target，则 target 只可能在下标 i 的左侧；</p>
<p>如果 nums[i]&lt;target，则target 只可能在下标 i 的右侧。</p>
<p>基于上述事实，可以在<strong>有序数组</strong>中使用二分查找寻找目标值。</p>
<p>二分查找的做法是，定义查找的范围 [left,right]，初始查找范围是整个数组。每次取查找范围中点mid，比较nums[mid] 和 target 的大小，如果相等则 mid 即为要寻找的下标，如果不相等则根据nums[mid] 和target 的大小关系将查找范围缩小一半。记住，左&#x2F;右指针要在mid基础上+1&#x2F;-1。</p>
<p>由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是O(logn)，其中 n是数组的长度。</p>
<p>二分查找的条件是查找范围不为空，即 left≤right。如果 target 在数组中，二分查找可以保证找到 target，返回target 在数组中的下标。如果 target 不在数组中，则当 left&gt;right 时结束查找，返回 -1。</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a><strong>贪心算法</strong></h2><ol>
<li><p>贪心算法（又称贪婪算法）是指，在对问题求解时，<strong>总是做出在当前看来是最好的选择</strong>。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</p>
</li>
<li><p>贪心选择是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素。</p>
</li>
<li><p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。运用贪心策略在每一次转化时都取得了最优解。问题的最优子结构性质是该问题可用贪心算法求解的关键特征。贪心算法的每一次操作都对结果产生直接影响。贪心算法对每个子问题的解决方案都做出选择，不能回退。</p>
</li>
</ol>
<p>4)贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。</p>
<p>5)实际上，贪心算法适用的情贪心算法(贪婪算法)况很少。一般对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可以做出判断。</p>
<p><strong>该算法存在的问题：</strong></p>
<p>1.不能保证求得的最后解是最佳的，计算过程不能代表实际过程</p>
<p>2.不能用来求最大值或最小值的问题</p>
<p>3.只能求满足某些约束条件的可行解的范围</p>
<p><strong>应用：[仅列出贪心的思路]</strong></p>
<p>①选择排序。贪心策略：每次从未排序的数据中选取最小值，并把最小值放在未排序数据的起始位置，直到未排序的数据为0，则结束排序。</p>
<p>②平衡字符串。在一个 平衡字符串 中，‘L’ 和 ‘R’ 字符的数量是相同的。给你一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。贪心策略：不要有嵌套的平衡，只要达到平衡，就立即分割(贪心策略)。我们假设 ‘R’ &#x3D;&#x3D; 1, ‘L’ &#x3D;&#x3D; -1 .只要累加等于 0 就算分割一次.</p>
<p>③买卖股票的最佳时机。prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有一股股票。你也可以先购买，然后在同一天出售。返回你能获得的最大利润 。贪心策略：在连续的两日内，如果是上升趋势则前一天买入，后一天卖出，下降趋势则不进行操作。</p>
<h2 id="数组reshape操作："><a href="#数组reshape操作：" class="headerlink" title="数组reshape操作："></a><strong>数组reshape操作：</strong></h2><p>将m*n的数组转化为r*c的数组</p>
<p>① 将数组展开为一维：</p>
<p>对于一个行数为 m，列数为 n，行列下标都从 0 开始编号的二维数组，我们可以通过下面的方式，将其中的每个元素 (i, j)映射到整数域内，并且它们按照行优先的顺序一一对应着 [0, mn) 中的每一个整数。形象化地来说，我们把这个二维数组「排扁」成了一个一维数组。如果读者对机器学习有一定了解，可以知道这就是 flatten 操作。</p>
<p>这样的映射即为：(i, j) → i * n + j</p>
<p>② 将一维数组合并为二维：</p>
<p>与①同理，将整数 X 映射回其在矩阵中的下标，即：i &#x3D; x &#x2F; n ; j &#x3D; x % n ;</p>
<p>③ 具体实现方法：<br> 设nums 本身为 mm 行 nn 列，如果 mn ≠ rc，那么二者包含的元素个数不相同，因此无法进行重塑；否则，对于 x ∈ [0,mn)，第 x 个元素在 nums 中对应的下标为 (x &#x2F; n,x % n)，而在新的重塑矩阵中对应的下标为 (x &#x2F; c,x % c)。我们直接进行赋值即可。</p>
<p>④代码：[Leetcode566: 重塑矩阵] def matrixReshape(self, mat, r, c)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m, n = <span class="built_in">len</span>(nums), <span class="built_in">len</span>(nums[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> m * n != r * c:</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">ans = [[<span class="number">0</span>] * c <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(r)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(m * n):</span><br><span class="line">    ans[x // c][x % c] = nums[x // n][x % n]    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a><strong>递归</strong></h2><p><strong>一、运用递归解决树的问题</strong></p>
<p>①“自顶向下”：</p>
<p>“自顶向下” 意味着在每个递归层级，我们将首先访问节点来计算一些值，并在递归调用函数时将这些值传递到子节点。 所以 “自顶向下” 的解决方案可以被认为是一种前序遍历。 具体来说，递归函数 top_down(root, params) 的原理是这样的：</p>
<p><img src="/2023/02/24/%E7%AE%97%E6%B3%95/clip_image001.png"></p>
<p>当遇到树问题时，请先思考一下两个问题：</p>
<p>1)你能确定一些参数，从该节点自身解决出发寻找答案吗？</p>
<p>2)你可以使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数吗？</p>
<p>如果答案都是肯定的，那么请尝试使用 “自顶向下” 的递归来解决此问题。</p>
<p><strong>例子：</strong>给定一个二叉树，请寻找它的最大深度。</p>
<p>“自顶向下”解决思想：我们知道根节点的深度是1。 对于每个节点，如果我们知道某节点的深度，那我们将知道它子节点的深度。 因此，在调用递归函数的时候，将节点的深度传递为一个参数，那么所有的节点都知道它们自身的深度。 而对于叶节点，我们可以通过更新深度从而获取最终答案。 这里是递归函数 maximum_depth(root, depth) 的伪代码：</p>
<p><img src="/2023/02/24/%E7%AE%97%E6%B3%95/clip_image002.png"></p>
<p>②“自底向上”：</p>
<p>自底向上” 是另一种递归方法。 在每个递归层次上，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。 这个过程可以看作是后序遍历的一种。 通常，“自底向上” 的递归函数 bottom_up(root) 为如下所示：</p>
<p><img src="/2023/02/24/%E7%AE%97%E6%B3%95/clip_image003.png"></p>
<p><strong>例子：</strong>让我们继续讨论前面关于树的最大深度的问题，但是使用不同的思维方式：对于树的单个节点，以节点自身为根的子树的最大深度x是多少？</p>
<p>如果我们知道一个根节点，以其左子节点为根的最大深度为l和以其右子节点为根的最大深度为r，我们是否可以回答前面的问题？ 当然可以，我们可以选择它们之间的最大值，再加上1来获得根节点所在的子树的最大深度。 那就是 x &#x3D; max（l，r）+ 1。</p>
<p>这意味着对于每一个节点来说，我们都可以在解决它子节点的问题之后得到答案。 因此，我们可以使用“自底向上“的方法。下面是递归函数 maximum_depth(root) 的伪代码：</p>
<p><img src="/2023/02/24/%E7%AE%97%E6%B3%95/clip_image004.png"></p>
<h2 id="快速乘与快速幂"><a href="#快速乘与快速幂" class="headerlink" title="快速乘与快速幂"></a><strong>快速乘与快速幂</strong></h2><p>用于防止数据超出范围，用加号，乘号替代乘号，幂运算。</p>
<p><strong>一、快速乘</strong>[Leetcode29:两数相除]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速乘 计算x*y</span></span><br><span class="line"><span class="comment"># 将y转化为二进制，取出每一位的值并变为加法运算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quickmod</span>(<span class="params">x, y</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">ans = <span class="number">0</span>; add = x</span><br><span class="line"><span class="keyword">while</span> y&gt;<span class="number">0</span>:</span><br><span class="line">    <span class="comment"># y为奇数(y最后一定会为奇数1),最后一次加上去</span></span><br><span class="line">    <span class="keyword">if</span> y&amp;<span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">        ans += add</span><br><span class="line">        <span class="comment"># 每次移位都要累加add,因为转化为2进制了</span></span><br><span class="line">        add += add</span><br><span class="line">        <span class="comment"># 右移一位</span></span><br><span class="line">        y &gt;&gt;= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>二、快速幂</strong>[Leetcode50:pow(x, n)]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速幂，计算x^n</span></span><br><span class="line"><span class="comment"># 将n转化为二进制，取出每一位的值并变为乘法运算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quickMul</span>(<span class="params">x, n</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="comment"># 考虑n为正数</span></span><br><span class="line">    ans = <span class="number">1.0</span>; add = x</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 在奇数时刻进行操作</span></span><br><span class="line">        <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">            ans *= add</span><br><span class="line">            add *= add</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a><strong>KMP算法</strong></h2><p>用于字符串匹配，时间复杂度O(m+n)</p>
<p>[Leetcode28 459:找出字符串中第一个匹配项的下标]</p>
<p><strong>字符串的前缀和后缀：</strong></p>
<p>如果字符串A和B，存在A&#x3D;BS，其中S是任意的非空字符串，那就称B为A的前缀。例如，‘Harry’的前缀包括{”H”， ”Ha”， ”Har”, ”Harr”}，我们把所有前缀组成的集合，称为字符串的前缀集合。同样可以定义后缀A&#x3D;SB，其中S是任意的非空字符串，那就称B为A的后缀，例如，”Potter”的后缀包括{”otter”,”tter”, ”ter”, ”er”, ”r”}，然后把所有后缀组成的集合，称为字符串的后缀集合。要注意的是，字符串本身并不是自己的后缀。</p>
<p><strong>部分匹配表(Partial Match Table)：</strong></p>
<p>PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度。对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}， 两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为3。</p>
<p><strong>匹配思路：</strong></p>
<p>例如，要在主字符串”ababababca”中查找模式字符串”abababca”。如果在 j 处字符不匹配，那么由于前边所说的模式字符串 PMT 的性质，主字符串中 i 指针之前的 PMT[j −1] 位就一定与模式字符串的第 0 位至第 PMT[j−1] 位是相同的。这是因为主字符串在 i 位失配，也就意味着主字符串从 i−j 到 i 这一段是与模式字符串的 0 到 j 这一段是完全相同的。而我们上面也解释了，模式字符串从 0 到 j−1 ，在这个例子中就是”ababab”，其前缀集合与后缀集合的交集的最长元素为”abab”， 长度为4。所以就可以断言，主字符串中i指针之前的 4 位一定与模式字符串的第0位至第 4 位是相同的，即长度为 4 的后缀与前缀相同。这样一来，我们就可以将这些字符段的比较省略掉。具体做法是，保持i指针不动，然后将j指针指向模式字符串的PMT[j −1]位即可。</p>
<p><img src="/2023/02/24/%E7%AE%97%E6%B3%95/clip_image005.png"></p>
<p><strong>next数组：</strong></p>
<p>在字符串的匹配中，如果是在 j 位失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值，所以为了编程的方便， 我们不直接使用PMT数组，而是<strong>将PMT数组向后偏移一位。我们把新得到的这个数组称为next数组。</strong></p>
<p><strong>next数组生成程序：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, s</span>):</span><br><span class="line">    i = <span class="number">0</span>; j = -<span class="number">1</span>; <span class="built_in">next</span> = [-<span class="number">1</span>]*(<span class="built_in">len</span>(s)+<span class="number">1</span>) </span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="keyword">if</span> j == -<span class="number">1</span> <span class="keyword">or</span> p[i] == p[j]: <span class="comment"># 匹配的情况 或者是刚退回到原位进行比较 </span></span><br><span class="line">        	i +=<span class="number">1</span>; j+=<span class="number">1</span>; <span class="built_in">next</span>[i] = j</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 不匹配，退回到模式串的上个相同位置处</span></span><br><span class="line">            j = <span class="built_in">next</span>[j]</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中有一个技巧是，在把PMT进行向右偏移时，第0位的值，我们将其设成了-1，这只是为了编程的方便，并没有其他的意义。在本节的例子中，next数组如上表所示。在代码实现中，next相当于PMT右移了一位，故j从-1开始，next长度为len(s)+1，next[0]&#x3D;-1。</p>
<p><strong>字符串匹配程序：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">KMP</span>(<span class="params">self, haystack, needle</span>):</span><br><span class="line">    <span class="built_in">next</span> = self.getNext(neddle)</span><br><span class="line">    i = <span class="number">0</span>; j = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(haystack):</span><br><span class="line">        <span class="keyword">if</span> j == -<span class="number">1</span> <span class="keyword">or</span> haystack[i] == neddle[j]:</span><br><span class="line">            i+=<span class="number">1</span>; j+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = <span class="built_in">next</span>[j]; </span><br><span class="line">        <span class="keyword">if</span> j == <span class="built_in">len</span>(neddle): </span><br><span class="line">       		eturn i - j</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a><strong>回溯算法</strong></h2><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯法解决的问题都可以抽象为树形结构，是的，我指的是所有回溯法的问题都可以抽象为树形结构！因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。</p>
<p>回溯法一般可以解决如下几种问题：</p>
<p>组合问题：N个数里面按一定规则找出k个数的集合；</p>
<p>切割问题：一个字符串按一定规则有几种切割方式；</p>
<p>子集问题：一个N个数的集合里有多少符合条件的子集；</p>
<p>排列问题：N个数按一定规则全排列，有几种排列方式；</p>
<p>棋盘问题：N皇后，解数独等等。</p>
<p>回溯法模板：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">   <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">     存放结果;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (选择：本层集合中元素(树中节点孩子的数量就是集合的大小)) &#123;</span><br><span class="line">     处理节点;</span><br><span class="line">     backtracking(路径，选择列表); // 递归</span><br><span class="line">     回溯，撤销处理结果</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例如：Leetcode77：组合问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  	<span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 套用回溯算法经典模板</span></span><br><span class="line">        path = [] <span class="comment"># 全局列表，存放路径和结果</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">n, k, index</span>):** <span class="comment"># index代表位置信息，从哪个位置开始</span></span><br><span class="line">            <span class="comment"># 终止条</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == k:</span><br><span class="line">                result.append(path[:])  <span class="comment"># 深拷贝</span></span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># index~n为本层节点 剪枝剪掉无用节点</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, n-(k-<span class="built_in">len</span>(path))+<span class="number">1</span>+<span class="number">1</span>):</span><br><span class="line">                path.append(i)</span><br><span class="line">                backtracking(n, k, i+<span class="number">1</span>) <span class="comment">#index+1代表不重复 下一层从后一个数开始</span></span><br><span class="line">                path.pop() <span class="comment"># 以i开头的遍历完了，需要返回到上一层，即回溯</span></span><br><span class="line">                backtracking(n, k, <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> result</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a><strong>背包问题</strong></h2><p><strong>0&#x2F;1背包：</strong>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</p>
<p><strong>代码模板：</strong>（一维dp，滚动数组）此模板为让价值更高。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化: 全为0</span></span><br><span class="line">dp = [<span class="number">0</span>] * (bag_weight + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先遍历物品, 再遍历背包容量</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(weight)):  <span class="comment"># i代表每一个数据，故为0~len-1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(bag_weight, weight[i] - <span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># j为dp的编号，要从大到小，避免内存重复，保证物品i只放入一次，且需先遍历i，再遍历j，保证每次背包有多个物品</span></span><br><span class="line">        <span class="comment"># 递推公式</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># dp数组表示前i个物品中满足重量要求j的最高价值</span></span><br><span class="line"><span class="comment"># 其中dp[j]为本次不进行操作的情况，则与上一个物品i时的情况一致；</span></span><br><span class="line"><span class="comment"># dp[j - weight[i]] + value[i]为添加本次物品的情况，则为未添加的价值加上该物品价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此外还有判断类型之和的，如有多少种方法使得和为多少，此时：</span></span><br><span class="line"><span class="comment"># dp[j] += dp[j - weight[i]]</span></span><br><span class="line"><span class="comment"># dp数组表示前i个物品中重量和为j的集合个数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>完全背包：</strong>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。</p>
<p>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。</p>
<p><strong>代码模板：</strong></p>
<p>与0&#x2F;1背包只有一个区别：for j in range(bag_weight, weight[i] - 1, -1)从后往前遍历变为从前往后，即for j in range(weight[i], bag_weight+1)，这样每个物品可以遍历多次，因为后一次的dp受到了前一次的影响。</p>
<p>有关最终的排列和组合，外层为物品，内层为重量—-&gt;对应组合；外层为重量，内层为物品—-&gt;对应排列，即每个顺序都考虑了，因为每一层都对各个物品进行了dp求解</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>算法</p><p><a href="http://example.com/2023/02/24/算法/">http://example.com/2023/02/24/算法/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Zehao Tian</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-02-24</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-02-24</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/02/24/java%E6%96%B9%E6%B3%95/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">java方法</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-item">数据结构基础</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/jetpacktocat.png" alt="田泽豪"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">田泽豪</p><p class="is-size-6 is-block">越努力，越幸运</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>HUST</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">53</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">20</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zehtian" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Set-函数"><span class="level-left"><span class="level-item">1</span><span class="level-item">Set( )函数</span></span></a></li><li><a class="level is-mobile" href="#哈希表实现"><span class="level-left"><span class="level-item">2</span><span class="level-item">哈希表实现</span></span></a></li><li><a class="level is-mobile" href="#Collections模块"><span class="level-left"><span class="level-item">3</span><span class="level-item">Collections模块</span></span></a></li><li><a class="level is-mobile" href="#位运算巧解"><span class="level-left"><span class="level-item">4</span><span class="level-item">位运算巧解</span></span></a></li><li><a class="level is-mobile" href="#遍历子序列的方式"><span class="level-left"><span class="level-item">5</span><span class="level-item">遍历子序列的方式</span></span></a></li><li><a class="level is-mobile" href="#动态规划"><span class="level-left"><span class="level-item">6</span><span class="level-item">动态规划</span></span></a></li><li><a class="level is-mobile" href="#双指针遍历"><span class="level-left"><span class="level-item">7</span><span class="level-item">双指针遍历</span></span></a></li><li><a class="level is-mobile" href="#二分查找"><span class="level-left"><span class="level-item">8</span><span class="level-item">二分查找</span></span></a></li><li><a class="level is-mobile" href="#贪心算法"><span class="level-left"><span class="level-item">9</span><span class="level-item">贪心算法</span></span></a></li><li><a class="level is-mobile" href="#数组reshape操作："><span class="level-left"><span class="level-item">10</span><span class="level-item">数组reshape操作：</span></span></a></li><li><a class="level is-mobile" href="#递归"><span class="level-left"><span class="level-item">11</span><span class="level-item">递归</span></span></a></li><li><a class="level is-mobile" href="#快速乘与快速幂"><span class="level-left"><span class="level-item">12</span><span class="level-item">快速乘与快速幂</span></span></a></li><li><a class="level is-mobile" href="#KMP算法"><span class="level-left"><span class="level-item">13</span><span class="level-item">KMP算法</span></span></a></li><li><a class="level is-mobile" href="#回溯算法"><span class="level-left"><span class="level-item">14</span><span class="level-item">回溯算法</span></span></a></li><li><a class="level is-mobile" href="#背包问题"><span class="level-left"><span class="level-item">15</span><span class="level-item">背包问题</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/MyBatis/"><span class="level-start"><span class="level-item">MyBatis</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringBoot/"><span class="level-start"><span class="level-item">SpringBoot</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringCloud/"><span class="level-start"><span class="level-item">SpringCloud</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringMVC/"><span class="level-start"><span class="level-item">SpringMVC</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/web%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">web基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">编程基础</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"><span class="level-start"><span class="level-item">论文写作</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">论文阅读笔记</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-01T12:57:45.000Z">2023-03-01</time></p><p class="title"><a href="/2023/03/01/java%E5%85%AB%E8%82%A1/">java八股</a></p><p class="categories"><a href="/categories/java/">java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-27T12:42:01.000Z">2023-02-27</time></p><p class="title"><a href="/2023/02/27/JVM/">JVM</a></p><p class="categories"><a href="/categories/java/">java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-27T12:41:49.000Z">2023-02-27</time></p><p class="title"><a href="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p><p class="categories"><a href="/categories/java/">java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-24T13:17:51.000Z">2023-02-24</time></p><p class="title"><a href="/2023/02/24/java%E6%96%B9%E6%B3%95/">java方法</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-24T13:17:21.000Z">2023-02-24</time></p><p class="title"><a href="/2023/02/24/%E7%AE%97%E6%B3%95/">算法</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">一月 2023</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">十二月 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JDBC/"><span class="tag">JDBC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MyBatis/"><span class="tag">MyBatis</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringBoot/"><span class="tag">SpringBoot</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringCloud/"><span class="tag">SpringCloud</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringMVC/"><span class="tag">SpringMVC</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html/"><span class="tag">html</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jvm/"><span class="tag">jvm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%83%E5%AD%A6%E4%B9%A0/"><span class="tag">元学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%88%90%E5%91%98%E6%8E%A8%E6%96%AD%E6%94%BB%E5%87%BB/"><span class="tag">成员推断攻击</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="tag">数据结构与算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"><span class="tag">机器学习基础</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">联邦学习</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"><span class="tag">论文写作</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><span class="tag">论文阅读笔记</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Blackpride</a><p class="is-size-7"><span>&copy; 2023 Zehao Tian</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>