<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Redis - 田泽豪的学习笔记</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="田泽豪的学习笔记"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="田泽豪的学习笔记"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本系列主要进行Redis的学习介绍，Redis（Remote Dictionary Server)，即远程字典服务，是一个开源的支持网络、可基于内存亦可持久化的日志型、Key-Value方式储存数据、并提供多种语言的API的非关系型数据库；与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实"><meta property="og:type" content="blog"><meta property="og:title" content="Redis"><meta property="og:url" content="http://example.com/2023/02/24/Redis/"><meta property="og:site_name" content="田泽豪的学习笔记"><meta property="og:description" content="本系列主要进行Redis的学习介绍，Redis（Remote Dictionary Server)，即远程字典服务，是一个开源的支持网络、可基于内存亦可持久化的日志型、Key-Value方式储存数据、并提供多种语言的API的非关系型数据库；与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/2023/02/24/Redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70.jpeg"><meta property="og:image" content="http://example.com/2023/02/24/Redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70-16772234339232.jpeg"><meta property="article:published_time" content="2023-02-24T12:58:16.000Z"><meta property="article:modified_time" content="2023-02-24T13:11:53.947Z"><meta property="article:author" content="Zehao Tian"><meta property="article:tag" content="Redis"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/2023/02/24/Redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2023/02/24/Redis/"},"headline":"Redis","image":[],"datePublished":"2023-02-24T12:58:16.000Z","dateModified":"2023-02-24T13:11:53.947Z","author":{"@type":"Person","name":"Zehao Tian"},"publisher":{"@type":"Organization","name":"田泽豪的学习笔记","logo":{"@type":"ImageObject","url":{"text":"Blackpride"}}},"description":"本系列主要进行Redis的学习介绍，Redis（Remote Dictionary Server)，即远程字典服务，是一个开源的支持网络、可基于内存亦可持久化的日志型、Key-Value方式储存数据、并提供多种语言的API的非关系型数据库；与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实"}</script><link rel="canonical" href="http://example.com/2023/02/24/Redis/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Blackpride</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-02-24T12:58:16.000Z" title="2023/2/24 20:58:16">2023-02-24</time>发表</span><span class="level-item"><time dateTime="2023-02-24T13:11:53.947Z" title="2023/2/24 21:11:53">2023-02-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Redis/">Redis</a></span><span class="level-item">44 分钟读完 (大约6614个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Redis</h1><div class="content"><p>本系列主要进行Redis的学习介绍，<strong>Redis（Remote Dictionary Server)，即远程字典服务，</strong>是一个开源的支持网络、可基于内存亦可持久化的日志型、<strong>Key-Value方式储存数据</strong>、并提供多种语言的API的非关系型数据库；与memcached一样，为了保证效率，<strong>数据都是缓存在内存中</strong>。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从）同步。</p>
<span id="more"></span>



<h2 id="1-Nosql概述"><a href="#1-Nosql概述" class="headerlink" title="1. Nosql概述"></a><strong>1. Nosql概述</strong></h2><h3 id="1-1-为什么要有Nosql"><a href="#1-1-为什么要有Nosql" class="headerlink" title="1.1 为什么要有Nosql"></a><strong>1.1 为什么要有Nosql</strong></h3><ol>
<li>数据量增加到一定程度，单机数据库就放不下了；</li>
<li>数据的索引（B+ Tree），一个机器内存也存放不下；</li>
<li>访问量变大后（读写混合），一台服务器承受不住。</li>
</ol>
<p>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦。于是出现了<strong>缓存cache</strong>：通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。</p>
<p>如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。</p>
<h3 id="1-2-什么是Nosql"><a href="#1-2-什么是Nosql" class="headerlink" title="1.2 什么是Nosql"></a><strong>1.2 什么是Nosql</strong></h3><p><strong>NoSQL &#x3D; Not Only SQL（不仅仅是SQL）</strong></p>
<p>Not Only Structured Query Language</p>
<p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p>
<p>非关系型数据库：<strong>数据存储没有固定的格式，并且可以进行横向扩展。</strong></p>
<p>NoSQL泛指非关系型数据库，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。</p>
<h3 id="1-3-Nosql特点"><a href="#1-3-Nosql特点" class="headerlink" title="1.3 Nosql特点"></a><strong>1.3 Nosql特点</strong></h3><ol>
<li>方便扩展（数据之间没有关系，很好扩展！）</li>
<li>大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</li>
<li>数据类型是多样型的！（不需要事先设计数据库，随取随用）</li>
<li>没有固定的查询语言</li>
</ol>
<h3 id="1-4-Nosql的四大分类"><a href="#1-4-Nosql的四大分类" class="headerlink" title="1.4 Nosql的四大分类"></a>1.4 Nosql的四大分类</h3><blockquote>
<p><strong>KV键值对</strong></p>
</blockquote>
<ul>
<li>新浪：<strong>Redis</strong></li>
<li>美团：Redis + Tair</li>
<li>阿里、百度：Redis + Memcache</li>
</ul>
<blockquote>
<p><strong>文档型数据库（bson数据格式）：</strong></p>
</blockquote>
<ul>
<li><strong>MongoDB</strong>(掌握)<ul>
<li>基于分布式文件存储的数据库。C++编写，用于处理大量文档。</li>
<li>MongoDB是RDBMS和NoSQL的中间产品。MongoDB是非关系型数据库中功能最丰富的，NoSQL中最像关系型数据库的数据库。</li>
</ul>
</li>
<li>ConthDB</li>
</ul>
<blockquote>
<p><strong>列存储数据库</strong></p>
</blockquote>
<ul>
<li><strong>HBase</strong>(大数据必学)</li>
<li>分布式文件系统</li>
</ul>
<blockquote>
<p><strong>图关系数据库</strong></p>
</blockquote>
<p>用于广告推荐，社交网络</p>
<ul>
<li><strong>Neo4j</strong>、InfoGrid</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th align="center">KV键值对</th>
<th align="center"><strong>文档型数据库（bson数据格式）</strong></th>
<th align="center"><strong>列存储数据库</strong></th>
</tr>
</thead>
<tbody><tr>
<td>应用场景</td>
<td align="center">内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。</td>
<td align="center">Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</td>
<td align="center">分布式的文件系统</td>
</tr>
<tr>
<td>数据模型</td>
<td align="center">Key 指向 Value 的键值对，通常用hash table来实现</td>
<td align="center">Key-Value对应的键值对，Value为结构化数据</td>
<td align="center">以列簇式存储，将同一列数据存在一起</td>
</tr>
<tr>
<td>优点</td>
<td align="center">查找速度快</td>
<td align="center">数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td>
<td align="center">查找速度快，可扩展性强，更容易进行分布式扩展</td>
</tr>
<tr>
<td>缺点</td>
<td align="center">数据无结构化，通常只被当作字符串或者二进制数据</td>
<td align="center">查询性能不高，而且缺乏统一的查询语法。</td>
<td align="center">功能相对局限</td>
</tr>
</tbody></table>
<h2 id="2-Redis入门"><a href="#2-Redis入门" class="headerlink" title="2. Redis入门"></a>2. Redis入门</h2><h3 id="2-1-什么是Redis"><a href="#2-1-什么是Redis" class="headerlink" title="2.1 什么是Redis"></a>2.1 什么是Redis</h3><ul>
<li><p><strong>Redis（Remote Dictionary Server)，即远程字典服务。</strong></p>
</li>
<li><p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、<strong>Key-Value数据库</strong>，并提供多种语言的API。</p>
</li>
<li><p>与memcached一样，为了保证效率，<strong>数据都是缓存在内存中</strong>。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从）同步。</p>
</li>
</ul>
<h3 id="2-2-Redis能该干什么"><a href="#2-2-Redis能该干什么" class="headerlink" title="2.2 Redis能该干什么"></a><strong>2.2 Redis能该干什么</strong></h3><ol>
<li>内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）</li>
<li>高效率、用于高速缓冲</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器、计数器(eg：浏览量)</li>
</ol>
<h3 id="2-3-Redis特性"><a href="#2-3-Redis特性" class="headerlink" title="2.3 Redis特性"></a>2.3 Redis特性</h3><ol>
<li><p>多样的数据类型</p>
</li>
<li><p>持久化</p>
</li>
<li><p>集群</p>
</li>
<li><p>事务</p>
</li>
</ol>
<blockquote>
<p><strong>Redis是单线程的，Redis是基于内存操作的。</strong></p>
</blockquote>
<p>所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。</p>
<blockquote>
<p><strong>Redis为什么单线程还这么快？</strong></p>
</blockquote>
<p><strong>Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的</strong>，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。</p>
<h2 id="3-Redis支持的五大类型"><a href="#3-Redis支持的五大类型" class="headerlink" title="3. Redis支持的五大类型"></a>3. Redis支持的五大类型</h2><p>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作<strong>数据库</strong>，<strong>高速缓存</strong>和<strong>消息队列代理</strong>。它支持<a target="_blank" rel="noopener" href="https://www.redis.net.cn/tutorial/3508.html">字符串</a>、<a target="_blank" rel="noopener" href="https://www.redis.net.cn/tutorial/3509.html">哈希表</a>、<a target="_blank" rel="noopener" href="https://www.redis.net.cn/tutorial/3510.html">列表</a>、<a target="_blank" rel="noopener" href="https://www.redis.net.cn/tutorial/3511.html">集合</a>、<a target="_blank" rel="noopener" href="https://www.redis.net.cn/tutorial/3512.html">有序集合</a>，<a target="_blank" rel="noopener" href="https://www.redis.net.cn/tutorial/3508.html">位图</a>，<a target="_blank" rel="noopener" href="https://www.redis.net.cn/tutorial/3513.html">hyperloglogs</a>等数据类型。内置复制、<a target="_blank" rel="noopener" href="https://www.redis.net.cn/tutorial/3516.html">Lua脚本</a>、LRU收回、<a target="_blank" rel="noopener" href="https://www.redis.net.cn/tutorial/3515.html">事务</a>以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动<a target="_blank" rel="noopener" href="https://www.redis.net.cn/tutorial/3524.html">分区</a>。</p>
<h3 id="3-1-Redis-key"><a href="#3-1-Redis-key" class="headerlink" title="3.1 Redis-key"></a>3.1 Redis-key</h3><blockquote>
<p>在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过对Redis-key的操作，来完成对数据库中数据的操作。</p>
</blockquote>
<ul>
<li><code>exists key</code>：判断键是否存在</li>
<li><code>del key</code>：删除键值对</li>
<li><code>move key db</code>：将键值对移动到指定数据库</li>
<li><code>RENAME key newkey</code>: 修改 key 的名称</li>
</ul>
<p>↓↓↓↓以下内容的类型都是指redis中, 值的类型 ↓↓↓↓</p>
<h3 id="3-2-String"><a href="#3-2-String" class="headerlink" title="3.2 String"></a>3.2 String</h3><blockquote>
<p>在redis中, 通常键和值都是字符串, 当值为字符串时, 能够进行字符串的一系列操作</p>
</blockquote>
<p><code>set key value</code>: 设置键值对, 键存在就更新, 不存在就插入</p>
<p><code>get key</code>: 得到键对应的值</p>
<p><code>APPEND key value</code>: 在key对应的值后追加字符串value</p>
<p><code>DECR/INCR key</code>:  将指定key的value数值进行+1&#x2F;-1(仅对于数字)</p>
<h3 id="3-3-List-列表"><a href="#3-3-List-列表" class="headerlink" title="3.3 List(列表)"></a>3.3 List(列表)</h3><blockquote>
<p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
</blockquote>
<p><code>LPUSH/RPUSH key value1[value2..]</code>: 从左边&#x2F;右边向列表中PUSH值(一个或者多个)。</p>
<p><code>LRANGE key start end</code>: 获取list 起止元素（索引从左往右 递增）</p>
<ul>
<li>list实际上是一个链表，before Node after , left, right 都可以插入值</li>
<li><strong>如果key不存在，则创建新的链表</strong></li>
<li>如果key存在，新增内容</li>
<li>如果移除了所有值，空链表，也代表不存在</li>
<li>在两边插入或者改动值，效率最高！修改中间元素，效率相对较低</li>
</ul>
<h3 id="3-4-Set-集合"><a href="#3-4-Set-集合" class="headerlink" title="3.4 Set(集合)"></a>3.4 Set(集合)</h3><blockquote>
<p>Redis的Set是<strong>string类型</strong>的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
</blockquote>
<p><code>SADD key member1[member2..]</code>: 向集合中无序增加一个&#x2F;多个成员</p>
<p><code>SISMEMBER key member</code>: 返回集合中所有的成员</p>
<p><code>SRANDMEMBER key [count]</code>: 查询member元素是否是集合的成员,结果是无序的</p>
<h3 id="3-5-Hash（哈希）"><a href="#3-5-Hash（哈希）" class="headerlink" title="3.5 Hash（哈希）"></a>3.5 Hash（哈希）</h3><blockquote>
<p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>Set就是一种简化的Hash, 只变动Hash的key, 而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。</p>
</blockquote>
<p><code>HSET key field value</code>: 将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖, 返回0</p>
<h3 id="3-6-Zset（有序集合）"><a href="#3-6-Zset（有序集合）" class="headerlink" title="3.6 Zset（有序集合）"></a>3.6 Zset（有序集合）</h3><blockquote>
<p>不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>score相同：按字典顺序排序</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
</blockquote>
<p><code>ZADD key score member1 [score2 member2]</code>: 向有序集合添加一个或多个成员，或者更新已存在成员的分数</p>
<h3 id="3-7-三大特殊类型"><a href="#3-7-三大特殊类型" class="headerlink" title="3.7 三大特殊类型"></a>3.7 <strong>三大特殊类型</strong></h3><h4 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial(地理位置)"></a><strong>Geospatial(地理位置)</strong></h4><blockquote>
<p>使用经纬度定位地理坐标并用一个<strong>有序集合zset保存</strong>，所以zset命令也可以使用</p>
</blockquote>
<h4 id="Hyperloglog-基数统计"><a href="#Hyperloglog-基数统计" class="headerlink" title="Hyperloglog(基数统计)"></a><strong>Hyperloglog(基数统计)</strong></h4><blockquote>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。</p>
<p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p>其底层使用string数据类型</p>
</blockquote>
<p><strong>什么是基数？</strong></p>
<blockquote>
<p>数据集中不重复的元素的个数。</p>
</blockquote>
<p><strong>应用场景：</strong></p>
<p>网页的访问量（UV）：一个用户多次访问，也只能算作一个人。</p>
<blockquote>
<p>传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是<strong>计数</strong>，Hyperloglog就能帮助我们利用最小的空间完成。</p>
</blockquote>
<h4 id="BitMaps-位图"><a href="#BitMaps-位图" class="headerlink" title="BitMaps(位图)"></a><strong>BitMaps(位图)</strong></h4><blockquote>
<p>使用位存储，信息状态只有 0 和 1</p>
<p>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。</p>
</blockquote>
<p><strong>应用场景</strong></p>
<p>签到统计、状态统计</p>
<h2 id="5-事务"><a href="#5-事务" class="headerlink" title="5. 事务"></a>5. 事务</h2><h3 id="5-1-Redis事务介绍"><a href="#5-1-Redis事务介绍" class="headerlink" title="5.1 Redis事务介绍"></a>5.1 Redis事务介绍</h3><p>Redis的单条命令是保证原子性的，但是redis事务不能保证原子性</p>
<blockquote>
<p>Redis事务本质：一组命令的集合。</p>
<p>—————– 队列 set set set 执行 ——————-</p>
<p>事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。</p>
<ul>
<li>一次性</li>
<li>顺序性</li>
<li>排他性</li>
</ul>
<hr>
<ol>
<li>Redis事务没有隔离级别的概念</li>
<li>Redis单条命令是保证原子性的，但是事务不保证原子性！</li>
</ol>
</blockquote>
<h3 id="5-2-Redis事务操作过程"><a href="#5-2-Redis事务操作过程" class="headerlink" title="5.2 Redis事务操作过程"></a>5.2 Redis事务操作过程</h3><ul>
<li>开启事务（<code>multi</code>）</li>
<li>命令入队</li>
<li>执行事务（<code>exec</code>）</li>
</ul>
<p>所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p>
<h3 id="5-3-事务错误"><a href="#5-3-事务错误" class="headerlink" title="5.3 事务错误"></a>5.3 事务错误</h3><ul>
<li><p>代码语法错误（编译时异常）时, 所有的命令都不执行</p>
</li>
<li><p>而代码逻辑错误 (运行时异常) 时, **其他命令可以正常执行 ** &gt;&gt;&gt; <strong>所以不保证事务原子性</strong></p>
</li>
</ul>
<h3 id="5-4-监控"><a href="#5-4-监控" class="headerlink" title="5.4 监控"></a>5.4 监控</h3><p><strong>悲观锁：</strong></p>
<ul>
<li>很悲观，认为什么时候都会出现问题，无论做什么都会加锁</li>
</ul>
<p><strong>乐观锁：</strong></p>
<ul>
<li>很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li>
<li>获取version</li>
<li>更新的时候比较version</li>
</ul>
<p>使用乐观锁时, 若想要加锁, 则: 使用<code>watch key</code>监控指定数据，相当于乐观锁加锁。</p>
<p>注意：每次提交执行exec后都会自动释放锁，不管是否成功</p>
<h2 id="6-SpringBoot整合"><a href="#6-SpringBoot整合" class="headerlink" title="6. SpringBoot整合"></a>6. SpringBoot整合</h2><h3 id="6-1-Jedis"><a href="#6-1-Jedis" class="headerlink" title="6.1 Jedis"></a>6.1 Jedis</h3><p>使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。</p>
<h3 id="6-2-SpringBoot整合Redis"><a href="#6-2-SpringBoot整合Redis" class="headerlink" title="6.2 SpringBoot整合Redis"></a>6.2 SpringBoot整合Redis</h3><ol>
<li><p>导入依赖 org.springframework.boot spring-boot-starter-data-redis</p>
<p>能够在spring.factories中找到自动装配类RedisConfiguation, 和存放自动装配属性的类RedisProperty</p>
</li>
<li><p>RedisConfiguation, 有两个重要的Bean:</p>
<ol>
<li><strong>RedisTemplate</strong></li>
<li><strong>StringRedisTemplate</strong></li>
</ol>
</li>
<li><p>当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate, 通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型;</p>
</li>
<li><p>RedisProperty中有一些可以配置的属性: 如database, url, host, password, port, ssl….</p>
</li>
<li><p>编写配置文件:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置redis</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">39.99.xxx.xx</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用RedisTemplate:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis02SpringbootApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// redisTemplate 操作不同的数据类型，api和我们的指令是一样的</span></span><br><span class="line">        <span class="comment">// opsForValue 操作字符串 类似String</span></span><br><span class="line">        <span class="comment">// opsForList 操作List 类似List</span></span><br><span class="line">        <span class="comment">// opsForHah</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取连接对象</span></span><br><span class="line">        <span class="comment">//RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span></span><br><span class="line">        <span class="comment">//connection.flushDb();</span></span><br><span class="line">        <span class="comment">//connection.flushAll();</span></span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;mykey&quot;</span>,<span class="string">&quot;kuangshen&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;mykey&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实际应用中, 通常放Json字符串, 采用RedisTemplate.opsForValue().get(“json字符串”)</p>
</li>
</ol>
<h2 id="7-持久化–RDB"><a href="#7-持久化–RDB" class="headerlink" title="7. 持久化–RDB"></a>7. 持久化–RDB</h2><p>RDB：Redis Databases</p>
<h3 id="7-1-什么是RDB"><a href="#7-1-什么是RDB" class="headerlink" title="7.1 什么是RDB"></a>7.1 什么是RDB</h3><hr>
<p>在<strong>指定时间间隔</strong>后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ；</p>
<p><img src="/2023/02/24/Redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70.jpeg"></p>
<p>默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。</p>
<h3 id="7-2-工作原理"><a href="#7-2-工作原理" class="headerlink" title="7.2 工作原理"></a>7.2 工作原理</h3><hr>
<p>在进行 <strong><code>RDB</code></strong> 的时候，**<code>redis</code>** 的主线程是不会做 <strong><code>io</code></strong> 操作的，主线程会 <strong><code>fork</code></strong> 一个子线程来完成该操作；</p>
<ol>
<li>Redis 调用forks。同时拥有父进程和子进程。</li>
<li>子进程将数据集写入到一个临时 RDB 文件中。</li>
<li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li>
</ol>
<p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)</p>
<p><img src="/2023/02/24/Redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70-16772234339232.jpeg"></p>
<h3 id="7-3-触发机制"><a href="#7-3-触发机制" class="headerlink" title="7.3 触发机制"></a>7.3 触发机制</h3><ol>
<li>save的规则满足的情况下，会自动触发rdb原则</li>
<li>执行flushall命令，也会触发我们的rdb原则</li>
<li>退出redis，也会自动产生rdb文件</li>
</ol>
<h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>使用 <code>save</code> 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了；</p>
<blockquote>
<p>由于 <code>save</code> 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，<code>save</code>命令执行速度会非常慢，阻塞所有客户端的请求。</p>
</blockquote>
<h4 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h4><p><code>bgsave</code> 是异步进行，进行持久化的时候，<code>redis</code> 还可以将继续响应客户端请求 ；</p>
<h4 id="bgsave和save对比"><a href="#bgsave和save对比" class="headerlink" title="bgsave和save对比"></a><strong>bgsave和save对比</strong></h4><table>
<thead>
<tr>
<th>命令</th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody><tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>是否会redis阻塞</td>
<td>是</td>
<td>否(阻塞发生在fock(), 通常非常快)</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗其它的内存</td>
<td>不阻塞客户端命令</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端命令</td>
<td>需要fock子进程,消耗内存</td>
</tr>
</tbody></table>
<h3 id="7-4-RDB优缺点"><a href="#7-4-RDB优缺点" class="headerlink" title="7.4 RDB优缺点"></a>7.4 RDB优缺点</h3><p><strong>优点：</strong></p>
<ol>
<li>适合大规模的数据恢复</li>
<li>对数据的完整性要求不高</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了</strong>。</li>
<li>fork进程的时候，会占用一定的内容空间。</li>
</ol>
<h2 id="8-持久化–AOF"><a href="#8-持久化–AOF" class="headerlink" title="8. 持久化–AOF"></a>8. 持久化–AOF</h2><p><strong>Append Only File</strong></p>
<p>将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍</p>
<blockquote>
<p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
</blockquote>
<h3 id="8-1-什么是AOF"><a href="#8-1-什么是AOF" class="headerlink" title="8.1 什么是AOF"></a>8.1 什么是AOF</h3><ul>
<li>快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种<strong>完全耐久</strong>的持久化方式：AOF 持久化。</li>
<li>AOF 默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！</li>
</ul>
<h3 id="8-2-AOF优缺点"><a href="#8-2-AOF优缺点" class="headerlink" title="8.2 AOF优缺点"></a>8.2 AOF优缺点</h3><p><strong>优点</strong></p>
<ol>
<li>每一次修改都会同步，文件的完整性会更加好</li>
<li>每秒同步一次，可能会丢失一秒的数据</li>
<li>从不同步，效率最高</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！</li>
<li>Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li>
</ol>
<h3 id="8-3-如何选择使用哪种持久化方式？"><a href="#8-3-如何选择使用哪种持久化方式？" class="headerlink" title="8.3 如何选择使用哪种持久化方式？"></a>8.3 如何选择使用哪种持久化方式？</h3><ul>
<li>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</li>
<li>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</li>
<li>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</li>
</ul>
<h2 id="9-Redis主从复制"><a href="#9-Redis主从复制" class="headerlink" title="9. Redis主从复制"></a>9. Redis主从复制</h2><h3 id="9-1-概念"><a href="#9-1-概念" class="headerlink" title="9.1 概念"></a>9.1 概念</h3><p> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master&#x2F;Leader）,后者称为从节点（Slave&#x2F;Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p>
<p>默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p>
<h3 id="9-2-作用"><a href="#9-2-作用" class="headerlink" title="9.2 作用"></a>9.2 作用</h3><ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li>
<li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li>
<li>高可用基石：主从复制还是哨兵和集群能够实施的基础。</li>
</ol>
<h3 id="9-3-为什么使用集群"><a href="#9-3-为什么使用集群" class="headerlink" title="9.3 为什么使用集群"></a>9.3 为什么使用集群</h3><ol>
<li>单台服务器难以负载大量的请求</li>
<li>单台服务器故障率高，系统崩坏概率大</li>
<li>单台服务器内存容量有限。</li>
</ol>
<h3 id="9-4-使用规则"><a href="#9-4-使用规则" class="headerlink" title="9.4 使用规则"></a>9.4 使用规则</h3><ol>
<li>从机只能读，不能写，主机可读可写但是多用于写。</li>
<li>当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</li>
<li>当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。</li>
<li>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：<ul>
<li>从机手动执行命令<code>slaveof no one</code>, 这样执行以后从机会独立出来成为一个主机</li>
<li>使用哨兵模式（自动选举）</li>
</ul>
</li>
</ol>
<h3 id="9-5-哨兵模式"><a href="#9-5-哨兵模式" class="headerlink" title="9.5 哨兵模式"></a>9.5 哨兵模式</h3><p>相对于主从模式, 当主机宕机时, 有更好的解决办法, 能够自动确定一台主机.</p>
<p>哨兵的作用：</p>
<ul>
<li><p>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</p>
</li>
<li><p>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</p>
</li>
</ul>
<blockquote>
<p>哨兵模式优缺点</p>
</blockquote>
<p><strong>优点：</strong></p>
<ol>
<li>哨兵集群，基于主从复制模式，所有主从复制的优点，它都有</li>
<li>主从可以切换，故障可以转移，系统的可用性更好</li>
<li>哨兵模式是主从模式的升级，手动到自动，更加健壮</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多配置项</li>
</ol>
<h2 id="10-缓存穿透与雪崩"><a href="#10-缓存穿透与雪崩" class="headerlink" title="10. 缓存穿透与雪崩"></a>10. 缓存穿透与雪崩</h2><h3 id="10-1-缓存穿透（查不到）"><a href="#10-1-缓存穿透（查不到）" class="headerlink" title="10.1 缓存穿透（查不到）"></a>10.1 缓存穿透（查不到）</h3><blockquote>
<p>概念</p>
</blockquote>
<p>在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>布隆过滤器</strong></p>
<p>对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。</p>
<p><strong>缓存空对象</strong></p>
<p>一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。</p>
<h3 id="10-2-缓存击穿（量太大，缓存过期）"><a href="#10-2-缓存击穿（量太大，缓存过期）" class="headerlink" title="10.2 缓存击穿（量太大，缓存过期）"></a>10.2 缓存击穿（量太大，缓存过期）</h3><blockquote>
<p>概念</p>
</blockquote>
<p> 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p>
<p> 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<ol>
<li><p><strong>设置热点数据永不过期</strong></p>
<p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。</p>
</li>
<li><p><strong>加互斥锁(分布式锁)</strong></p>
<p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p>
</li>
</ol>
<h3 id="10-3-缓存雪崩"><a href="#10-3-缓存雪崩" class="headerlink" title="10.3 缓存雪崩"></a>10.3 缓存雪崩</h3><blockquote>
<p>概念</p>
</blockquote>
<p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<ul>
<li><p>redis高可用</p>
<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</p>
</li>
<li><p>限流降级</p>
<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
</li>
<li><p>数据预热</p>
<p><strong>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</strong></p>
</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Redis</p><p><a href="http://example.com/2023/02/24/Redis/">http://example.com/2023/02/24/Redis/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Zehao Tian</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-02-24</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-02-24</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Redis/">Redis</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">数据结构基础</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/02/24/SpringCloud/"><span class="level-item">SpringCloud</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/jetpacktocat.png" alt="田泽豪"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">田泽豪</p><p class="is-size-6 is-block">越努力，越幸运</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>HUST</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">53</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">20</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zehtian" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-Nosql概述"><span class="level-left"><span class="level-item">1</span><span class="level-item">1. Nosql概述</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-为什么要有Nosql"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">1.1 为什么要有Nosql</span></span></a></li><li><a class="level is-mobile" href="#1-2-什么是Nosql"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">1.2 什么是Nosql</span></span></a></li><li><a class="level is-mobile" href="#1-3-Nosql特点"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">1.3 Nosql特点</span></span></a></li><li><a class="level is-mobile" href="#1-4-Nosql的四大分类"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">1.4 Nosql的四大分类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-Redis入门"><span class="level-left"><span class="level-item">2</span><span class="level-item">2. Redis入门</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-什么是Redis"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">2.1 什么是Redis</span></span></a></li><li><a class="level is-mobile" href="#2-2-Redis能该干什么"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">2.2 Redis能该干什么</span></span></a></li><li><a class="level is-mobile" href="#2-3-Redis特性"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">2.3 Redis特性</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-Redis支持的五大类型"><span class="level-left"><span class="level-item">3</span><span class="level-item">3. Redis支持的五大类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-Redis-key"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">3.1 Redis-key</span></span></a></li><li><a class="level is-mobile" href="#3-2-String"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">3.2 String</span></span></a></li><li><a class="level is-mobile" href="#3-3-List-列表"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">3.3 List(列表)</span></span></a></li><li><a class="level is-mobile" href="#3-4-Set-集合"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">3.4 Set(集合)</span></span></a></li><li><a class="level is-mobile" href="#3-5-Hash（哈希）"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">3.5 Hash（哈希）</span></span></a></li><li><a class="level is-mobile" href="#3-6-Zset（有序集合）"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">3.6 Zset（有序集合）</span></span></a></li><li><a class="level is-mobile" href="#3-7-三大特殊类型"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">3.7 三大特殊类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Geospatial-地理位置"><span class="level-left"><span class="level-item">3.7.1</span><span class="level-item">Geospatial(地理位置)</span></span></a></li><li><a class="level is-mobile" href="#Hyperloglog-基数统计"><span class="level-left"><span class="level-item">3.7.2</span><span class="level-item">Hyperloglog(基数统计)</span></span></a></li><li><a class="level is-mobile" href="#BitMaps-位图"><span class="level-left"><span class="level-item">3.7.3</span><span class="level-item">BitMaps(位图)</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#5-事务"><span class="level-left"><span class="level-item">4</span><span class="level-item">5. 事务</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-1-Redis事务介绍"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">5.1 Redis事务介绍</span></span></a></li><li><a class="level is-mobile" href="#5-2-Redis事务操作过程"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">5.2 Redis事务操作过程</span></span></a></li><li><a class="level is-mobile" href="#5-3-事务错误"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">5.3 事务错误</span></span></a></li><li><a class="level is-mobile" href="#5-4-监控"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">5.4 监控</span></span></a></li></ul></li><li><a class="level is-mobile" href="#6-SpringBoot整合"><span class="level-left"><span class="level-item">5</span><span class="level-item">6. SpringBoot整合</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#6-1-Jedis"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">6.1 Jedis</span></span></a></li><li><a class="level is-mobile" href="#6-2-SpringBoot整合Redis"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">6.2 SpringBoot整合Redis</span></span></a></li></ul></li><li><a class="level is-mobile" href="#7-持久化–RDB"><span class="level-left"><span class="level-item">6</span><span class="level-item">7. 持久化–RDB</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#7-1-什么是RDB"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">7.1 什么是RDB</span></span></a></li><li><a class="level is-mobile" href="#7-2-工作原理"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">7.2 工作原理</span></span></a></li><li><a class="level is-mobile" href="#7-3-触发机制"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">7.3 触发机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#save"><span class="level-left"><span class="level-item">6.3.1</span><span class="level-item">save</span></span></a></li><li><a class="level is-mobile" href="#bgsave"><span class="level-left"><span class="level-item">6.3.2</span><span class="level-item">bgsave</span></span></a></li><li><a class="level is-mobile" href="#bgsave和save对比"><span class="level-left"><span class="level-item">6.3.3</span><span class="level-item">bgsave和save对比</span></span></a></li></ul></li><li><a class="level is-mobile" href="#7-4-RDB优缺点"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">7.4 RDB优缺点</span></span></a></li></ul></li><li><a class="level is-mobile" href="#8-持久化–AOF"><span class="level-left"><span class="level-item">7</span><span class="level-item">8. 持久化–AOF</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#8-1-什么是AOF"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">8.1 什么是AOF</span></span></a></li><li><a class="level is-mobile" href="#8-2-AOF优缺点"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">8.2 AOF优缺点</span></span></a></li><li><a class="level is-mobile" href="#8-3-如何选择使用哪种持久化方式？"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">8.3 如何选择使用哪种持久化方式？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#9-Redis主从复制"><span class="level-left"><span class="level-item">8</span><span class="level-item">9. Redis主从复制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#9-1-概念"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">9.1 概念</span></span></a></li><li><a class="level is-mobile" href="#9-2-作用"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">9.2 作用</span></span></a></li><li><a class="level is-mobile" href="#9-3-为什么使用集群"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">9.3 为什么使用集群</span></span></a></li><li><a class="level is-mobile" href="#9-4-使用规则"><span class="level-left"><span class="level-item">8.4</span><span class="level-item">9.4 使用规则</span></span></a></li><li><a class="level is-mobile" href="#9-5-哨兵模式"><span class="level-left"><span class="level-item">8.5</span><span class="level-item">9.5 哨兵模式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#10-缓存穿透与雪崩"><span class="level-left"><span class="level-item">9</span><span class="level-item">10. 缓存穿透与雪崩</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#10-1-缓存穿透（查不到）"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">10.1 缓存穿透（查不到）</span></span></a></li><li><a class="level is-mobile" href="#10-2-缓存击穿（量太大，缓存过期）"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">10.2 缓存击穿（量太大，缓存过期）</span></span></a></li><li><a class="level is-mobile" href="#10-3-缓存雪崩"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">10.3 缓存雪崩</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/MyBatis/"><span class="level-start"><span class="level-item">MyBatis</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringBoot/"><span class="level-start"><span class="level-item">SpringBoot</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringCloud/"><span class="level-start"><span class="level-item">SpringCloud</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringMVC/"><span class="level-start"><span class="level-item">SpringMVC</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/web%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">web基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">编程基础</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"><span class="level-start"><span class="level-item">论文写作</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">论文阅读笔记</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-01T12:57:45.000Z">2023-03-01</time></p><p class="title"><a href="/2023/03/01/java%E5%85%AB%E8%82%A1/">java八股</a></p><p class="categories"><a href="/categories/java/">java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-27T12:42:01.000Z">2023-02-27</time></p><p class="title"><a href="/2023/02/27/JVM/">JVM</a></p><p class="categories"><a href="/categories/java/">java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-27T12:41:49.000Z">2023-02-27</time></p><p class="title"><a href="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p><p class="categories"><a href="/categories/java/">java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-24T13:17:51.000Z">2023-02-24</time></p><p class="title"><a href="/2023/02/24/java%E6%96%B9%E6%B3%95/">java方法</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-24T13:17:21.000Z">2023-02-24</time></p><p class="title"><a href="/2023/02/24/%E7%AE%97%E6%B3%95/">算法</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">一月 2023</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">十二月 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JDBC/"><span class="tag">JDBC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MyBatis/"><span class="tag">MyBatis</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringBoot/"><span class="tag">SpringBoot</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringCloud/"><span class="tag">SpringCloud</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringMVC/"><span class="tag">SpringMVC</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html/"><span class="tag">html</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jvm/"><span class="tag">jvm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%83%E5%AD%A6%E4%B9%A0/"><span class="tag">元学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%88%90%E5%91%98%E6%8E%A8%E6%96%AD%E6%94%BB%E5%87%BB/"><span class="tag">成员推断攻击</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="tag">数据结构与算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"><span class="tag">机器学习基础</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">联邦学习</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"><span class="tag">论文写作</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><span class="tag">论文阅读笔记</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Blackpride</a><p class="is-size-7"><span>&copy; 2023 Zehao Tian</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>