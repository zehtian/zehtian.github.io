<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>设计模式 - 田泽豪的学习笔记</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="田泽豪的学习笔记"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="田泽豪的学习笔记"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本篇文章主要进行设计模式的介绍，设计模式是前辈们对代码开发经验的总结, 是解决特定问题的一系列套路, 他不是语法规定, 而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。本文中简要列出了23中设计模式，以及OOP七大原则，并重点介绍了单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式，适配器模式，桥接模式，代理模式和模板方法模式。"><meta property="og:type" content="blog"><meta property="og:title" content="设计模式"><meta property="og:url" content="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><meta property="og:site_name" content="田泽豪的学习笔记"><meta property="og:description" content="本篇文章主要进行设计模式的介绍，设计模式是前辈们对代码开发经验的总结, 是解决特定问题的一系列套路, 他不是语法规定, 而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。本文中简要列出了23中设计模式，以及OOP七大原则，并重点介绍了单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式，适配器模式，桥接模式，代理模式和模板方法模式。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230225201638551.png"><meta property="og:image" content="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230225201825785.png"><meta property="og:image" content="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230225205522250.png"><meta property="og:image" content="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230225222115531.png"><meta property="og:image" content="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226102104263.png"><meta property="og:image" content="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226105913321.png"><meta property="og:image" content="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226112223842.png"><meta property="og:image" content="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226112250414.png"><meta property="og:image" content="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226113645320.png"><meta property="og:image" content="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226113316590.png"><meta property="og:image" content="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/clip001.png"><meta property="og:image" content="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230227102018399.png"><meta property="article:published_time" content="2023-02-27T12:41:49.000Z"><meta property="article:modified_time" content="2023-02-27T12:55:25.923Z"><meta property="article:author" content="Zehao Tian"><meta property="article:tag" content="设计模式"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230225201638551.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},"headline":"设计模式","image":["http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230225201638551.png","http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230225201825785.png","http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230225205522250.png","http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230225222115531.png","http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226102104263.png","http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226105913321.png","http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226112223842.png","http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226112250414.png","http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226113645320.png","http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226113316590.png","http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/clip001.png","http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230227102018399.png"],"datePublished":"2023-02-27T12:41:49.000Z","dateModified":"2023-02-27T12:55:25.923Z","author":{"@type":"Person","name":"Zehao Tian"},"publisher":{"@type":"Organization","name":"田泽豪的学习笔记","logo":{"@type":"ImageObject","url":{"text":"Blackpride"}}},"description":"本篇文章主要进行设计模式的介绍，设计模式是前辈们对代码开发经验的总结, 是解决特定问题的一系列套路, 他不是语法规定, 而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。本文中简要列出了23中设计模式，以及OOP七大原则，并重点介绍了单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式，适配器模式，桥接模式，代理模式和模板方法模式。"}</script><link rel="canonical" href="http://example.com/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Blackpride</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-02-27T12:41:49.000Z" title="2023/2/27 20:41:49">2023-02-27</time>发表</span><span class="level-item"><time dateTime="2023-02-27T12:55:25.923Z" title="2023/2/27 20:55:25">2023-02-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">1 小时读完 (大约9034个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">设计模式</h1><div class="content"><p>本篇文章主要进行设计模式的介绍，设计模式是前辈们对代码开发经验的总结, 是解决特定问题的一系列套路, 他不是语法规定, 而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。本文中简要列出了23中设计模式，以及OOP七大原则，并重点介绍了单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式，适配器模式，桥接模式，代理模式和模板方法模式。</p>
<span id="more"></span>



<h2 id="1-设计模式概述"><a href="#1-设计模式概述" class="headerlink" title="1. 设计模式概述"></a>1. 设计模式概述</h2><p>设计模式是前辈们对代码开发经验的总结, 是解决特定问题的一系列套路, 他不是语法规定, 而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。</p>
<h3 id="1-1-23种设计模式"><a href="#1-1-23种设计模式" class="headerlink" title="1.1 23种设计模式"></a><strong>1.1 23种设计模式</strong></h3><ul>
<li>创建型模式：<ul>
<li>单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式</li>
</ul>
</li>
<li>结构型模式<ul>
<li>适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式</li>
</ul>
</li>
<li>行为型模式：<ul>
<li>模板方法模式，命令模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式，访问者模式</li>
</ul>
</li>
</ul>
<h3 id="1-2-OOP七大原则"><a href="#1-2-OOP七大原则" class="headerlink" title="1.2 OOP七大原则"></a>1.2 OOP七大原则</h3><ul>
<li>开闭原则（核心）：对扩展开放，对修改关闭。就是添加功能不能改变原有代码；</li>
<li>里氏替换原则：继承必须确保超类所拥有的性质在子类中仍然成立。就是子类不要重写父类的方法；</li>
<li>依赖倒置原则：要面向接口编程，不要面向实现编程。就是先写好接口，各个实现类去分别实现接口；</li>
<li>单一职责原则：控制类的粒度大小，将对象解耦，提高其内聚性。就是每一个类实现一个功能，要拆分彻底；</li>
<li>接口隔离原则：要为各个类建立他们需要的专用接口；</li>
<li>迪米特法则 ：只与你的直接朋友交谈，不跟陌生人说话。就是A要与C建立连接，最好找一个B，保证A和B，B和C之间都有连接；</li>
<li>合成复用原则：尽量先使用组合或者聚合等关联关系实现，其次再考虑使用继承关系。</li>
</ul>
<h2 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2. 单例模式"></a>2. 单例模式</h2><h3 id="2-1-饿汉式"><a href="#2-1-饿汉式" class="headerlink" title="2.1 饿汉式"></a>2.1 饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造器，外部无法直接调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Hungry</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一上来就加载了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Hungry</span> <span class="variable">HUNGRY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hungry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类的实例化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HUNGRY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>饿汉式在类的创建时，就已经进行了实例化，创建好了静态的对象供系统使用，以后不再改变，因此是<strong>线程安全的</strong>；</li>
<li>但饿汉式需要<strong>消耗大量的内存</strong>，因为每次加载都会进行实例化，于是有了懒汉式，仅在需要实例时才创建。</li>
</ul>
<h3 id="2-2-DCL-懒汉式"><a href="#2-2-DCL-懒汉式" class="headerlink" title="2.2 DCL 懒汉式"></a>2.2 DCL 懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先声明，但没有使用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双重检测锁模式的懒汉式单例 DCL懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//加上同步锁，保证线程安全</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">                <span class="comment">//等到需要创建实例时，再进行实例化</span></span><br><span class="line">                <span class="keyword">if</span>(lazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">                    lazyMan = <span class="keyword">new</span> <span class="title class_">LazyMan</span>();</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                      1.分配内存空间</span></span><br><span class="line"><span class="comment">                      2.执行构造方法，初始化对象</span></span><br><span class="line"><span class="comment">                      3.把这个对象指向这个空间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                      正常流程：123</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                      但有时候会出现指令重排，如132  --线程A</span></span><br><span class="line"><span class="comment">                      在这种情况下，如果出现了线程B，就会出现lazyMan!=null，但还没有完成构造的情况</span></span><br><span class="line"><span class="comment">                      因此要加上volatile</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>正常的懒汉式是<strong>线程不安全</strong>的，因为在多线程的情况下，无法保证每次的实例化对象是相同的，可能会出现多个对象；</p>
</li>
<li><p>于是添加了同步锁，进行双重检测锁模式，使得线程变为安全；</p>
</li>
<li><p>但由于lazyMan &#x3D; new LazyMan()不是一个原子性操作，会受到指令重排的影响。在多线程情况下，会导致实例无法构造，于是需要添加volatile关键字，避免指令重排的情况；</p>
</li>
<li><p>补充：原子性操作：<strong>不会被线程调度机制打断的操作</strong>。这种操作一旦开始，就一直运行到结束，中间不会出现线程切换。也就是一定要按顺序执行完。</p>
</li>
</ul>
<h3 id="2-3-静态内部类"><a href="#2-3-静态内部类" class="headerlink" title="2.3 静态内部类"></a>2.3 静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Holder</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.HOLDER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在内部类中实例化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Holder</span> <span class="variable">HOLDER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-4-枚举"><a href="#2-4-枚举" class="headerlink" title="2.4 枚举"></a>2.4 枚举</h3><p>由于反射的存在，可以将构造器，或者属性的<strong>私有性破坏</strong>，导致：这些单例模式都不安全！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//enum 本身也是一个Class类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EnumSingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>枚举可以避免反射的发生。</p>
<h3 id="2-5-单例模式总结"><a href="#2-5-单例模式总结" class="headerlink" title="2.5 单例模式总结"></a>2.5 单例模式总结</h3><ul>
<li><p>核心作用：保证一个类只有一个实例，并且提供一个访问实例的全局访问点。</p>
</li>
<li><p>常见场景：</p>
<ul>
<li><p>Windows的任务管理器，回收站；</p>
</li>
<li><p>读取配置文件的类，一般也只有一个对象；</p>
</li>
<li><p>网站的计数器一般也会采用单例模式，来保证同步；</p>
</li>
<li><p><strong>数据库连接池的设计一般也算单例模式</strong>；</p>
</li>
<li><p>Servlet编程中，每个Servlet也是单例的；</p>
</li>
<li><p><strong>在Spring中，每个Bean默认就是单例的</strong>：这些Bean只能有一个实例，当spring创建applicationContext容器的时候，spring会初始化所有的该作用域实例；</p>
<p>此外，Spring中的Bean也可以设置为原型模式，每次通可以过getBean获取一个新实例，创建后spring将不再对其管理。</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3. 工厂模式"></a>3. 工厂模式</h2><ul>
<li>作用：实现了创建者和调用者的分离</li>
<li>核心本质：<ul>
<li><strong>实例化对象不使用new，用工厂方法代替</strong>；</li>
<li>将选择实现类，创建对象统一管理和控制。从而<strong>将调用者跟我们的实现类</strong>解耦。</li>
</ul>
</li>
<li>详细分类<ul>
<li>简单工厂模式 ：用来生成同一等级结构中的任意产品（对于增加的新产品，需要覆盖已有代码）；</li>
<li>工厂方法模式：用来生产同一等级结构中的固定产品（支持增加任意产品）；</li>
<li>抽象工厂模式：围绕一个超级工厂创建其他工厂，该超级工厂称为其它工厂的工厂。</li>
</ul>
</li>
</ul>
<h3 id="3-1-简单工厂模式"><a href="#3-1-简单工厂模式" class="headerlink" title="3.1 简单工厂模式"></a>3.1 简单工厂模式</h3><ul>
<li>构建一个工厂，需要实例化类时，直接<strong>调用工厂的方法</strong>即可。在工厂中进行类的实例化；</li>
<li>简单工厂模式不满足开闭原则，当新增一个类时，需要改变<code>CarFactory</code>类的代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单工厂模式，也叫静态工厂</span></span><br><span class="line"><span class="comment">//如果要新增功能，需要修改此类，不满足开闭原则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    <span class="comment">//拿车</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">getCar</span><span class="params">(String car)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(car.equals(<span class="string">&quot;五菱&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WuLing</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(car.equals(<span class="string">&quot;特斯拉&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tesla</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 原始方式</span></span><br><span class="line"><span class="comment">//        Car car1 = new WuLing();</span></span><br><span class="line"><span class="comment">//        Car car2 = new Tesla();</span></span><br><span class="line"><span class="comment">//        car1.name();</span></span><br><span class="line"><span class="comment">//        car2.name();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.工厂模式，直接去工厂拿，要什么拿什么，不需要new对象了</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> CarFactory.getCar(<span class="string">&quot;五菱&quot;</span>);</span><br><span class="line">        car1.name();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230225201638551.png"></p>
<h3 id="3-2-工厂方法模式"><a href="#3-2-工厂方法模式" class="headerlink" title="3.2 工厂方法模式"></a>3.2 工厂方法模式</h3><ul>
<li>设计一个工厂的接口，每一个类都再编写一个对应的工厂类，并实现该接口；</li>
<li>需要实例化类时，直接实例化对应的工厂，并调用工厂接口中的方法;</li>
<li>当新增一个类时，直接再新增一个对应的工厂类，并实现工厂接口<code>CarFactory</code>，不需要修改原来的代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂方法模式，能够满足开闭原则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    Car <span class="title function_">getCar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WuLingFactory</span> <span class="keyword">implements</span> <span class="title class_">CarFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">getCar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WuLing</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WuLingFactory</span>().getCar();</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeslaFactory</span>().getCar();</span><br><span class="line">        car1.name();</span><br><span class="line">        car2.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230225201825785.png"></p>
<h3 id="3-3-两种方式的比较"><a href="#3-3-两种方式的比较" class="headerlink" title="3.3 两种方式的比较"></a>3.3 两种方式的比较</h3><ul>
<li>根据设计原则，工厂方法模式更优，因为满足开闭原则；</li>
<li>根据实际业务，简单工厂模式更优，业务复杂度低，且易于管理，就管理一个工厂类就行了。</li>
</ul>
<h3 id="3-4-工厂模式总结"><a href="#3-4-工厂模式总结" class="headerlink" title="3.4 工厂模式总结"></a>3.4 工厂模式总结</h3><ul>
<li>简单工厂模式（静态工厂模式)<ul>
<li>虽然某种程度上不符合设计原则，但实际使用最多！</li>
</ul>
</li>
<li>工厂方法模式<ul>
<li>不修改已有类的前提下，通过增加新的工厂类实现扩展。</li>
</ul>
</li>
<li>抽象工厂模式<ul>
<li>不可以增加产品，可以增加产品族!</li>
</ul>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li>JDK中Calendar的getlnstance方法；</li>
<li>JDBC中的Connection对象的获取；</li>
<li>Spring中IOC容器创建管理bean对象。IOC将多个Bean放在了工厂中，使用时，直接调用工厂的getBean方法，想要什么，就在参数中设置什么：getBean(要获取的Bean的id)；<ul>
<li>在IOC容器中，通过静态工厂方法声明创建bean的步骤是：<ol>
<li>首先在bean的class属性里指定静态工厂类的全类名;</li>
<li>同时在factory-method属性里指定工厂方法的名称;</li>
<li>最后使用&lt;constrctor-arg&gt;元素为该方法传递方法参数;</li>
<li><strong>通过ioc容器的getBean()方法就可以获取到创建的bean对象</strong></li>
</ol>
</li>
</ul>
</li>
<li>反射中Class对象的newInstance方法</li>
</ul>
<h2 id="4-抽象工厂模式"><a href="#4-抽象工厂模式" class="headerlink" title="4. 抽象工厂模式"></a>4. 抽象工厂模式</h2><p>抽象工厂模式提供了一个<strong>创建一系列相关或者相互依赖对象的接口，无需指定它们具体的类</strong></p>
<p>适用场景：</p>
<ul>
<li><p>客户端（应用层）不依赖于产品类实例如何被创建、实现等细节；</p>
</li>
<li><p>强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量的重复代码；</p>
</li>
<li><p>提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体的实现</p>
</li>
<li><p>优点：具体产品在应用层的代码隔离，无需关心创建的细节将一个系列的产品统一到一起创建</p>
</li>
<li><p>缺点：规定了所有可能被创建的产品集合，产品簇中扩展新的产品困难；加了系统的抽象性和理解难度</p>
</li>
</ul>
<p>个人理解：</p>
<ul>
<li>创建了一个抽象工厂的接口，里面包含了获取各种产品的方法（即规定了所有可能被创建的产品集合）；</li>
<li>每个子工厂都需要实现该抽象工厂接口，同时实现接口的方法，分别调用自己下面的产品；</li>
<li>客户端实例对象时，<strong>先实例化对应的工厂（该工厂实现了抽象工厂的接口），然后调用工厂的方法获取实例</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象产品工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IProductFactory</span> &#123;</span><br><span class="line">    <span class="comment">//生产手机</span></span><br><span class="line">    IphoneProduct <span class="title function_">iphoneProduct</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//生产路由器</span></span><br><span class="line">    IRouterProduct <span class="title function_">iRouterProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子工厂类，实现抽象工厂接口，在其中实例化对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title class_">IProductFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IphoneProduct <span class="title function_">iphoneProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XiaoMiPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IRouterProduct <span class="title function_">iRouterProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XiaoMiRouter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaWeiFactory</span> <span class="keyword">implements</span> <span class="title class_">IProductFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IphoneProduct <span class="title function_">iphoneProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaWeiPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IRouterProduct <span class="title function_">iRouterProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaWeiRouter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------小米系列---------------------&quot;</span>);</span><br><span class="line">        <span class="type">IProductFactory</span> <span class="variable">xiaomiFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XiaoMiFactory</span>();</span><br><span class="line">        <span class="type">IphoneProduct</span> <span class="variable">iphoneProduct</span> <span class="operator">=</span> xiaomiFactory.iphoneProduct();</span><br><span class="line">        iphoneProduct.callUp();</span><br><span class="line">        <span class="type">IRouterProduct</span> <span class="variable">iRouterProduct</span> <span class="operator">=</span> xiaomiFactory.iRouterProduct();</span><br><span class="line">        iRouterProduct.openWifi();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------华为系列---------------------&quot;</span>);</span><br><span class="line">        <span class="type">IProductFactory</span> <span class="variable">huaWeiFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuaWeiFactory</span>();</span><br><span class="line">        <span class="type">IphoneProduct</span> <span class="variable">iphoneProduct1</span> <span class="operator">=</span> huaWeiFactory.iphoneProduct();</span><br><span class="line">        <span class="type">IRouterProduct</span> <span class="variable">iRouterProduct1</span> <span class="operator">=</span> huaWeiFactory.iRouterProduct();</span><br><span class="line">        iphoneProduct1.callUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类图：</p>
<p><img src="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230225205522250.png"></p>
<h2 id="5-建造者模式"><a href="#5-建造者模式" class="headerlink" title="5. 建造者模式"></a>5. 建造者模式</h2><ul>
<li>建造者模式也属于创建型模式，它提供了一种创建对象的最佳方式；</li>
<li>定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示；</li>
<li>主要作用：在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象；</li>
<li>用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)</li>
</ul>
<p>例子：<br>工厂（建造者模式）︰负责制造汽车（组装过程和细节在工厂内）<br>汽车购买者（用户）：只需要说出需要的型号（对象的类型和内容），然后直接购买就可以使用了（不需要知道汽车是怎么组装的（车轮、车门、发动机、方向盘等等））。</p>
<p>角色分析（以建房子为例）：</p>
<p><img src="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230225222115531.png"></p>
<p>假设造房简化为如下步骤：(1）地基（2）钢筋工程（3）铺电线（4）粉刷；</p>
<p><strong>如果要盖一座房子：</strong></p>
<ul>
<li><strong>首先要找一个建筑公司或工程承包商（指挥者Director），用于选择具体的工人（具体建造者Builder）过来造房子（产品Product），同时指定建房子的顺序（上述四个步骤的顺序），最后验收；</strong></li>
<li><strong>具体建造者Builder负责完成建房子的四个步骤（没有顺序，就是说四个步骤都能做），建造者负责建成房子（Product）；</strong></li>
<li><strong>产品Product就是最终的结果，也包含了上述的四个部分。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象的建造者：方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//四个步骤</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildA</span><span class="params">()</span>; <span class="comment">//铺地基</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildB</span><span class="params">()</span>; <span class="comment">//钢筋工程</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildC</span><span class="params">()</span>; <span class="comment">//铺电线</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildD</span><span class="params">()</span>; <span class="comment">//粉刷</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终结果：得到了房子</span></span><br><span class="line">    <span class="keyword">abstract</span> Product <span class="title function_">getProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的建造者：工人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line">    <span class="comment">//工人负责创建产品！！很重要</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">()</span>&#123;</span><br><span class="line">        product = <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildA</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setBuildA(<span class="string">&quot;地基&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;地基&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildB</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setBuildB(<span class="string">&quot;钢筋工程&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;钢筋工程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildC</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setBuildC(<span class="string">&quot;铺电线&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;铺电线&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildD</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setBuildD(<span class="string">&quot;粉刷&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;粉刷&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Product <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指挥：核心，负责指挥构建一个工程，工程如何构建，由他决定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指挥工人按照顺序建房子</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">build</span><span class="params">(Builder builder)</span>&#123;</span><br><span class="line">        builder.buildA();</span><br><span class="line">        builder.buildB();</span><br><span class="line">        builder.buildC();</span><br><span class="line">        builder.buildD();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.getProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//指挥</span></span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>();</span><br><span class="line">        <span class="comment">//指挥 具体的工人完成 产品</span></span><br><span class="line">        <span class="comment">//指挥：可以自己选取工人，还能选取建造顺序</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">build</span> <span class="operator">=</span> director.build(<span class="keyword">new</span> <span class="title class_">Worker</span>());</span><br><span class="line">        System.out.println(build.toString());</span><br><span class="line">        <span class="comment">//因此，对于消费者来说，只需要找到指挥就行了，剩下的全都无关，指挥者最后得到了产品，并交给消费者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：</p>
<ul>
<li>产品的建造和表示分离，实现了解耦（也就是结果和过程分开，交给别人做，自己拿结果就行，而不是自己创建一个对象）。使用建造者模式可以使客户端不必知道产品内部组成的细节；</li>
<li>将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰；</li>
<li>具体的建造者类之间是相互独立的，这有利于系统的扩展（因为有着共同的接口）。增加新的具体建造者无需修改原有类库的代码，符合“开闭原则“，客户可以选择任意的建造者。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似（因为有一个抽象的接口）；如果产<strong>品之间的差异性很大</strong>（图纸都变了，那需要更多的接口了），则不适合使用建造者模式，因此其使用范围受到一定的限制；</li>
<li>如果<strong>产品的内部变化复杂</strong>，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li>
</ul>
</li>
<li><p>应用场景：</p>
<ul>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象<strong>具备共性;</strong></li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品；</li>
<li>适合于一个具有较多的零件（属性）的产品（对象）的创建过程。</li>
</ul>
</li>
<li><p>建造者与抽象工厂模式的比较:</p>
<ul>
<li>与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族；</li>
<li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象；</li>
<li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车！</li>
</ul>
</li>
<li><p>一个具体应用：lombok插件中的@Builder注解</p>
<ul>
<li><p>Builder 使用创建者模式又叫建造者模式。简单来说，就是<strong>一步步创建一个对象，它对用户屏蔽了里面构建的细节，但却可以精细地控制对象的构造过程</strong>。</p>
</li>
<li><p>@Builder内部帮我们做了什么？能够帮助初始化你的实例对象。</p>
<ol>
<li><strong>创建一个名为<code>ThisClassBuilder</code>的内部静态类，并具有和实体类形同的属性（称为构建器）</strong>;</li>
<li>在实体类中：会创建一个<code>build()</code>方法，它的目的是用来创建构建器；</li>
<li>在构建器中：对于目标类中的所有的属性和未初始化的<code>final</code>字段，都会在构建器中创建对应属性；</li>
<li>在构建器中：创建一个无参的<code>default</code>构造函数；</li>
<li>在构建器中：对于实体类中的每个参数，都会对应创建类似于<code>setter</code>的方法，只不过方法名与该参数名相同。并且返回值是构建器本身（便于链式调用）；</li>
<li>在构建器中：一个<code>build()</code>方法，调用此方法，就会根据设置的值进行创建实体对象；</li>
<li>在构建器中：同时也会生成一个<code>toString()</code>方法。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="6-原型模式"><a href="#6-原型模式" class="headerlink" title="6. 原型模式"></a>6. 原型模式</h2><h3 id="6-1-原型模式"><a href="#6-1-原型模式" class="headerlink" title="6.1 原型模式"></a>6.1 原型模式</h3><ul>
<li><p>原型模式可以理解为克隆，先创建（new）一个被克隆的对象，当需要创建和原对象相同的对象时，直接进行克隆即可；</p>
</li>
<li><p>浅克隆：克隆前后的对象指向同一个引用，即改变前对象的属性，克隆后的对象也会发生变化；</p>
</li>
<li><p>深克隆：克隆前后的对象都指向各自的引用，即改变前对象的属性，克隆后的对象保持不变。</p>
</li>
<li><p>被克隆的类需要：实现Cloneable接口，并重写clone方法</p>
</li>
</ul>
<p>图解：</p>
<p><img src="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226102104263.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浅克隆</span></span><br><span class="line"><span class="comment">//被克隆的类，也叫原型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Video</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//能够被克隆</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Video</span><span class="params">(String name, Date date)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Video&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, date=&quot;</span> + date +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深克隆</span></span><br><span class="line"><span class="comment">//被克隆的类，也叫原型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Video</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//能够被克隆</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//修改克隆方法，使其成为深克隆</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="built_in">super</span>.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现深克隆：将这个对象的属性也进行克隆</span></span><br><span class="line">        <span class="type">Video</span> <span class="variable">v</span> <span class="operator">=</span> (Video) obj;</span><br><span class="line">        v.date = (Date) <span class="built_in">this</span>.date.clone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Video</span><span class="params">(String name, Date date)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Video&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, date=&quot;</span> + date +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现克隆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bilibili</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">Video</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Video</span>(<span class="string">&quot;狂神说Java&quot;</span>, date);</span><br><span class="line">        <span class="type">Video</span> <span class="variable">v2</span> <span class="operator">=</span> (Video) v1.clone();</span><br><span class="line">        System.out.println(v1.toString());</span><br><span class="line">        System.out.println(v2.toString());</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//浅克隆：克隆前后的对象指向同一个引用date，更改date会导致二者都发生变化</span></span><br><span class="line">        date.setTime(<span class="number">123123132</span>);</span><br><span class="line">        System.out.println(v1.toString());</span><br><span class="line">        System.out.println(v2.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个具体的应用：</p>
<ul>
<li>spring容器管理bean的另一种方法：原型模式，实现创建好每个bean的实例，每次使用getBean时就克隆一份。</li>
</ul>
<h3 id="6-2-创造型模式总结"><a href="#6-2-创造型模式总结" class="headerlink" title="6.2 创造型模式总结"></a>6.2 创造型模式总结</h3><ul>
<li>创建型模式的作用：帮我们new对象的（或者克隆对象），与对象的创建有关；</li>
<li>单例模式保证一个类只有一个实例；</li>
<li>工厂模式分为简单工厂和工厂方法，一般简单工厂模式就够了；</li>
<li>抽象工厂模式是生产一个大的产品族，而工厂模式是生产一个具体的产品；</li>
<li>建造者模式让对象的创建和使用分离，可以将一个个模块通过指挥者进行指挥拼装，可以创建复杂对象；</li>
<li>原型模式只需要new一个原型，后面的实例可以直接克隆原型，可以提高效率。对象复杂时，可以考虑使用原型模式。</li>
</ul>
<h2 id="7-适配器模式"><a href="#7-适配器模式" class="headerlink" title="7. 适配器模式"></a>7. 适配器模式</h2><p>结构型模式：从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题。</p>
<p>适配器模式：</p>
<ul>
<li><strong>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作</strong>；</li>
<li>角色分析：<ul>
<li>目标接口：客户所期待的接口，目标可以是具体的或抽象的类，也可以是接口。（比如这里的电脑USB）</li>
<li>需要适配的类：需要适配的类或适配者类。（网线）</li>
<li>造配器：通过包装一个需要适配的对象，把原接口转换成目标对象</li>
</ul>
</li>
</ul>
<p><img src="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226105913321.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要被适配的类：网线</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接网线上网&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口转换器的抽象实现，用于造转换器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NetToUsb</span> &#123;</span><br><span class="line">    <span class="comment">//作用：处理请求，网线=&gt;usb</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器</span></span><br><span class="line"><span class="comment">//采用组合方式（对象适配器），也可以直接继承（类适配器）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter2</span> <span class="keyword">implements</span> <span class="title class_">NetToUsb</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//用有参构造器去包装被适配类（网线）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter2</span><span class="params">(Adaptee adaptee)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.request();  <span class="comment">//可以上网了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端类：电脑</span></span><br><span class="line"><span class="comment">//想上网，但插不上网线</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="comment">//上网：电脑需要转接器才可以上网</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">net</span><span class="params">(NetToUsb adapter)</span>&#123;</span><br><span class="line">        <span class="comment">//找一个转接头</span></span><br><span class="line">        adapter.handleRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//电脑，适配器，网线</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">Adaptee</span> <span class="variable">adaptee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adaptee</span>();</span><br><span class="line">        <span class="type">Adapter2</span> <span class="variable">adapter2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter2</span>(adaptee);</span><br><span class="line">        </span><br><span class="line">        computer.net(adapter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>对象适配器优点：<ul>
<li>一个对象适配器可以<strong>把多个不同的适配者适配到同一个目标</strong>；</li>
<li>可以适配一个适配者的子类，满足“里氏代换原则”；</li>
</ul>
</li>
<li>类适配器缺点：<ul>
<li>对于Java、C#等不支持多重类继承的语言，<strong>一次最多只能适配一个适配者类</strong>，不能同时适配多个适配者;</li>
<li>在Java、C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</li>
</ul>
</li>
</ul>
<p>具体的应用：</p>
<ul>
<li>InputStreamReader(InputStream)   &#x2F;&#x2F;字符流转字节流  进行了转接；</li>
<li>SpringMVC <strong>Dispachter中的处理器映射器，处理器适配器</strong>；</li>
<li>SpringBoot中的AutoConfig类中有很多适配器。</li>
</ul>
<h2 id="8-桥接模式"><a href="#8-桥接模式" class="headerlink" title="8. 桥接模式"></a>8. 桥接模式</h2><ul>
<li>桥接模式是将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体（Handle and Body）模式或接口（Interfce）模式；</li>
<li>适用于出现大量多继承的情况中，每个抽象部分（独立变化的维度）只负责对应的功能（如电脑品牌，电脑类型）</li>
</ul>
<p><img src="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226112223842.png"></p>
<p><img src="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226112250414.png"></p>
<p>将复杂的多继承关系，按照独立的维度进行了转化，侧重点：找连接点（桥）。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//品牌Brand</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Brand</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lenovo</span> <span class="keyword">implements</span> <span class="title class_">Brand</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;联想&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mac</span> <span class="keyword">implements</span> <span class="title class_">Brand</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类型Computer</span></span><br><span class="line"><span class="comment">//抽象类，只能被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="comment">//组合，建桥（Brand和Computer的桥）</span></span><br><span class="line">    <span class="keyword">private</span> Brand brand;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">(Brand brand)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">        brand.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Laptop</span> <span class="keyword">extends</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Laptop</span><span class="params">(Brand brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.info();</span><br><span class="line">        System.out.print(<span class="string">&quot;手提电脑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> <span class="keyword">extends</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(Brand brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.info();</span><br><span class="line">        System.out.print(<span class="string">&quot;笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//联想笔记本</span></span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="keyword">new</span> <span class="title class_">Lenovo</span>());</span><br><span class="line">        book.info();</span><br><span class="line">        <span class="comment">//苹果手提电脑</span></span><br><span class="line">        <span class="type">Laptop</span> <span class="variable">laptop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Laptop</span>(<span class="keyword">new</span> <span class="title class_">Mac</span>());</span><br><span class="line">        laptop.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226113645320.png"></p>
<ul>
<li>好处分析：<ul>
<li>桥接模式偶尔类似于多继承方案，但是多继承方案违背了类的单一职责原则，复用性比较差，类的个数也非常多，桥接模式是比多继承方案更好的解决方法，<strong>极大的减少了子类的个数，从而降低管理和维护的成本</strong>；</li>
<li>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。<strong>符合开闭原则</strong>，就像一座桥，可以把两个变化的维度连接起来。</li>
</ul>
</li>
<li>劣势分析：<ul>
<li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程；</li>
<li>桥接模式要求<strong>正确识别出系统中两个独立变化的维度</strong>，因此其使用范围具有一定的局限性。</li>
</ul>
</li>
</ul>
<p>场景：</p>
<ul>
<li>Java语言通过Java虚拟机实现了平台的无关性；（一个维度：java虚拟机功能程序；另一个维度：能够适用的系统：可以在Windows，Linux…上适用）</li>
<li>AWT中的Peer架构；</li>
<li>JDBC驱动程序也是桥接模式的应用之一。（一个维度：JDBC本身的功能实现；另一个维度：连接的数据库：可以连接Mysql，可以连接Oracle…）</li>
</ul>
<p><img src="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230226113316590.png"></p>
<h2 id="9-代理模式"><a href="#9-代理模式" class="headerlink" title="9. 代理模式"></a>9. 代理模式</h2><h3 id="9-1-代理模式原理"><a href="#9-1-代理模式原理" class="headerlink" title="9.1 代理模式原理"></a>9.1 代理模式原理</h3><p>代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<p><strong>代理设计模式的原理：</strong></p>
<p>使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</p>
<ul>
<li>之前为大家讲解过代理机制的操作，属于<strong>静态代理</strong>，<strong>特征是代理类和目标对象的类都是在编译期间确定下来</strong>，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最好可以通过一个代理类完成全部的代理功能；</li>
<li><strong>动态代理</strong>是指客户通过代理类来调用其它对象的方法，并且是<strong>在程序运行时根据需要动态创建目标类的代理对象。</strong>动态代理使用场合：1.调试；2.远程方法调用；</li>
<li>动态代理相比于静态代理的优点：抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。</li>
</ul>
<h3 id="9-2-静态代理"><a href="#9-2-静态代理" class="headerlink" title="9.2 静态代理"></a>9.2 静态代理</h3><p>角色分析：</p>
<ul>
<li><p>抽象角色：一般会使用接口或者抽象类来解决；</p>
</li>
<li><p>真实角色：被代理的角色；</p>
</li>
<li><p>代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作；</p>
</li>
<li><p>客户：访问代理对象的人。即main方法。</p>
</li>
<li><p>真实角色和代理角色都要实现抽象角色的接口，代理角色需要组合真实角色，实现代理，同时可以增加操作。</p>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserDAO</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDAO</span> <span class="keyword">implements</span> <span class="title class_">IUserDAO</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDAO-插入/更新用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理角色，可以相较原始角色，增加新的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDAOTransactionProxy</span> <span class="keyword">implements</span> <span class="title class_">IUserDAO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IUserDAO realMapper;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDAOTransactionProxy</span><span class="params">(IUserDAO realMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.realMapper = realMapper;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 增强逻辑：执行前处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;proxy-开启事务&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用被代理对象的方法</span></span><br><span class="line">        realMapper.save();</span><br><span class="line">        <span class="comment">// 增强逻辑：执行后处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;proxy-提交事务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 真实对象（原对象）</span></span><br><span class="line">    <span class="type">IUserDAO</span> <span class="variable">realMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDAO</span>();</span><br><span class="line">    <span class="comment">// 代理对象 持有原对象</span></span><br><span class="line">    <span class="type">IUserDAO</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDAOTransactionProxy</span>(realMapper);</span><br><span class="line">    <span class="comment">// 执行IUserDAO接口对象的方法</span></span><br><span class="line">    mapper.save();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>代理模式（静态代理）的好处:</p>
<ul>
<li>可以使真实角色的操作更加纯粹！不用去关注一些公共的业务；</li>
<li><strong>公共业务就交给代理角色</strong>，实现了业务的分工；</li>
<li>公共业务发生扩展的时候，方便集中管理。</li>
</ul>
<p>（静态代理）缺点:</p>
<ul>
<li>一个真实角色就会产生一个代理角色；</li>
<li>代码量会翻倍，开发效率会变低。</li>
</ul>
<h3 id="9-3-动态代理"><a href="#9-3-动态代理" class="headerlink" title="9.3 动态代理"></a>9.3 动态代理</h3><p>动态代理标准格式：</p>
<p><img src="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/clip001.png"></p>
<p><strong>两个重要类：</strong></p>
<p>InvocationHandler：调用处理程序（invoke）并返回结果；</p>
<p>Proxy：提供了创建动态代理类和实例的静态方法，用于生成动态代理实例。</p>
<p>代理模式（动态代理）的好处:</p>
<ul>
<li>可以使真实角色的操作更加纯粹！不用去关注一些公共的业务；</li>
<li>公共业务就交给代理角色，实现了业务的分工；</li>
<li>公共业务发生扩展的时候，方便集中管理；</li>
<li>一个动态代理类代理的是一个接口，一般就是对应的一类业务；</li>
<li>一个动态代理类可以代理多个类，只要是实现了同一个接口即可。</li>
</ul>
<p>一个具体的例子：spring的AOP底层就是代理模式</p>
<ul>
<li>基于切面编程，如果我们为<code>Spring</code>的某个<code>bean</code>配置了切面，那么<code>Spring</code>在创建这个<code>bean</code>的时候，实际上创建的是这个<code>bean</code>的一个代理对象，我们后续对<code>bean</code>中方法的调用，实际上调用的是代理类重写的代理方法。</li>
<li>将一些具体的业务交给底层去做，而将公共的业务交给代理，实现一个切面，在其中增加功能。</li>
</ul>
<h2 id="10-模板方法模式"><a href="#10-模板方法模式" class="headerlink" title="10. 模板方法模式"></a>10. 模板方法模式</h2><p>行为型模式：适应行为的变化 ，强调父类调用子类的特性，用来<strong>识别类和对象之间的常用交流</strong>模式并加以实现。</p>
<p>模板方法模式：</p>
<ul>
<li>是类的行为模式；</li>
<li>准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后<strong>声明一些抽象方法来迫使子类实现剩余的逻辑</strong>。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意；</li>
<li>比如定义一个操作中的算法的骨架，将步骤延迟到子类中。模板方法使得子类能够不去改变一个算法的结构即可重定义算法的某些特定步骤；</li>
<li>核心：定义一个抽象类，在其中定义一个模板方法，在模板方法中加入一些抽象方法，让子类去继承并实现功能。</li>
</ul>
<p>模式中的角色：</p>
<ul>
<li>AbstractClass 抽象类实现了模板方法（template），定义了算法的骨架，具体子类需要去实现其它的抽象方法ConcreteClass；</li>
<li>实现抽象方法 ，以完成模板算法中特定的步骤。</li>
</ul>
<p>类图：</p>
<p><img src="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230227102018399.png"></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CodeAbstractClass</span> &#123;</span><br><span class="line">	<span class="comment">//定义的一个模板</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">template</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (callback()) method();</span><br><span class="line">		<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;当前方法执行时长：&quot;</span> + (end - start));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//子类必须重写的抽象方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">callback</span><span class="params">()</span>&#123; <span class="comment">//钩子函数，子类可以重写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClassA</span> <span class="keyword">extends</span> <span class="title class_">CodeAbstractClass</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;模拟耗时操作...&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(<span class="string">&quot;检测ConcreteClassA.method方法运行的时长======&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClassB</span> <span class="keyword">extends</span> <span class="title class_">CodeAbstractClass</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;模拟耗时操作...&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(<span class="string">&quot;ConcreteClassB.method方法运行的时长======&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//检测ConcreteClassA.method方法运行的时长======当前方法执行时长：</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">ConcreteClassA</span>().template();        </span><br><span class="line">		<span class="comment">//ConcreteClassB.method方法运行的时长======当前方法执行时长：       </span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">ConcreteClassB</span>().template();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意事项和细节：</p>
<ul>
<li><p>钩子函数在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子”；</p>
</li>
<li><p><strong>算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法</strong>或者已经实现的某些步骤，子类就会继承这些修改；</p>
</li>
<li><p>一般模板方法都加上 final 关键字， 防止子类重写模板方法。</p>
</li>
</ul>
<p>一个具体的例子：Spring中几乎所有的扩展都是用了模板方法模式，以SpringIOC为例简单说明一下。</p>
<ul>
<li>首先定义一个<strong>接口ConfigurableApplicationContext</strong>，声明<strong>模板方法refresh</strong>；</li>
<li><strong>抽象类AbstractApplicationContext</strong>实现了接口，实现了模板方法refresh（这个方法很重要，是各种IOC容器初始化的入口）的逻辑；</li>
<li><strong>AbstractRefreshableApplicationContext继承了AbstractApplicationContext</strong>，并获取BeanFactory容器；</li>
<li>客户访问时，直接调用ConfigurableApplicationContext，就可以实现BeanFactory容器的获取，之后在调用getBean来获取bean。</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>设计模式</p><p><a href="http://example.com/2023/02/27/设计模式/">http://example.com/2023/02/27/设计模式/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Zehao Tian</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-02-27</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-02-27</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/02/27/JVM/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">JVM</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/02/24/java%E6%96%B9%E6%B3%95/"><span class="level-item">java方法</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/jetpacktocat.png" alt="田泽豪"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">田泽豪</p><p class="is-size-6 is-block">越努力，越幸运</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>HUST</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">53</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">20</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zehtian" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-设计模式概述"><span class="level-left"><span class="level-item">1</span><span class="level-item">1. 设计模式概述</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-23种设计模式"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">1.1 23种设计模式</span></span></a></li><li><a class="level is-mobile" href="#1-2-OOP七大原则"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">1.2 OOP七大原则</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-单例模式"><span class="level-left"><span class="level-item">2</span><span class="level-item">2. 单例模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-饿汉式"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">2.1 饿汉式</span></span></a></li><li><a class="level is-mobile" href="#2-2-DCL-懒汉式"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">2.2 DCL 懒汉式</span></span></a></li><li><a class="level is-mobile" href="#2-3-静态内部类"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">2.3 静态内部类</span></span></a></li><li><a class="level is-mobile" href="#2-4-枚举"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">2.4 枚举</span></span></a></li><li><a class="level is-mobile" href="#2-5-单例模式总结"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">2.5 单例模式总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-工厂模式"><span class="level-left"><span class="level-item">3</span><span class="level-item">3. 工厂模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-简单工厂模式"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">3.1 简单工厂模式</span></span></a></li><li><a class="level is-mobile" href="#3-2-工厂方法模式"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">3.2 工厂方法模式</span></span></a></li><li><a class="level is-mobile" href="#3-3-两种方式的比较"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">3.3 两种方式的比较</span></span></a></li><li><a class="level is-mobile" href="#3-4-工厂模式总结"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">3.4 工厂模式总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-抽象工厂模式"><span class="level-left"><span class="level-item">4</span><span class="level-item">4. 抽象工厂模式</span></span></a></li><li><a class="level is-mobile" href="#5-建造者模式"><span class="level-left"><span class="level-item">5</span><span class="level-item">5. 建造者模式</span></span></a></li><li><a class="level is-mobile" href="#6-原型模式"><span class="level-left"><span class="level-item">6</span><span class="level-item">6. 原型模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#6-1-原型模式"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">6.1 原型模式</span></span></a></li><li><a class="level is-mobile" href="#6-2-创造型模式总结"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">6.2 创造型模式总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#7-适配器模式"><span class="level-left"><span class="level-item">7</span><span class="level-item">7. 适配器模式</span></span></a></li><li><a class="level is-mobile" href="#8-桥接模式"><span class="level-left"><span class="level-item">8</span><span class="level-item">8. 桥接模式</span></span></a></li><li><a class="level is-mobile" href="#9-代理模式"><span class="level-left"><span class="level-item">9</span><span class="level-item">9. 代理模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#9-1-代理模式原理"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">9.1 代理模式原理</span></span></a></li><li><a class="level is-mobile" href="#9-2-静态代理"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">9.2 静态代理</span></span></a></li><li><a class="level is-mobile" href="#9-3-动态代理"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">9.3 动态代理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#10-模板方法模式"><span class="level-left"><span class="level-item">10</span><span class="level-item">10. 模板方法模式</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/MyBatis/"><span class="level-start"><span class="level-item">MyBatis</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringBoot/"><span class="level-start"><span class="level-item">SpringBoot</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringCloud/"><span class="level-start"><span class="level-item">SpringCloud</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringMVC/"><span class="level-start"><span class="level-item">SpringMVC</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/web%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">web基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">编程基础</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"><span class="level-start"><span class="level-item">论文写作</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">论文阅读笔记</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-01T12:57:45.000Z">2023-03-01</time></p><p class="title"><a href="/2023/03/01/java%E5%85%AB%E8%82%A1/">java八股</a></p><p class="categories"><a href="/categories/java/">java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-27T12:42:01.000Z">2023-02-27</time></p><p class="title"><a href="/2023/02/27/JVM/">JVM</a></p><p class="categories"><a href="/categories/java/">java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-27T12:41:49.000Z">2023-02-27</time></p><p class="title"><a href="/2023/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p><p class="categories"><a href="/categories/java/">java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-24T13:17:51.000Z">2023-02-24</time></p><p class="title"><a href="/2023/02/24/java%E6%96%B9%E6%B3%95/">java方法</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-24T13:17:21.000Z">2023-02-24</time></p><p class="title"><a href="/2023/02/24/%E7%AE%97%E6%B3%95/">算法</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">一月 2023</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">十二月 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JDBC/"><span class="tag">JDBC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MyBatis/"><span class="tag">MyBatis</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringBoot/"><span class="tag">SpringBoot</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringCloud/"><span class="tag">SpringCloud</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringMVC/"><span class="tag">SpringMVC</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html/"><span class="tag">html</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jvm/"><span class="tag">jvm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%83%E5%AD%A6%E4%B9%A0/"><span class="tag">元学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%88%90%E5%91%98%E6%8E%A8%E6%96%AD%E6%94%BB%E5%87%BB/"><span class="tag">成员推断攻击</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="tag">数据结构与算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"><span class="tag">机器学习基础</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">联邦学习</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"><span class="tag">论文写作</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><span class="tag">论文阅读笔记</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Blackpride</a><p class="is-size-7"><span>&copy; 2023 Zehao Tian</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>