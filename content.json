{"posts":[{"title":"java基础（一）","text":"本系列主要进行java语言的介绍，其中本篇文章介绍java的基本语法，包括java的数据类型，变量，运算符，语句，数组等。 java语言的特点：面向对象，健壮性，跨平台性 java语言三大特性：封装，继承，多态 java数据类型 类型 存储空间 数据范围 byte 1字节=8bit位 -128~127 short 2字节 -2^15~2^15-1 int 4字节 -2^31~2^31-1 long 8字节 float 4字节 double 8字节 char 2字节 Java 的整型常量默认为 int 型，声明 long 型变量，必须以 ‘l’ 或 ‘L’ 结尾。long a=124548784L Java 的浮点型常量默认为 double 型，声明 float 型常量，变量要以 ‘f’ 或 ‘F’ 结尾。通常定义浮点变量时，使用 double。 char 型数据用来表示通常意义上“字符”。Java 中的所有字符都使用 Unicode 编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。 字符串类型String：String不是基本数据类型，属于引用数据类型。使用方式与基本数据类型一致。如： String str = “abcd”; String s2 = “a”; String s3 = “”。 String可以和8种基本数据类型变量做运算，且运算只能是连接运算 ‘+’ 。运算结果还是String类型。 判断+是加法还是连接：+前后两个要运算的有一个是字符串就是连接，没有就是加法。如： char c = ‘a’; //a:97 A:65 int number = 10; String str = “hello”; System.out.printIn(c + num + str); //107hello java的变量语法（声明并赋值，二者可分开）： &lt;数据类型&gt; &lt;变量名&gt; = &lt;初始化值&gt; 如：int var = 10; 变量的作用：用于在内存中保存数据 使用变量注意： Java中每个变量必须先声明(定义且赋值)，后使用 使用变量名来访问这块区域的数据 变量的作用域：其定义所在的一对{ }内 变量只有在其作用域内才有效 同一个作用域内，不能定义重名的变量 java运算符算数运算符： b=++a：先运算后取值；b=a++：先取值后运算 /：除法：整数之间做除法时，只保留整数部分而舍弃小数部分。如：12/5=2 (double)12/5=2.4 %：取模：对负数取模，可以把模数负号忽略不记， 与被模数符号相同。如：12%5=2; (-12)%5=-2; (-12)%(-5)=-2 赋值运算符： 符号：=；当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理。支持连续赋值。 扩展赋值运算符：+=, -=,*=, /=, %=。两者区别：扩展赋值运算符不会改变本身变量的数据类型，如: short s=10; s=s+10; //编译失败，但是s+=10编译成功 逻辑运算符：&amp;逻辑与 &amp;&amp;短路与 |逻辑或 ||短路或 !逻辑非 ^逻辑异或 在Java中不可以写成3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6 。 位运算符：&amp; | ^ ~ &lt;&lt; &gt;&gt; 三元运算符：(条件表达式)?表达式1: 表达式2； 可嵌套 java循环语句while循环的语法如下： 先判断再循环 while(布尔表达式){ 循环体;} do-while循环的语法如下： 先循环再判断 do{ 循环体; }while(布尔表达式); for循环的语法结构： for(表达式1; 表达式2; 表达式3){ 循环体; } 其中：表达式1的作用是给循环变量初始化；表达式2的作用是给出循环条件；表达式3的作用是改变循环变量的值；循环体可以是一条或多条语句。 for循环的执行过程是：执行表达式1，计算表达式2，如果表达式2的值为true，执行循环体，执行表达式3，改变循环变量的值，再计算表达式2的值，如果是true，再进入循环体，形成循环，直到表达式2的值为false，结束循环，执行for后面的语句。 java数组一维数组的声明与创建： 元素类型[] 数组名 = new 元素类型[元素个数或数组长度]; –动态 元素类型[] 数组名 = new 元素类型[]{元素，元素，……}; –静态 元素类型[] 数组名 = {元素，元素，……}; –静态 示例： int[] arr = new int[5]; //此时初始值为0，初始化方式如: arr[0]=1 int[] arr = new int[]{3,5,1,7}; //创建并初始化 int[] arr = {3,5,1,7}; //创建并初始化 注意：1.给数组分配空间时，必须指定数组能够存储的元素个数来确定数组大小。创建数组之后不能修改数组的大小。可以使用length 属性获取数组的大小。 2.元素类型为String时，初始化的值为null 3.元素类型后面的[]可以放在数组名后面 4.若要复制数组arr1，需要new一个新数组arr2=new int[arr1.length]，而不能 直接arr2=arr1，直接相等会导致arr1和arr2是同一个地址，改变arr2也会改变arr1的值，而new一个新的arr说明arr1和arr2地址不同。 Arrays的使用： 遍 历： Arrays.toString(array) 将数组的元素以字符串的形式返回，如”[1, 2, 3]” 排序： Arrays.sort(array) 将数组按照升序排列 查找： binarySearch()在指定数组中查找指定元素，返回元素的索引，如果没有找到返回（-插入点-1） 注意：使用查找的功能的时候，数组一定要先排序 二维数组定义： 动态定义： 数组类型[][] 数组名 = new 数组类型[一维数组的个数][每一个一维数组中元素的个数]; 数组类型[][] 数组名 = new 数组类型[一维数组的个数][]; 此方法需要再定义一次一维数组，用于元素个数不确定的情况 或者直接进行静态定义 注意：1.二维数组不要求每个一维数组的元素个数相等","link":"/2023/01/11/java%E5%9F%BA%E7%A1%80%E4%B8%80/"},{"title":"html入门","text":"本篇文章讲解了html的入门知识。首先讲解了html的基本元素和格式，之后讲解了一个html文档的基本结构，其中具体介绍了head内容和body内容的拓展。 HTML元素：一个HTML元素包括： 基本格式： &lt;元素 属性&gt;内容&lt;/元素&gt; &lt;&gt;中可以添加属性，用引号进行表示，它们不会显示出来 &lt;!–我是注释–&gt;间可以添加注释 &lt;p&gt;&lt;/p&gt;：封装为段落。元素的属性有： · class 赋予名字(id)，这个名字此后可以被用来识别此元素的样式信息和其他信息 &lt;em&gt;&lt;/em&gt;：斜体 &lt;strong&gt;&lt;/strong&gt;：加粗 &lt;h&gt;&lt;/h&gt;：标题 有h1，h2… &lt;img&gt;：插入指定图片 · src 图片地址 &lt;a&gt;：是被包裹的内容成为一个链接。&lt;a&gt;元素的属性有： &lt;input&gt;：输入数据 · type 数据格式 · disabled 禁止输入 HTML文档：一个HTML文档由多个HTML元素构成。 1.&lt;!DOCTYPE html&gt;: 声明文档类型 2.&lt;html&gt;&lt;/html&gt;：根元素，包裹了整个界面 3.&lt;head&gt;&lt;/head&gt;: &lt;head&gt;元素. 这个元素是一个容器，它包含了所有你想包含在HTML页面中但不想在HTML页面中显示的内容。这些内容包括你想在搜索结果中出现的关键字和页面描述，CSS样式，字符集声明等等。 4.&lt;meta charset=”utf-8”&gt;: 这个元素设置文档使用utf-8字符集编码，utf-8字符集包含了人类大部分的文字。基本上他能识别你放上去的所有文本内容。毫无疑问要使用它，并且它能在以后避免很多其他问题。 5.&lt;title&gt;&lt;/title&gt;: 设置页面标题，出现在浏览器标签上，当你标记/收藏页面时它可用来描述页面。 6.&lt;body&gt;&lt;/body&gt;: &lt;body&gt;元素。 包含了你访问页面时所有显示在页面上的内容，文本，图片，音频，游戏等等。 Head内容拓展：1.添加作者和描述 2.其它类型源数据 3.添加自定义图标 4.在HTML中应用CSS和Javascript Body内容拓展：1.标题和段落： 2.列表： 每份无序的清单从&lt;ul&gt;元素开始——需要包裹清单上所有被列出的项目； 然后用 &lt;li&gt;元素把每个列出的项目单独包裹起来： 有序列表的结构和无序列表一样，除了需要用&lt;ol&gt;元素将所有项目包裹, 而不是&lt;ul&gt;。 3.斜体、粗体、下划线 其它：实体引用（转义字符）： 代码格式：通常每一个嵌套的元素以两个空格缩进。","link":"/2022/12/22/html%E5%85%A5%E9%97%A8/"},{"title":"java基础（三）","text":"本系列主要进行java语言的介绍，其中本篇文章介绍java的面向对象部分（下），包括多态性，Object类和包装类，代码块，抽象类(abstract)，接口(interface)等，此外介绍了关键字static的使用和异常的处理等。 java多态性多态性的理解：一个事物的多种形态 对象的多态性：父类的引用指向子类的对象 如：Person p1 = new Women() 举例：可将new Women()或者new Men()作为方法func(Person person)的person参数，即func(new Women())，并在func中实际调用Women或Men类重写的方法。 多态的使用：虚拟方法调用（原父类被重写的方法叫虚拟方法） 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。总结：编译，看左边；运行，看右边。 多态性的使用前提：1.类的继承关系 2.要有方法的重写 不然这样用就没有意义，不如直接调用父类的对象 注意：1. 对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边） ​ 2. 多态是运行时行为 向下转型：将父类的对象转换成子类对象，以使用子类独有的属性和方法（多态实际上是向上转型） 如 Woman p2 = (Woman)p1，这样p2就变成了Woman类的对象 instanceof的使用：a instanceof A 判断对象a是否是类A的实例，如果是，返回true，如果不是，返回false 使用情境：为了避免在向下转型时出现ClasscastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。如上述向下转型需判断 p1 instanceof Woman为true 如果a instanceof A返回true,则a instanceof B也返回true.其中,类B是类A的父类。 Object类和包装类运算符==的使用： 可以使用在基本数据类型变量和引用数据类型变量中 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等(不一定类型要相同) 如果比较的是引用数据类型变量，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体 方法equals()的使用： object类中equals()的定义: public booiean equals(object obj) { ​ return (this==obj); } 说明: equals()是一个方法，只能应用于引用数据类型 object类中定义的equals()和==的作用是相同的。比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体。 像String、 Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的实体内容是否相同。 方法toString()的使用： 当我们输出一个对象的引用时（ 即System.out.println() 时），实际上就是调用当前对象的toString()方法 object类中toString()的定义: public string toString(){ ​ return getclass().getName()+”@” + Integer.toHexString(hashcode()); } 像String、Date、File、包装类等都重写了object类中的toString()方法，使得在调用对象的toString()时,返回”实体内容”信息。 包装类：针对八种基本数据类型定义相应的引用类型——包装类（封装类）。 具体的，一般是将首字母的小写变大写，如byte-&gt;Byte，此外有一些特殊：int-&gt;Integer；char-&gt;Character 基本数据类型，包装类，String之间的相互转化： static关键字1.static:静态的 2.static可以用来修饰: 属性、方法、代码块、内部类 3.使用static修饰属性: 静态变量（或类变量) 3.1. 属性：按是否使用static修饰，又分为: 静态属性Vs 非静态属性(实例变量) 实例变量: 我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时,不会导致其他对象中同样的属性值的修改。 静态变量: 我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。 3.2. static修饰属性的其他说明: 静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用静态变量的加载要早于对象的创建。 由于类只会加载一次，则静态变量在内存中也只会存在一份:存在方法区的静态域中。 类可以调用其类变量，但不能调用实例变量；对象可以调用类变量，也可以调用实例变量 3.3. 静态属性举例：System.out Math.PI 4.使用static修饰方法：静态方法 随着类的加载而加载，可以通过”类.静态方法”的方式进行调用 静态方法中，只能调用静态的方法或属性；非静态方法中，既可以调用非静态的方法或属性,也可以调用静态的方法或属性 类可以调用其静态方法，但不能调用非静态方法；对象都可以调用 在静态的方法内,不能使用this关键字、super关键字 关于静态属性和静态方法的使用，可以从生命周期的角度去理解。静态的是随着类的创建就创建，随着类的消失而消失；非静态的是随着对象的创建而开始，对象的消失而终止。 5.1 开发中，如何确定一个属性是否要声明为static的? ​ 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。 5.2 开发中，如何确定一个方法是否要声明为static的? ​ 操作静态属性的方法，通常设置为static的； ​ 工具类中的方法，习惯上声明为static的 代码块格式： { ​ //代码块中内容 ​ } 1.代码块的作用:用来初始化类、对象 2.代码块如果有修饰的话，只能使用static 3.分类：静态代码块Vs非静态代码块 4.静态代码块 （加了static） 内部可以有输出语句 随着类的加线而执行,而且只执行一次 作用:初始化类的信息 静态代码块要优于非静态代码块执行 5.非静态代码块 内部可以有输出语句 随着对象的创建而执行，每创建一个对象，就执行一次非静态代码块 作用:可以在创建对象时，对对象的属性等进行初始化 final关键字的使用final：最终的 1.final可以用来修饰的结构：类、方法、变量 2.final用来修饰一个类：此类不能被其他类所继承。 比如：String类、System类、StringBuffer类 3.final用来修饰方法：表明此方法不可以被重写。 比如，Object类中getClass(); 4.final修饰变量，此时变量变常量，即不能改变 abstract关键字的使用1.abstract修饰类：抽象类 抽象类不能被实例化；抽象类中一定有构造器，便于子类实例化时调用；开发中，都会提供抽象类的子类，让子类对象实例化 2.abstract修饰方法：抽象方法 抽象方法中只有方法的声明，没有方法体；包含抽象方法的类一定是抽象类，而抽象类中可以没有抽象方法 若子类重写了父类中的所有抽象方法，则此子类可以被实例化；若子类没有重写父类的所有抽象方法，则该子类也是一个抽象类，需要用abstract修饰。 3.abstract不能用来修饰：属性、构造器等结构，不能修饰私有方法、静态方法、final修饰的方法和类 interface：接口的使用Java中，接口和类是并列的两个结构 如何定义接口：定义接口中的成员 JDK7及以前，只能定义全局常量和抽象方法 ​ &gt;全局常量：public static final的，但是书写时，可以省略不写 ​ &gt;抽象方法：public abstract的，但是书写时，可以省略不写 JDK8:除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略) 接口中不能定义构造器的！意味着接口不可以实例化 Java开发中，接口通过让类去实现(implements)的方式来使用。 如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类 JAVA类可以定义多个接口，class AA extends BB implements CC,DD,EE；接口课可以继承接口，甚至可以继承多个接口","link":"/2023/01/12/java%E5%9F%BA%E7%A1%80%E4%B8%89/"},{"title":"java基础（五）","text":"本系列主要进行java语言的介绍，其中本篇文章介绍java的高级特性——集合。java集合可分为Collection和Map两种体系。Collection接口：单列集合，存储一个一个的对象。其中包括List接口和Set接口；Map接口：双列集合，用来存储一对（key-value）一对的数据。 java集合可分为Collection和Map两种体系。 1.Collection接口：单列集合，存储一个一个的对象 ​ 1.1 List接口，存储有序的、可重复的数据； ​ 如：ArrrayList、LinkedList、Vector ​ 1.2 Set接口，存储无序的、不可重复的数据； ​ 如：HashSet、 LinkedHashSet、TreeSet 2.Map接口：双列集合，用来存储一对（key-value）一对的数据。 ​ 如：HashMap、LinkedHashMap、TreeMap Collection接口Collection接口中的常用方法新建一个Collection接口对象。如：Collection coll1 = new ArrayList() add(Object e)：将元素e添加到集合中； addAll(Collection coll)：将集合coll中的元素添加到该集合中； size()：获取添加元素的个数； clear()：清空集合元素； isEmpty()：判断当前集合是否为空； contains(Object e)：判断集合中是否存在元素e；–containsAll同理 remove(Object e)：删除一个元素e，并返回是否删除成功；–removeAll同理 retrainAll(Collection coll)：求集合交集，并将结果返回在原集合中； equals(Object e)：返回与e是否相等，要想返回true，e首先得是Collection； toArray(Collection coll)：集合转化为数组。 注意：向Collection接口的实现类的对象中添加数据obj时，要求obj所在类重写equals()。 集合Collection的遍历使用Iterator迭代器遍历集合Collection[主要是List]：使用hasNext()和next() 例子： 1234Collection coll = new ArrayList();Iterator iter = coll.interator();while(iter.hasNext()): System.out.println(iter.next()); //打印当前集合中的对应元素 注意：1. 可以想象有一个指针，iter最先指向空，hasNext()判断下一个元素有没有值，如果有，则使用next()先将指针移动到下一个元素，然后返回指向元素的值。 Iterator仅用于遍历集合，本身没有承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合； 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认指针都在第一个元素之前（即空）； iter.remove()：可以在遍历的时候，对集合的元素进行移除操作。 foreach遍历集合和数组：（jdk5.0新增） 格式：for(集合中元素类型 局部变量 : 集合对象){ … } 如：for(Object obj : coll){ ​ System.out.println(obj); //其实obj内部调用的还是迭代器 ​ } List接口List接口：存储有序的、可重复的数组–&gt;”动态”数组，可替换原有数组 ArrayList：List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储； LinkedList：底层使用双向链表存储；对于频繁的插入和删除操作，此类效率更高； Vector：List接口的远古实现类；线程安全的，效率低；底层使用Object[] elementData存储 ArrayList类ArrayList源码分析： 1.jdk 7情况下： ArrayList list = new ArrayList(); //底层创建了长度是10的object[]数组elementData list.add(123); //elementData[e] = new Integer(123); … list.add(11); //如果此次的添加导致底层elementData数组容量不够，则扩容。 默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。 结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity) 2.jdk 8中ArrayList的变化: ArrayList list = new ArrayList(); //底层object[] elementData初始化为{}，并没有创建长度为10的数组 list.add(123); //第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData中 后续的添加和扩容操作与jdk 7无异。 3.小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式,延迟了数组的创建，节省内存。 LinkedList类LinkedList源码分析： LinkedList list = new LinkedList(); // 内部声明了Node类型的first和last属性，默认值null list.add(123);//将123封装到Node中，创建了Node对象。 其中，Node的定义体现了LinkedList的双向链表的说法： 123456789private static class Node&lt;E&gt; { E item; Node&lt;E&gt;next; Node&lt;E&gt;prev; Node(Node&lt;E&gt; prev, E eLement, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev;}} List接口中常用方法： Set接口Set接口：存储无序的、不可重复的数组–&gt;高中讲的”集合” HashSet：Set接口的主要实现类；线程不安全的；可以存储null值； LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历；在添加数据的同时，每个数据还维护了两个引用，记录此数据的前一个数据和后一个数据；（类似于添加了链表的功能） TreeSet：可以按照添加对象的指定属性，进行排序。 Set接口没有单独定义方法，均是Collection中定义过的方法； 向Set中添加的数据，其所在的类一定要重写hashCode()和equals()方法； hashCode()和equals()还需要保持一致性。 以HashSet为例说明: 无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值进行添加； 不可重复性：保证添加的元素按照equals()判断时，不能返回true。即：相同的元素只能添加一个。 添加元素的过程：（以HashSet为例说明） 我们向HashSet中添加元素a，首先调用元素a所在类的hashcode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数据中的存放位置（即为索引位置），判断数组此位置上是否有元素： ​ 如果此位置上没有其他元素，则a添加成功； —&gt; 情况一 ​ 如果此位置上有其它元素b（或以链表形式存在的多个元素），则比较元素a与元素b的hash值： ​ 如果hash值不同，则元素a添加成功； —&gt;情况二 ​ 如果hash值相同，进而需要调用元素a所在类的equals()方法： ​ equals() 返回true，元素a添加失败； ​ equals() 返回false，元素a添加成功。 —&gt;情况三 对于添加成功的情况二和情况三而言，元素a与已经存在指定索引位置上的数据以链表的方式存储。 Jdk7：元素a放到数组中，指向原来的元素 Jdk8：原来的元素在数组中，指向元素a HashSet底层：数组+链表 TreeSet：可以按照添加对象的指定属性，进行排序 向TreeSet中添加数据，需要保证是相同类的对象； 两种排序方式：自然排序（实现comparable接口）和定制排序（Comparator类）； 自然排序时，比较两个对象相同的标准为：compareTo()返回0，而不是equals()； 定制排序时，比较两个对象相同的标准为：compare()返回0，而不是equals() Map接口Map接口：双列数据，用来存储一对（key-value）一对的数据。 HashMap：作为Map的主要实现类；线程不安全的，效率高；可以存储null的key和value；LinkedHashMap：保证遍历map元素时，可以按照添加的顺序实现遍历；在原有的HashMap底层结构的基础上，添加了一对指针，指向前一个和后一个元素；对于频繁的遍历操作，执行效率要高于HashMap；底层使用红黑树； TreeMap：可以按照添加的key-value对进行排序，实现排序遍历，此时考虑key的自然排序或定制排序； Hashtable：Map的古老实现类；线程安全的，效率低；不可以存储null的key和value； Properties：常用来处理配置文件，key和value都为String类型。 Map结构的理解： key是无序的、不可重复的，使用Set存储所有的key； —&gt;key所在的类要重写equals()和hashCode() value是无序的、可重复的，使用Collection存储所有的value； —&gt;value所在的类要重写equals() 一个键值对：key-value构成了一个Entry对象，使用Set存储所有的Entry HashMap类HashMap的底层结构：数组+链表（jdk7之前） 数组+链表+红黑树（jdk8之后） HashMap原理：jdk7 HashMap map = new HashMap()： 在实例化以后，底层了创建了一个长度是16的一维数组Entry[] table …可能执行了多个put… map.put(key1, value1)： 首先调用key1所在类的hashcode()计算key1的哈希值，此哈希值接着通过某种算法计算以后，得到在Entry数组中的存放位置。判断数组此位置上是否有元素： ​ 如果此位置上的数据为空，则key1-value1添加成功； —&gt; 情况一 ​ 如果此位置上的数据不为空（意味着存在一个或多个数据（以链表形式存在）），则比较key1与已经存在元素的hash值： ​ 如果hash值都不同，则key1-value1添加成功； —&gt;情况二 ​ 如果key1的hash值与已经存在的某一个元素key2-value2相同，则比较equals()方法： ​ equals() 返回true，使用value1替换value2； ​ equals() 返回false，元素a添加成功。 —&gt;情况三 对于添加成功的情况二和情况三，此时key1-value1与已经存在指定索引位置上的数据以链表的方式存储。 在不断的添加过程中，会存在扩容问题，默认的扩容方式：扩容为原来的两倍，并将数据复制。 HashMap原理：jdk8 jdk8相较于jdk7在底层实现方面的不同: new HashMap()：底层没有创建一个长度为16的数组； jdk 8底层的数组是：Node[]，而非Entry[]； 首次调用put()方法时，底层创建长度为16的数组； jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树； 当数组的某一个索引上的元素以链表形式存在的个数&gt;8，且当前数组的长度&gt;64时，此时此索引位置上的数据改为红黑树存储。 Map的常用方法 遍历所有的key集：keySet Map map = new HashMap(); …..多次put…. Set set = map.keySet(); Iterator iter = set.iterator(); while(iter.hasNext()): System.out.println(iter.next());} 遍历所有的value集：values() Collection values = map.values(); for(Object obj : values): System.out.println(obj);} Collections工具类Collections工具类：可以操作Collection和Map的工具类 使用方法：如 List list = new Arraylist(); ​ ….多次add….. ​ Collections.reverse(list);","link":"/2023/01/14/java%E5%9F%BA%E7%A1%80%E4%BA%94/"},{"title":"java基础（二）","text":"本系列主要进行java语言的介绍，其中本篇文章介绍java的面向对象部分（上），包括类和对象的介绍，封装性、继承性的体现等，此外介绍了关键字this、package、import、super的使用。 java类和对象类是抽象的一类事物，对象是具体的一个实例。 类的定义： class Person{ ​ //属性 String name; int age = 10; //方法 public void speak(String language) { system.out.println(‘说的语言是:’, language) }} 类的实例化: Person zhangsan = new Person() 调用属性和方法：zhangsan.name; zhangsan.speak(‘Chinese’) 方法的声明：权限修饰符 返回值类型 方法名(形参列表) { ​ 方法体 ​ } 四种权限修饰符：private、public、缺省、protected 返回值类型： 若没有返回值 则为void，在方法中不写return或就写一个return; 若有返回值 则需要在声明时写返回值的类型，并在方法中写 return+返回值 关于变量的赋值： 如果变量是基本数据类型，则此时赋值的是变量所保存的数据 如果变量是引用数据类型，则此时赋值的是变量所保存数据的地址值 方法形参的传递机制：值传递 形参：方法定义时，声明的小括号的参数 实参：方法调用时，实际传递给形参的数据 值传递机制： 如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值 如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值 构造器（构造方法，constructor）：任何类中都有，用于1.创建对象 2.属性初始化 使用位置：Person zhangsan = new Person() 其中Person()就是构造器 如果没有显式的定义类的构造器的话，则系统默认提供一个空的构造器 构造器的表示为 类名()，可以理解为名称与类名相同的方法，类似于python的__init__ 一个类中可以定义多个构造器，彼此构成重载 一旦定义了显式构造器，则系统不再提供空的构造器 属性赋值的先后顺序：默认初始化(系统默认值)-显式初始化(类中定义时手动的赋值)/代码块中赋值(取决于先后顺序)-构造器中赋值-通过’对象.属性’或’对象.方法’赋值 java类的封装性封装性的设计思想：隐藏对象内部的复杂性，只对外公开简单的接口，便于外界调用，从而提升系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露起来。 封装性的体现：我们将类的属性xxx私有化(private)，同时提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值。 这只是一个体现，还有很多体现，如设置不对外暴露的私有化方法，只在类中可见；单例模式，即构造器的私有化等。 封装性的体现，需要权限修饰符的配合。从小到大排列：private、缺省、protected、public 修饰符 类内部 同一个包 不同包的子类 同一个工程 private Yes default(缺省) Yes Yes protected Yes Yes Yes public Yes Yes Yes Yes 注：1. 对于类的权限修饰只能是public和缺省。其中public可以在任意地方被访问，缺省类只可以被同一个包的内部访问。 ​ 2. 四种权限都可以用来修饰类的内部结构：属性，方法，构造器，内部类 this的使用： this可以用来修饰、调用：属性、方法、构造器 this修饰属性和方法：this理解为：当前对象 ​ 2.1. 在类的方法中，我们可以使用’this.属性’或’this.方法’的方式，调用当前对象的属性或方法，但是，通常情况下，我们都选择省略’this.’。特殊情况下，如果方法的形参与类的属性同名时，我们必须显示的使用’this.变量’的方式，表明此变量是属性，而不是形参。 ​ 2.2. 在类的构造器中，我们可以使用’this.属性’或’this.方法’的方式，调用当前正在创建的对象属性或方法，但是，通常情况下，我们都选择省略’this.’。特殊情况下，如果构造器的形参与类的属性同名时，我们必须显示的使用’this.变量’的方式，表明此变量是属性，而不是形参。 this调用构造器 ​ 3.1 我们在类的构造器中，可以显示的使用’this(形参列表)’方式，调用本类中指定的其它构造器 ​ 3.2 构造器不能通过’this(形参列表)’自己调用自己；如果类中有n个构造器，最多有n-1个构造器使用’this(形参列表)’调用其它构造器 ​ 3.3 规定’this(形参列表)’必须声明在当前构造器的首行，构造器内部最多只能声明一个’this(形参列表)’来调用其他的构造器 package: 包 便于实现项目中类的管理 同一个包下，不能命名同名的类、接口 不同的包下，可以命名同名的类、接口 import: 导入 1．在源文件中显式的使用import结构导入指定包下的类、接口 2．声明在包的声明和类的声明之间 3．如果需要导入多个结构,则并列写出即可 4．可以使用”XXX.*”的方式,表示可以导入XXX包下的所有结构 5．如果使用的类或接口是java.lang包下定义的，则可以省略import结构 6．如果使用的类或接口是本包下定义的，则可以省略import结构 7．如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。 8．使用”xxx.*”方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入: 9．import static:导入指定类或接口中的静态结构。 java类的继承性继承性的好处： 减少了代码的冗余，提高了代码的复用性 便于功能的扩展 为之后的多态性的使用，提供了前提 继承性的格式： class A extends B{} A：子类、派生类、subclass B：父类、超类、基类、superclass 一旦子类A继承了父类B，子类A中就获取了父类B中的声明的所有属性和方法。 特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。只有因为封装性的影响,使得子类不能直接调用父类的结构而已。 子类继承了父类后，还可以声明自己的属性或方法，实现功能的拓展。 注意： 子父类是相对的概念；子类直接继承的父类，称为:直接父类。间接继承的父类称为:间接父类 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法 如果没有显式声明父类的话，则此类继承于java.lang.Object类 方法的重写： 在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型3.子类重写的方法使用的访间权限不能小于父类被重写的方法的访问权限 子类不能重写父类中声明为private权限的方法 子类方法抛出的异常不能大于父类被重写方法的异常注意: 注意：子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写)。因为static方法是属于类的，子类无法覆盖父类的方法。 super的使用： 对于this，是先在自己类中找属性或方法，如果没找到，然后再去对应父类找 对于super，则是直接在父类中找，如果直接父类没有，再继续往上找 （this就是理解为自己类，super理解为父类） super调用属性或方法： 1．我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。但是,通常情况下,我们习惯省略”super. “ 2．特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。 3．特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式,表明调用的是父类中被重写的方法。 super调用构造器 1． 我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器 2．”super(形参列表)”的使用,必须声明在子类构造器的首行! 3．我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现 4．在构造器的首行，没有显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器 5．在类的多个构造器中，至少有一个构造器使用了”super(形参列表)”(显式或隐式)，调用父类的构造器 子类对象实例化的全过程 1．从结果上来看:（继承化） 子类继承父类以后，就获取了父类中声明的属性或方法。 创建子类的对象,在堆空间中,就会加载所有父类中声明的属性。 2．从过程上来看: 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器.直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构,子类对象才可以考虑进行调用。 明确：虽然创建子类对象时调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。","link":"/2023/01/12/java%E5%9F%BA%E7%A1%80%E4%BA%8C/"},{"title":"java基础（六）","text":"本系列主要进行java语言的介绍，其中本篇文章介绍java的高级特性——泛型和IO流。在IO流中，会介绍File类、文件流和处理流（缓冲流、转换流、对象流等）的使用。 java泛型在集合中使用泛型： 集合接口或集合类在jdk5.0时都修改为带泛型的结构。在实例化集合类时，可以指明具体的泛型类型； 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化时的反向类型； 比如: add(E e) —&gt;实例化以后: add(Integer e) 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿对应的包装类作为泛型的类型； 如果实例化时，没有指明泛型的类型。默认类型为java.lang.object类型。 IO流File类File类的使用 File类的一个对象，代表一个文件或一个文件目录（文件夹）； 来自于java.io包下； 实例化方法1：File file1 = new File(“hello.txt”); //相对路径，相对于当前module 实例化方法2：File file2 = new File(“D:\\study\\java\\hello.txt”); //绝对路径 实例化方法3：File file3 = new File(“study”, “java”); //父路径+子路径 实例化方法4：File file4 = new File(file3, “hello.txt”); //之前的file路径+新增路径 File类中只涉及到关于文件和文件目录的创建、删除、重命名等方法，并未设计到写入或读取文件内容的操作。如果需要写入或读取内容，必须使用IO流实现； 后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点”。 File的创建和删除123456789101112131415//创建和删除文件File file1 = new File(&quot;hello.txt&quot;);//如果file1在硬盘中不存在，则创建file1if(!file1.exists()){ file1.createNewFile();}else{ //文件存在，就删除文件 file1.delete() }//创建文件目录File file2 = new File(&quot;D:\\\\io\\\\io1&quot;);Boolean mkdir1 = file2.mkdir(); //只创建当前目录，前提是其父目录一定存在，否则返回false创建失败Boolean mkdir2 = file2.mkdirs(); //会创建上层没有的目录，不管父目录是否存在都会创建成功if(mkdir1): System.out.println(&quot;创建成功&quot;) 文件流IO流原理和分类： IO是Input/Output的缩写，用于处理设备之间的数据传输，如读/写文件，网络通讯等； java程序中，对于数据的输入/输出操作以“流stream”的方式进行； IO流的相关类和接口来自于java.io包中，通过标准的方法输入和输出数据； 我们是站在内存（即程序）的角度理解输入（读取外部数据到内存）和输出（将程序的数据输出到外部）； 按操作数据单位分为字节流（8 bit）和字符流（16 bit）；按流向分为输入流和输出流；按流的角色分为节点流和处理流。 基础类有：字节输入流InputStream，字节输出流OutputStream；字符输入流Reader，字符输出流Writer。这些都是抽象类，派生的子类才能被实例化，对应的子类的名称都是以其父类名称作为后缀。 文件内容的读入：FileReader例子：将hello.txt内容读入到程序中，并输出 read()的理解：返回读入的第一个字符，如果达到文件末尾，则返回-1； 异常的处理：为保证流资源一定可以执行关闭操作，需要使用try-catch-finally处理异常; 读入的文件一定要存在，否则会报异常。 1234567891011121314151617181920212223242526272829303132333435363738FileReader fr = null;try{//1.实例化File对象，指明需要操作的文件File file = new File(&quot;hello.txt&quot;); //2.提供具体的流fr = new FileReader(file); //3.读入操作//3.1 方法一：一次读一个//int data;//while(data = fr.read() != -1):{//System.out.print((char)data);//}//3.2 方法二：一次读指定个char[] cbuf = new char[5]; // 一次五个int len;while((len = fr.read(cbuf)) != -1){ //3.2.1用for循环读 for(int i = 0; i &lt; len; i++){ System.out.print(char[i]); } //3.2.2 还可以用String读取char[]内容 String str = new String(cbuf, 0, len); System.out.print(str); }} catch (IOException e){ e.printStackTrace();} finally{//4.流的关闭if(fr != null){ try{ fr.close();} catch (IOException e){ e.printStackTrace(); } }} 从内存中写出数据到硬盘的文件里：FileWriter例子：将hello.txt内容读入到程序中，并写入到hello1.txt中。 输出操作时，对应的File可以不存在。如果不存在，会自动创建文件；如果存在，调整构造器FileWriter(file, true/false)，决定是否向原文件中追加内容，即false为覆盖原文件； FileInputStream和FileOutputStream实现原理与FileReader和FileWriter同理； 字符流不能处理图片这种字节数据；字节流处理文本文件有时候会出现乱码。因此，通常，对于文本文件（.txt, .java, .c, …），使用字符流处理，对于非文本文件（.jpg, .mp3, .avi, .doc, …），使用字节流处理； 12345678910111213141516171819202122232425262728293031323334//由于会有异常，finally中一定会运行，因此需要先定义FileReader和FileWriter的对象FileReader fr = null;FileWriter fw = nulltry{//1.实例化File对象，指明读入和写出到的文件File srcfile = new File(&quot;hello.txt&quot;);File destfile = new File(&quot;hello1.txt&quot;);//2.提供具体的流fr = new FileReader(file) ;fw = new FileWriter(file) ;//3.读入和写出操作char[] cbuf = new char[5]; // 一次五个int len;while((len = fr.read(cbuf)) != -1){ //每次写多个字符 fw.write(cbuf, 0, len) }}catch (IOException e){ e.printStackTrace();} finally{//4.流的关闭if(fr != null){try{ fr.close();} catch (IOException e){ e.printStackTrace();}}if(fw != null){try{ fw.close();} catch (IOException e){ e.printStackTrace();}}} 处理流之一：缓冲流处理流均为 在节点流之外包裹的一个流，用于对节点流进行优化操作。 缓冲流的作用：提高流的读取、写入的速度。 主要包括：BufferedInputStream; BufferedOutputStream; BufferedReader; BufferedWriter 任务：添加缓冲层后实现非文本文件的复制 1234567891011121314151617181920212223242526272829303132333435363738394041424344BufferedInputStream bis = null;BufferedOutputStream bos = null;try{//1.实例化File对象，指明读入和写出到的文件File srcfile = new File(&quot;爱情与友情.jpg&quot;);File destfile = new File(&quot;爱情与友情1.txt&quot;);//2.提供具体的流//2.1 造节点流（文件流）FileInputStream fis = new FileInputStream(srcfile);FileOutputStream fos = new FileOutputStream(destfile);//2.2 造缓冲流bis = new BufferedInputStream(fis) ;bos = new BufferedOutputStream(fos) ;//3.读入和写出操作byte[] buffer = new byte[5]; // 一次五个int len;while((len = bis.read(buffer)) != -1){//每次写多个字符bis.write(buffer, 0, len);}}catch (IOException e){ e.printStackTrace();} finally{//4.流的关闭 关闭缓冲流即可，因为会自动关闭内层的文件流if(bis != null){try{ bis.close();} catch (IOException e){ e.printStackTrace();}}if(bos != null){try{ bos.close();} catch (IOException e){ e.printStackTrace();}}}//注意：对于BufferedReader，有一个新的方法：readLine，用于读取数据，就不用定义char[]数组了。//使用方法：String data;while(data = br.readLine() != null){ //每次写一行文本 bw.write(data); // data中不包含换行符 bw.newLine(); //新建一行} 处理流之二：转换流转换流：属于字符流。包含： InputStreamReader：将一个字节的输入流转换为字符的输入流； OutputStreamWriter ：将一个字符的输出流转换为字节的输出流 作用：提供字符流和字节流之间的转换。 解码：字节、字节数组 –&gt; 字符数组、字符串； 编码：字符数组、字符串 –&gt; 字节、字节数组。 例子： 解决任务：如将UTF-8格式的txt文件复制，并转换为jbc格式的新的txt文件输出。（将字节转换成字符流的方式，读取和写入txt文件，最终又以字节流保存）（因为之前提到过，字节流读取文本数据会出现乱码） 解决方法：1.实例化File；2.造节点流（字符节点流）；3.造转换流：读为InputStreamReader，写为OutputStreamWriter；4.关闭流，关闭外层即可。 处理流之三：对象流对象流用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把java中的对象写入到数据源中，也能把对象从数据源中还原出来。 主要包括的类有：ObjectInputStream和ObjectOutputStream 序列化：用ObjectOutputStream类保存基本类型数据或对象的机制； 反序列化：用ObjectInputStream类读取基本类型数据或对象的机制； ObjectInputStream和ObjectOutputStream不能序列化static和transient修饰的成员变量。 对象的序列化： 对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象； 序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原； 序列化是RMI (Remote Method Invoke-远程方法调用）过程的参数和返回值都必须实现的机制，而RM是JavaEE的基础。因此序列化机制是JavaEE平台的基础； 如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一（Serializable，Externalizable）。否则，会抛出NotSerializableException异常。","link":"/2023/01/14/java%E5%9F%BA%E7%A1%80%E5%85%AD/"},{"title":"java基础（四）","text":"本系列主要进行java语言的介绍，其中本篇文章介绍java的高级特性（上），包括java多线程，java常用类，枚举类与注解等，java的常用类中主要介绍String类。 java多线程创建多线程方式一：继承于Thread类 创建一个继承于Thread类的子类； 重写Thread类的run() –&gt;将此线程执行的操作声明在run()中； 创建Thread类的子类的对象；（可创建多个） 通过此对象调用start()：①启动当前线程；②调用当前线程的run()方法 则start后面的程序为主线程，run中运行的程序为子线程，二者同时运行。 Thread中的常用方法: start()：启动当前线程；调用当前线程的run()； run()：通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法； currentThread()：静态方法，返回执行当前代码的线程； getName()：获取当前线程的名字； setName()：设置当前线程的名字； yield()：释放当前cpu的执行权； join()：在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态； stop()：已过时。当执行此方法时，强制结束当前线程； sleep(long millitime)：让当前线程”睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态； isALive()：判断当前线程是否存活。 getPriority()：获取线程的优先级 setPriority()：设置线程的优先级 注意：高优先级的线程会抢占低优先级的线程的cpu，但不是高优先级的线程先执行，再执行低优先级的线程；而只是一个概率问题。 方式二：实现Runnable接口 创建一个实现了Runnable接口的类； class Windows implements Runnable 实现类去实现Runnable中的抽象方法: run()； 创建实现类的对象； Windows w= new Windows() 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象；（可创建多个） 如：Thread t1 = new Thread(w); Thread t2 = new Thread(w)… 通过Thread类的对象调用start()：①启动线程；②调用当前线程的run()–&gt;调用了Runnable类型的target的run()，也就是自己写的run() 。 t1.start(); t2.start()… 优先使用方式二，原因： 实现的方式没有类的单继承的局限性； 实现的方式更适合来处理多个线程共享数据的情况。使用方法一需要使用static 方法三：采用Callable接口（jdk5新增方法） 创建一个实现Callable接口的实现类； 实现call方法，将此线程需要执行的操作声明在call()中；—可以有返回值 创建Callable接口实现类的对象； NumThread numThread = new NumThread() 将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象； FutureTask futureTask = new FutureTask(numThread) 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()，启动线程； new Thread(futureTask).start() 获取Callable中call方法的返回值，采用get获取。 Object sum = futureTask.get() 方法四：采用线程池（jdk5新增方法）提前创建好多个线程，放入线程池中，使用时直接获取。 线程的生命周期： 线程的安全问题当一个线程未操作完时，其它线程参与进来，进行相同的操作。如：一个线程操作车票过程中，还没有操作完成，票没有卖出去，其它线程参与了进来，也操作了车票，会出现重票、错票的情况。 解决方法：一个线程a操作时，其它线程不能参与进来，直至其操作完成。这种情况即使线程a出现了阻塞，也不能被改变。java中，通过同步机制，来解决线程的安全问题。 方法一：同步代码块synchronized(同步监视器){ ​ //需要被同步的代码 } 说明：1. 操作共享数据的代码，即为需要被同步的代码； ​ 2. 共享数据：多个线程共同操作的变量。比如：票ticket就是共享数据； ​ 3. 同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。其中，方法一(Thread)中可用类，方法二(Runnable)中可用this。也都可以自己创建。 要求：多个线程必须要共用同一把锁。 方法二：同步方法 使用方法：方法声明前加一个synchronized，如public synchronized void show() 同步方法也需要同步监视器，只是不需要显示声明； 非静态的同步方法，其同步监视器是this； 静态的同步方法，其同步监视器是其类本身 同步的方式，解决了线程的安全问题。但同步的代码块运行时，只能有一个线程参与，其余线程等待，因此效率低。 方法三：Lock锁需要手动启动锁（启动同步 lock()）和手动关闭锁（关闭同步unlock()） java常用类String类的介绍 代表字符串，使用一对””引起来表示，代表不可变的字符序列； ​ 体现：1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值；2.对字符串进行拼接或字符替换时，也会重新指定内存区域赋值，不能使用原有区域添加； String对象的字符内容是存储在一个字符数组value[]中的； final char[] value 可以比大小，支持序列化； 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串声明在字符串常量池中，字符串常量池不会存储相同的字符串； String s1 = “javaEE” 若采用new+构造器的方式给字符串赋值，则字符串声明在堆中，地址就会有区别了。 String s2 = new String(“javaEE”) 注意：常量和常量的拼接在常量池，但凡有一个是变量，则拼接结果在堆中。 字符串的常用方法： 注意：1. 原字符串不可变，只是添加了新的字符串 ​ 2. char值序列就可以理解为字符串 String字符串转化为基本数据类型/包装类：调用包装类的静态方法：parseXxx(str) 如：String str1 = “123” int num = Integer.parseInt(str1) //123 基本数据类型/包装类转化为String字符串：调用String重载的valueOf(xxx) 如：int num = 123 String str2 = String.valueOf(num2) //“123” String字符串转化为char[]：采用toCharArray()；反过来，调用直接调用String的构造器即可 如： String str3 = “abc123” Char[] charArray = str3.toCharArray(); // {‘a’, ‘b’, ‘c’, ‘1’, ‘2’, ‘3’} String str4 = new String(charArray) // “abc123” StringBuffer与StringBuilderStringBuffer：可变的字符序列；线程安全的，效率低；底层使用char[]存储 StringBuilder：可变的字符序列；线程不安全的，效率高；底层使用char[]存储 注意：可变和不可变只的是空间中是否创建新的地址存放变化后的字符串。可变表示不用重新创建，在原来地址处进行修改即可。主要体现为：char[]是否用final修饰 源码分析： String str = new String(); //char[] value = new char[0]; String str1 = new String(“abc”); //char[] value = new char[]{‘a’, ‘b’, ‘c’}; StringBuffer sb1 = new StringBuffer(); //char value = new char[16]; 底层创建了一个长度为16的char型数组 StringBuffer sb1 = new StringBuffer(“abc”); //char value = new char[“abc”.length()+16] StringBuffer的常用方法： 开发中建议使用StringBuffer和 StringBuilder，采用new StringBuffer(capacity)进行定义 此外常用类还有System类、Math类等等。 枚举类与注解 类的对象只有有限个、确定的，这样的类叫做枚举类。 当需要定义一组常量时，强烈建议使用枚举类。 使用enum定义枚举类： enum Season() 提供当前枚举类的对象，多个对象之间用”,”隔开，末尾对象用”;”结束； SPRING(“春天”), SUMMER(“夏天”); 声明对象的属性，用private final 修饰； private final String seasonName; 私有化类的构造器，并给对象属性赋值； private Season(String seasonName){…} 测试类调用时，直接采用类名.对象名调用。 Season summer = Season.SUMMER 注意：1.定义类：enum+类名，没有class； ​ 2.enum定义的枚举类自动继承了java.lang.enum类，如重写了toString方法，直接打印对象名 注解：Annotation Annotation其实就是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理； Annotation可以像修饰符一样被使用，可用于修饰包，类，构造器，方法，成员变量，参数，局部变量的声明，这些信息保存在Annotation的”name=value”对中。 如@Override","link":"/2023/01/14/java%E5%9F%BA%E7%A1%80%E5%9B%9B/"},{"title":"元学习","text":"本篇文章讲解了机器学习中的元学习相关内容。首先讲解了元学习的概念和大致的算法流程，之后具体介绍了三种不同的元学习方法，包括MAML，Reptile，FOMAML。 元学习概念Meta Learning: Meta Learning 被称作元学习，不同于Machine Learning，Machine Learning的目标是让机器能够学习，Meta Learning则是要让机器学会如何去学习。 对于一般的机器学习流程，首先将原始数据分为两类(train_test_spilt)，为训练数据和测试数据，通过将训练数据代入到此学习算法F中，得到一个生成的函数f，之后利用测试数据来对此函数进行测试，并得到相应的损失值l。如果效果达标就证明机器学到了该特定任务的实现函数。 其中，传统的机器学习算法是由人来人为制定学习算法F，而Meta Learning则是机器自己生成。得到的L(F)为损失函数，为各个任务通过测试得到的损失值的和，通过损失函数可以判断此F的好坏。 具体算法首先有一个初始参数parameter，随训练数据一起代入到梯度计算中，得到此参数的更新值，循环往复，得到最后的数据θ。 损失函数定义完毕后，我们该如何降低F的损失呢？由于Meta Learning的求解是非常复杂的过程，我们先以MAML算法为例讲解一个Meta Learning的简单情况的求解。 MAML算法想要解决的问题是，对于F在每一个任务中学习到的f，规定f只负责决定参数的赋值方式，而不设计模型的架构，也不改变参数更新的方式。也就是说，MAML中的f的网络结构和更新方式都是提前固定的，MAML要解决的是如何针对不同任务为网络赋不同的初始值。 MAML在意的是用Ф训练出的θn的表现如何；而Model-training则是在意在所有task中均有最佳loss的初始值Ф。 此外对于Reptile，对应生成初始参数Ф的方向为，由初始值到多次训练得到最后的θn的方向。 实例一(MAML)概念通过大量的学习任务来得到一个模型，当出现一小批新任务时，能够对模型进行微调，并快速学习。基本思想：训练模型的初始参数，以便在通过一个或多个梯度步骤更新参数后，该模型在新任务上具有最佳性能，而该梯度步骤是根据该新任务中的少量数据计算得出的。 从此图可以看出，MAML的目标是找到对任务(task)的变化敏感的模型参数(model parameters)，这样，当损失梯度(loss gradient)的方向改变时，参数的微小变化将对从所有任务分布 p(T) 提取的任何一个任务(task)的损失函数(loss function)产生较大的改善。即可以使用新任务(new task)上少量的样本fine tune模型后得到新的模型参数(model parameters, θ)对新任务检测的性能有很大的提升。 算法过程 1、第一个Require的 p(T) 指的是meta-train中tasks的分布；第二个Require中的 α 和 β 指的是步长(step size)，也可以理解为学习率(learning rate). MAML的模型训练过程是gradient by gradient，即MAML是基于二级梯度的，每次迭代包含两次的参数更新的过程，分别对应两个学习率 α 和 β。2、步骤1：随机初始化模型的参数。3、步骤2：是一个外循坏。每次迭代可以理解为一个epoch，每个epoch训练多个任务中的若干个任务。预训练过程有多个任务，也就对应多个epoch。（循环变量：时期（mata batch）。存在这多个时期，每一个时期中有多个任务。）4、步骤3：随机对若干个(meta size)任务进行采样，形成一个meta batch训练数据。5、步骤4：这是一个内循环。利用meta batch中的每一个任务Ti，分别对模型的参数进行更新（比如4个任务更新4次参数）。（循环变量：任务(Ti)。在某一个具体时期中，有多个任务，分别对这些任务进行参数更新）6、步骤5：在N-way K-shot（N-way指训练数据中有N个类别class，K-shot指每个类别下有K个被标记数据）的设置下，利用meta batch中的某个task中的support set（任务中少量中有标签的数据，可以理解为训练集training set）的N*K个样本计算每个参数的梯度。7、步骤6：第一次梯度的更新的过程。针对Meta batch的每个任务Ti更新一次参数得到新的模型参数θi，这些新模型参数会被临时保存，用来接下的第二次梯度计算，但其并不是真正用来更来更新模型。8、步骤7：内循环结束。9、步骤8：第二次梯度更新的过程。这个是计算一个query set（另一部分有标签的数据，可以理解为验证集validation set，用来验证模型的泛化能力）中的5-wayV（V是一个变量，一般等于K，也可以自定义为其他参数比如15）个样本的损失loss，然后更新meta模型的参数，这次模型参数更新是一个真正的更新，更新后的模型参数在该次meta batch结束后回到步骤3用来进行下一次mata batch的计算。10、步骤9：外循环结束。 两个种类：（1）Regression：小样本监督学习（2）RL：强化学习区别：RL需要从任务对应的环境中采样 实例二(Reptile)一阶的基于梯度的元学习算法。 基本思想：通过重复采样任务，对其进行训练并将初始化朝着该任务的训练权重进行工作。 对应参数的更新方向：由初始值到多次训练得到最后的θn的方向。 具体算法步骤： 1、初始化参数 2、开始循环迭代i =0,1,2… 3、采样一个meta batch,每个batch内有多个任务task 4、对于每一个task，根据迭代次数k采样出含k个batch的minibatch, 5、对minibatch内的每一个batch使用梯度下降法更新初始化参数，得到Ψ’ 6、将每个task更新后的参数Ψ’与初始参数Ψ相减，将这个相减的结果经过某个映射（将这个差值看做某个梯度，加入到某种自适应的算法中）。在我们的实现中一般是（Ψ’-Ψ）/a，这个a我们一般设置为一个可以变的值。 这一步可以理解为： （Ψi~表示第i个任务上对Ti的更新操作。） 7、回到2，继续，直到循环结束。 当k=1时，算法对应于期望损失的随机梯度下降（SGD） 当k&gt;1时，算法包含了LT更高阶的微分项 Reptile的核心代码： Reptile有效的原因： 1、通过用泰勒级数近似表示更新过程，发现SGD自动给出了与MAML计算的二阶项相同的项。这一项调整初始权重，以最大限度地增加同一任务中不同小批量梯度之间的点积，从而增大模型的泛化能力。 2、Reptile通过利用多次梯度更新，找到了一个接近所有最优解流形的点。 当执行SGD更新时，MAML形式的更新过程就已经被自动包含在其中了，通过最大化模型在不同批次数据之间的泛化能力，从而使得模型在微调（fine-tune）时能取得显著的效果。 实例三(FOMAML)忽略了MAML中的二阶微分项，节省了计算开销，但损失了部分梯度信息 具体步骤： 将梯度向量视为常量，即可将雅可比矩阵转化为恒等操作，所以可以简化外循环优化过程中所使用的梯度公式。 具体流程如下： 1、采样任务T； 2、对初始化参数执行更新操作，得到ϕ~; 3、利用ϕ~计算对ϕ的梯度，得到gFOMAML; 4、将gFOMAML应用到外部循环优化中。 Reptile和FOMAML在内循环过程中都是使用的SGD进行的优化，在这个优化过程中任何微小的变化都将导致最终模型性能的巨大变化，两者对于内循环中的超参数都有很强的敏感性，FOMAML在minibatch以错误的方式选取时会出现显著的性能下降情况。","link":"/2022/12/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%85%83%E5%AD%A6%E4%B9%A0/"},{"title":"python常用方法","text":"本篇文章讲解了python中各个数据结构的常用方法与实现。包括：列表list，字符串，链表，队列，栈，树，堆等。 list的常用方法1.对List进行翻转：list(reverse(List))；# reversed也行，reversed是python自带，reverse是List特有，不过返回的都是迭代器 2.对List进行排序：List.sort(reverse = True)，reverse = True代表降序，默认为升序 3.插入元素：List.append() 4.插入列表：List.extend() 5.获取指定元素m的下标：List.index(m) 6.List的切割：list无法直接切割，如List[a:b][c:d]是不行的，只有numpy数组可以 但一维list可以直接切割，如List[: a] 7.读取List某一行：List[a]，不是List[a, :] 读取List某一列：[x[a] for x in List]，而不是List[:, a] 8.定义一个a*b的全零列表: s = [[0 for j in range(b)] for i in range(a)] 定义二维空列表: s=[][] 要先插入后赋值 9.list元素的删除：①list.remove(a) 删除第一个a；②list.pop(index) 删除并返回序列为index的元素，常用于栈、队列中；③切片 实际上上面说的List都是数组，数组和列表的最大区别是：数组具有索引，且数组中的数据是连续存储的。 字符串的常用方法1.字符串遍历：for i in range(Str): Str[i] // for eachstr in Str: eachstr 2.返回字符串中某一字符s的索引值：Str.index(s) 3.字符串中字符的替换：Str.replace(old, new, count)，count表示替换次数，若没有则表示全部替换 4.字符串的分割：Str.split(s). 将字符串Str沿字符s进行切割，并返回各部分组成的数组 5.字符串的拼接：Str = Str1 + Str2 + Str3 6.字符串的翻转：’’.join(reversed(Str)); 列表合并为字符串’’.join(Str) 7.计算一个字符串中间某个字符出现的次数: Str1.count(s) 8.大小写转化：.lower()；.upper() 9.字符串的查找：Str.find(s, begin, end) (从Str中查找s，begin end为开始和结束的下标) 10.字符串的删除：①Str.strip(s）从str中删除s的所有符号； ②删除固定位置字符：切片操作s’=Str[0:3]+Str[4:] 删除Str中第三个位置 ③删除字符串中的某一种字符：替换操作Str.replace(s, ‘’) 链表的常用方法1.单链表插入新节点： class Node: # constructor def init(self, data, next=None): ​ self.data = data；self.next = next # 插在开头 dummy = Node(0)；dummy.next = head；head = dumy；return head # 插在中间 dummy = Node(0)；dummy.next = prev.next；prev.next = dummy # 插在末尾 dummy = Node(0) while head.next: head = head.next head.next = dummy；dummy.next = None 2.单链表删除结点时，可以先找到要删除结点的上一个结点node，node.next = node.next.next，同时还不用考虑删除最后一个结点的情况，因为右边为None 3.双链表基本方法：查找、插入、删除，见Leetcode707.设计链表 https://leetcode.cn/problems/design-linked-list/ 记住，链表可以直接用头结点来表示，返回头结点就等于返回了整个链表； 记住，一旦一个节点的next指向了None，就不能直接对这个None赋值了，而是要让该节点的next指向一个新的值 队列的常用方法队列(先进先出FIFO) python实现队列： import collections q = collections.deque()// q=list() 一般情况下用list就行了，deque是双端队列 q.append(element); q.popleft() // q.pop(0) 一定要加上0，因为list的地址是固定的 注：list没有empty()方法 栈的常用方法栈(后进先出LIFO) python实现栈： import collections q = collections.deque() // q=list() 一般情况下用list就行了 q.append(element); q.pop() # pop会返回取出元素 树的常用方法树的遍历 前序遍历[https://leetcode.cn/leetbook/read/data-structure-binary-tree/xeywh5/]： 递归： 非递归： 中序遍历：[https://leetcode.cn/leetbook/read/data-structure-binary-tree/xecaj6/] 后序遍历：[https://leetcode.cn/leetbook/read/data-structure-binary-tree/xebrb2/] 总结一下：三种遍历的中心思想是一致的，若采取非递归的方法，都需要创建一个栈。然后都是先按左子树找到最左边的叶子结点，并依次入栈，之后进行出栈并遍历右子树。对于后序遍历，出栈需要进行条件判定：右子树为空或已经遍历，才能出栈，因此需要设定标志位。 层序遍历：[https://leetcode.cn/leetbook/read/data-structure-binary-tree/xefh1i/] 注意，与链表相似，树的根节点可以代表整棵树，对根节点采用left和right属性就可以调用各个节点。在leetcode中，返回根节点等于返回了整棵树，但是不要忘了，它本质上还是一个节点。 堆的常用方法python中的优先队列都是从小到大排列的（即最小根堆），主要方法有： q = list() 1.heapq.heapify(q) 列表转化为堆 2.heapq.heappush(q, (value,key)) 将m放入堆中—O(logn) 3.heapq.heappop(q) 弹出并返回堆顶元素，即最小值 排序方法：按value大小排序","link":"/2022/12/22/python%E6%96%B9%E6%B3%95/"},{"title":"机器学习优化方法讲解","text":"本篇文章讲解了机器学习中的优化方法。包括梯度下降算法及其优化算法等。 1）梯度下降算法： ①BGD(Batch gradient descent)： 采用整个训练集的数据来进行梯度的计算，对于凸函数可以收敛到全局最小值，非凸函数可以收敛到局部最小值。 优点：梯度是在全部数据集上计算出的，因此每次迭代都是向着整体的最优化方向 缺点：计算量大，速度慢； ​ 容易陷入极小值点，因为在极小值点（鞍点）梯度为0，所以参数不会更新。 ②SGD(Stochastic gradient descent)： 和BGD 的一次用所有数据计算梯度相比，SGD 每次更新时随机选择一个样本进行梯度更新，一次只进行一次更新。 优点：速度快，并且可以新增样本； ​ SGD 可能会跳到更好的局部极小值处，因为极小值时，梯度是随机选择的一个样本，这个梯度未必是0。 缺点：SGD不是每次迭代都向着整体最优化方向，准确度下降，不是全局最优； ​ SGD 因为更新比较频繁，会造成 cost function 有严重的震荡。 ③Mini-batch gradient descent： 将二者综合，每一次参数更新时使用样本中的一小部分（使用一小批数据进行更新）。 缺点：不能保证很好的收敛性。学习率太小收敛慢，太大会在极小值附近震荡。 ​ batch-size大小难以选择。 2）梯度下降算法的优化：①动量梯度下降算法(Momentum)： 梯度不仅与当前梯度有关，还与之前的梯度有关，这样参数更新的方向会朝向更加有利于收敛的方向（有利于减小震荡），收敛速度更快。对于动量梯度下降算法，当前时刻的梯度是 从开始时刻到当前时刻的梯度指数加权平均。 其中动量参数通常取0.9左右。 优点：增加收敛稳定性，减小震荡，收敛速度更快 缺点：所有特征用同一种学习率，无法进行学习率自适应调节，如对于稀疏特征更希望大一点的学习率； ②自适应梯度算法Adagrad(Adaptive gradient algorithm): Adagrad可以对低频的参数做较大的更新，对高频的做较小的更新，对于稀疏的数据它的表现很好，很好地提高了 SGD 的鲁棒性。Adagrad优化算法就是在每次使用一个 batch size 的数据进行参数更新的时候，算法计算所有参数的梯度，那么其想法就是对于每个参数，初始化一个变量 s 为 0，然后每次将该参数的梯度平方求和累加到这个变量 s 上，然后在更新这个参数的时候，学习率就变为： Adagrad 的核心想法是：如果一个参数的梯度一直都非常大，那么其对应的学习率就变小一点，防止震荡，而一个参数的梯度一直都非常小，那么这个参数的学习率就变大一点，使得其能够更快地更新，这就是Adagrad算法加快深层神经网络的训练速度的核心。 ③均方根传递算法RMSProp(Root Mean Square Prop)： RMSprop 是为了解决 Adagrad 学习率急剧下降的问题。RMS使用的是指数加权平均，旨在消除梯度下降中的摆动，与Momentum的效果一样，某一维度的导数比较大，则指数加权平均就大，某一维度的导数比较小，则其指数加权平均就小，这样就保证了各维度导数都在一个量级，进而减少了摆动。 建议η=0.001，β=0.9. ④ADAM(Adaptive Moment Estimation)： Adam不仅存储了过去梯度的平方的指数衰减平均值，还像Momentum一样保持了过去提取的指数衰减平均值。 如果 mt 和 vt 被初始化为 0 向量，那它们就会向 0 偏置，所以做了偏差校正，通过计算偏差校正后的 mt 和 vt 来抵消这些偏差： 梯度更新规则: 超参数设定：建议β1 ＝ 0.9，β2 ＝ 0.999，ϵ ＝ 10e−8。","link":"/2022/12/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"},{"title":"机器学习-成员推断攻击","text":"本篇文章讲解了机器学习中的成员推断攻击（Membership Inference Attack, MIA），成员推断攻击是指：给定一个数据记录，攻击者需要判断该数据记录是否存在于目标模型的训练数据集中。本文将依次讲解：成员推断攻击的分类，白盒成员推断攻击，黑盒成员推断攻击，以及数据模型泄露的结论。 成员推断攻击的分类1.按攻击者的观察方式分为白盒和黑盒攻击： ​ 其中，黑盒攻击者无法访问参数和计算过程，但给定输入可以观测到输出值；白盒攻击时，这些中间结果对于攻击者来说是可得的。除此之外，模型的参数和结构对于攻击者来说也是可见的。 2.按攻击者的目标分，目标可以是独立学习和联邦学习： ​ 其中，独立学习时，攻击者可以观测到微调前后的模型情况；联邦学习时，攻击者可以作为中心服务器或者参与者进行观测。 3.按攻击者的攻击模式分为主动攻击和被动攻击： ​ 推理攻击大多数为被动攻击，即对手在不改变学习过程的情况下进行观察；而主动攻击中，参与训练过程的对手可以主动影响目标模型，以提取有关其训练集的更多信息。 4.按先验知识分为监督和非监督学习攻击： ​ 若对手的数据集D’与目标数据集D重叠。给定该数据集，他可以以监督的方式训练攻击模型，并用其攻击其余的训练数据集。而非监督攻击时，攻击者可以访问与目标训练集D部分重叠的数据集D’，但是，对手不知道D’∩D中的数据点。 白盒成员推断攻击这里白盒成员推断攻击的讲解以《Comprehensive Privacy Analysis of Deep Learning》论文为例，并应用于了联邦学习的环境中。其白盒攻击结构为： ​ 其中，攻击者知道目标模型的训练数据(x,y)和模型的参数信息W，模型f，并可以计算得到隐藏层h、模型输出f(x)和损失值L。将这些信息作为攻击模型的输入，经过卷积神经网络和全连接网络等形式，计算得出相应的攻击输出值，并获得成员信息。若为非监督模式，则还需要结合译码过程，得到最终的模型。 ​ 成员推理攻击的目的：判断某个数据记录是否属于目标的训练集。 ​ 联邦学习的详细解释：拥有不同训练集Di的N个参与者就单个深度学习任务和模型架构达成共识，以训练全局模型。 中央服务器为全局模型保留参数W的最新版本。 每个参与者具有局部模型，因此具有局部参数Wi。 在培训的每个时期，每个参与者都下载全局参数，使用SGD算法在其本地培训数据上对其进行本地更新，然后将其上传回服务器。参数服务器使用所有参与者上载的参数来计算每个参数的平均值。这种协作式培训一直持续到全局模型收敛为止。 黑盒成员推断攻击对于黑盒成员推断攻击，攻击者不知道目标模型的结构。这里以论文《Membership Inference Attacks Against Machine Learning Models》为例，这是第一篇有关成员推断攻击的文章，主要思想是借助一个与目标模型类似的模型（影子模型），来实现成员推断攻击。 攻击条件与判定：给予攻击者数据记录和对目标模型的黑匣子查询访问权限。如果攻击者可以正确确定此数据记录是否属于模型的训练数据集，则攻击成功。攻击准确性的标准度量标准是精度（由成员推断出的记录的确确实是训练数据集的成员）和召回率（由攻击者正确推断出训练数据集的成员的几率）。 黑盒设置中的成员资格推断攻击。攻击者使用数据记录查询目标模型并获得对该记录的模型预测。预测是记录属于某个类的概率向量(每类一个)。该预测向量与目标记录的标签一起传递到攻击模型，攻击模型会推断记录是在目标模型的训练数据集中还是不在目标模型的训练数据集中。 攻击者的目的：构建一个攻击模型，该模型可以识别目标模型行为中的此类差异，并仅根据目标模型的输出，使用它们来区分目标模型训练数据集的成员与非成员。 需要通过影子模型来构建攻击模型： ​ 借助影子模型来生成攻击模型的训练数据集(下图中的Attack Training Set)，进而生成攻击模型。推断影子模型的训练数据集中的成员资格，会生成一个攻击模型，该攻击模型也可以成功地推断目标模型的训练数据集中的成员资格。 ​ 使用与用于训练目标模型相同的机器学习平台来训练影子模型。目标模型和阴影模型的训练数据集具有相同的格式，但不相交。阴影模型的训练数据集可能会重叠。所有模型的内部参数均经过独立训练。 ​ 虽然目标模型的类型和结构是未知的，但是攻击者知道训练目标模型相关的服务信息，可以使用与用于训练目标模型的服务完全相同的服务，例如GooglePrediction API来训练影子模型，来做到二者模型平台类似，训练数据集格式类似。 影子模型的数据从何而来(上图中的Training Set and Test Set)： ​ ①如果攻击者没有真实的训练数据，也没有关于其分布的任何统计信息，他可以使用目标模型本身为阴影模型生成合成训练数据(借助具体算法，详见论文Ⅴ.C) ​ ②攻击者具有一些有关从中提取目标模型的训练数据的统计信息(如不同特征的边际分布的先验知识)。 在我们的实验中，我们通过从每个特征的边际分布中独立采样每个值的值来生成阴影模型的综合训练记录。 ​ ③攻击者可能会访问一些与目标模型的训练数据相似的数据，并被视为“嘈杂”版本。 在我们使用位置数据集的实验中，我们通过翻转10％或20％随机选择的特征的（二进制）值，然后在产生的噪声数据集上训练阴影模型，来模拟此情况。 模型数据泄露的结论①模型的类越多，任务越多，泄露的信息就越多。 ②每个类的训练数据量与成员推断准确性之间的关系：这种关系更加复杂，通常，训练数据集中与给定类别关联的数据越多，该类别的攻击精度越低。 ③较早的训练时期包含数据集的一般特征的信息，不会泄漏重要的隶属信息，但是，随着模型开始学习此类时期中的离群值，较晚的时期包含更多的隶属信息，因此使用训练了一段时间后的模型攻击效率更高。 ④与层输出相比，梯度泄漏的训练集成员信息更多。","link":"/2022/12/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%88%90%E5%91%98%E6%8E%A8%E6%96%AD%E6%94%BB%E5%87%BB/"},{"title":"编程注意事项","text":"本篇文章讲解了python中的一些编程注意事项，主要涉及到python的一些基本语法和机器学习有关知识的实现，还在更新中。 1.x为torch.tensor，M为模型，M(x)为模型输出，假设模型输出标签为m： y1=M(x).argmax(-1)，则y1=tensor([m])，y1.shape=torch.size([1]); y2=torch.argmax(M(x), -1)，则y2=tensor([m])，y2.shape=torch.size([1]); y3=torch.argmax(M(x))，则y3=tensor(m)，y3.shape=torch.size([])。 2.各个数据类型的相互转化： torch.tensor转numpy：a.numpy() numpy转torch.tensor：torch.from_numpy (a) numpy转tf.tensor：tf.convert_to_tensor(a) tf.tensor转numpy：a.eval() 3.模型和学习率的保存： ①先建立一个字典，保存四个参数：（有scheduler动态变化才需要保存scheduler） state = {‘net’:model.state_dict(), ‘optimizer’:optimizer.state_dict(), ‘epoch’:epoch, ‘scheduler’:scheduler.state_dict()} ②调用torch.save(): torch.save(state, dir) 其中dir表示保存文件的绝对路径+保存文件名，如’/home/qinying/Desktop/modelpara.pth’ ③当你想恢复某一阶段的训练（或者进行测试）时，那么就可以读取之前保存的网络模型参数等。 checkpoint = torch.load(dir) model.load_state_dict(checkpoint[‘net’]) optimizer.load_state_dict(checkpoint[‘optimizer’]) start_epoch = checkpoint[‘epoch’] + 1 scheduler.load_state_dict(checkpoint[‘scheduler’]) 4.随机数种子设置，保证每次运行结果相同： random.seed(args.seed) np.random.seed(args.seed) torch.manual_seed(args.seed)","link":"/2022/12/25/%E7%BC%96%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"title":"联邦学习（三）","text":"本篇文章为联邦学习系列的第三篇。主要讲解机器学习中的一个新型方向——联邦学习（Federated Learning, FL）。联邦学习是一种新的机器学习框架，在满足隐私保护和数据安全的同时，使数据拥有方能够共同拥有和交换数据，搭建一个更加稳定、高效的系统。本文继续介绍纵向联邦学习（Vertical Federated Learning, VFL）的相关知识，继续讲解隐私保护问题，本文章以分析论文的方式进行介绍。 论文5：真实场景的VFL隐私泄露论文“Privacy Leakage of Real-World Vertical Federated Learning” CoRR 2021 针对真实场景（真实安全计算框架），提出了两种不同的攻击方式，评估了VFL的隐私泄露。 In this paper, we provide the first systematic study on the potential privacy risk of practical learning protocols in vertical federated learning. Specially, our work seeks to answer the crucial research question: How much is the privacy risks of the practical learning protocols for computing participates whose data is used as part of the training set? In other words, how much is the privacy leakage of the learning protocol about the participants’ training data? 提出的攻击方法：reverse multiplication attack（反向乘法攻击）and reverse sum attack（反向和攻击）。 场景：在论文3的基础上，加了一些真实的隐私保护措施和协议限制，大致还是相同，两个用户和一个中央服务器（也叫第三方协调器 third-party coordinator）。主要挑战：加密的中间输出和异质的训练数据。一方面，加密的中间输出使得参与者无法通过梯度更新直接推断私有数据，导致任何基于学习的攻击都不能工作。另一方面，由于参与者的训练数据是异质的，他们中没有人可以通过恶意查询推断其它用户的私有数据。 攻击者信息：其中的一个参与者被攻击者控制，攻击者可以发送或接收该参与者训练数据的静态结果（如梯度信息或梯度与数据的乘法结果…）对应的加密信息，通常攻击者可以恶意控制该用户的局部训练过程。攻击者不会破坏协议规则，但希望从协议中收集尽可能多的私人信息。如在reverse multiplication attack中，攻击者可以构造特定的字符串，并将它们插入到梯度的最低有效位，同时保持学习协议不变；在reverse sum attack，攻击方还可能破坏第三方服务器，以从协议中获取更多隐私。 攻击者的目标：尽可能多地推断参与者的私人训练数据集。在reverse multiplication attack中，攻击者旨在推断目标参与者的原始训练数据；在reverse sum attack中，攻击者试图推断目标参与者训练数据的部分顺序。 具体实现内容好复杂，涉及到编码、解密这些，这里不多阐述。 论文6：第一个VFL对成员信息保密的框架 论文“Vertical Federated Learning without Revealing Intersection Membership” CORR2021 提出了VFL中第一个对成员信息保密的框架。 场景：与[2]中场景相同，但多强调了一点：VFL各个用户在开始训练本地模型之前，需要先进行样本ID的对齐，也就是确定各方共享的相同实体(定义为交集)。通常，这是通过私有集交集(PSI)协议实现的。然而，这个过程中会产生成员隐私的泄露，具体的，各参与方都能够看到相互重叠的数据ID。因此，这篇文章提出了PSU协议，并基于这一协议提出了新的VFL框架，来在保持模型肖泳的同时保护交集成员的隐私。这里主要拓展视野并了解威胁模型。 威胁模型：假设用户一个为active party Pa，数据集Da=(Ia, Xa, ya)一个为passive party Pp，数据集Dp=(Ip, Xp)，攻击者为其中之一，且honest-but-curious，攻击者的目标是找到交集ID。分为两种情况：①Pa为攻击者，Pa通过yid和Pp传递的特征值z进行攻击，找到id∈Ia∩Ip；②Pp为攻击者，Pp通过xid和Pa回传的梯度值g进行攻击，找到id∈Ia∩Ip。 原文参考：We assume malicious parties are honest-but-curious, i.e. Pa and Pp faithfully run the VFL protocol, but they may infer important information including raw sample data and intersection membership from the exchanged information. In particular, we consider two privacy leakage scenarios: 1) for id∈Ia, Pa finds out if id∈Ia∩Ip by checking yid and the embedding forwarded by Pp, and 2) for id∈Ip, Pp finds out if id∈Ia∩Ip by checking xid and the gradient sent back by Pa. 论文7：第一个VFL的数据恢复工作 论文“CAFE: Catastrophic data leakage in vertical federated learning” NeurPIS 2021 提出了一种VFL下的数据泄露攻击，能够有效的从共享梯度中恢复批数据，可用于大批量数据。(参与标准FL的私人数据，特别是VFL情况下，有很高的风险从训练梯度中泄露) 场景：作用于通用VFL场景，与论文3相同，一个active party(server)和多个passive party，server拥有标签信息，可以选定每一轮更新哪些id的数据。攻击者为server，通过全局模型的梯度泄露，控制id，恢复出每轮训练的数据。 攻击者信息：1) 全局模型的梯度信息(分为很多梯度信息，包括每一个批次损失函数的梯度、每一层损失函数的梯度、总损失函数的梯度，这个是server本身就能得到的)，2) 批次身份，即每轮全局训练指定每位用户参与训练的一个批次的数据量。(public shared gradients and batch identities)。注：θ 为全局模型的参数，θ­1 为全局模型第一个FC Layer的参数，b1 为第一个FC Layer的bias，D 为目标batch的全部训练数据。 攻击者的目标：分为三个步骤：1) 恢复第一个FC Layer输出的损失和梯度信息(借助)；2) 恢复第一个FC Layer的输入数据；3) 获取所有输入数据。具体如下图所示。左边为VFL的框架，右边为CAFE的框架。 CAFE的具体实现功能这里不再阐述，有很多复杂的推导。 CAFÉ的related works：即一些有关联邦学习中从客户端上传的梯度信息中恢复出原始数据的方法，大致思想都是优化目标函数，通过修改目标函数和优化思想，作用于不同的场景下。这种方法需要大量理论的分析。每种方法的优缺点和比较CAFÉ文章中都有。 CAFÉ的后续工作：没有直接follow CAFE的文章，但有一些其它数据恢复的文章。VFL下的数据恢复，就CAFÉ一篇。 再读CAFÉ，看看改进点：1. 采用更新的优化方式，实现更好的性能（不会）；2. 限制条件，不用梯度。去做属性推断攻击。（但又能用什么呢？z、x、y、θ和用梯度也没什么区别好像）；3. 更强的场景，攻击者为被动方（即参与VFL的任意一个用户），去恢复数据，这样条件就只有zp、xp、θp了。","link":"/2023/01/06/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E4%B8%89/"},{"title":"联邦学习（一）","text":"本篇文章为联邦学习系列的第一篇。主要讲解机器学习中的一个新型方向——联邦学习（Federated Learning, FL）。联邦学习是一种新的机器学习框架，在满足隐私保护和数据安全的同时，使数据拥有方能够共同拥有和交换数据，搭建一个更加稳定、高效的系统。本文主要对联邦学习进行一个概述，同时进行横向联邦学习的讲解。 联邦学习概述随着互联网的发展，人工智能（Artificial Intelligence, AI）得到了越来越广泛的应用，为人们的生活提供了很大的便利。但是，数据分布与隐私保护的问题也随之而来，一些大型的AI项目需要融合各个公司的数据，但在现实中想要将分散在各地、各个机构的数据进行整合几乎是不可能的。同时，随着通用数据保护条例（General Data Protection Regulation，GDPR）的出台，数据之间的交流越来越困难，用户的隐私保护和安全管理更加严格。 要解决上述数据交流的困境，传统的机器学习算法已经很难满足要求，在目前的法规和GDPR下，各个公司在用户没有批准的情况下无法直接进行数据交流。因此，需要设计一个新的机器学习框架，在满足隐私保护和数据安全的同时，使数据拥有方能够共同拥有和交换数据，搭建一个更加稳定、高效的系统，这就是联邦学习。 联邦学习最近已成为传统机器学习的一种替代方法，它允许两个或更多参与者（每个人都有自己的训练数据集）构建联合模型。各参与者使用自己的数据，在本地训练自己的模型，服务器进行参数的汇总并更新联合模型。联邦学习的各个步骤均为加密操作，在模型的构建过程中，各个用户的数据均在本地保留，没有进行数据共享，一定程度上保证了机器学习过程中的安全问题。因此，联邦学习系统有望在有效的保护数据隐私的同时扩大机器学习的规模。 联邦学习框架联邦机器学习（Federated machine learning），又名联邦学习，是一个机器学习框架，能在有效帮助多个机构在满足用户隐私保护、数据安全的前提下，进行数据使用和机器学习建模。联邦学习系统构架如下图所示。 上图主要介绍了两个数据持有方的情况。联邦学习系统主要由两部分组成，数据持有方（用户）和第三方协作者（服务器），用户分别在各自本地训练模型，且用户之间的数据不共享；服务器用来进行加密模型训练，保护用户数据隐私的同时进行模型参数汇总。训练过程可分为以下几个步骤： （1）协作者对训练过程中需要使用的数据信息进行加密，并将公钥传递给参与联邦学习的用户； （2）各用户接受公钥，并交互用于训练本地模型的中间参数信息，开始准备本地模型的训练； （3）各用户在本地各自计算梯度值和损失，进行加密模型训练，并把结果和参数传递给服务器。服务器进行参数的汇总，更新全局模型，得到全局参数信息（总梯度值）； （4）服务器将梯度加密回传给各个用户，用户继续在本地各自模型的参数。 重复上述过程，根据具体情况设置合适的损失函数和优化方式，当损失函数收敛时结束整个训练过程。在模型训练过程中，用户各自的数据仍然保留在本地，没有进行数据共享，数据的交互和模型的训练均为加密操作，不会造成隐私泄露。借助联邦学习系统，各用户合作实现了整个全局模型的训练，达到隐私保护的效果。 横向联邦学习的实现本地模型训练在联邦学习中，各个用户需要在本地进行模型的训练，本地模型的训练与大部分机器学习模型类似，即为由一组参数θ进行参数化的函数 f(θ): X-&gt;Y，其中X表示输入（或特征）空间，Y表示输出空间。 本文专注于用于分类任务的监督学习。其训练数据是一组标记有其正确类别的数据点，测试数据则没有类别标签，使用将输入图像或文本作为输入并输出类标签的模型。为了找到适合训练数据的最佳参数集，训练算法优化了目标（损失）函数，当模型在数据点上输出错误的标签时，该函数会对模型进行惩罚。我们使用 表示在给定模型参数的情况下在数据点 上计算出的损失，而 表示在批次b的数据点上计算出的平均损失。 有许多方法可以优化目标函数，如随机梯度下降（Stochastic Gradient Descent, SGD），Adam优化、Adagrad优化等，SGD优化在目前的机器学习和神经网络中的使用最为普遍，SGD是一种迭代方法，其中，优化器在每个步骤中都会接收一小批训练数据，并根据模型的方向更新模型参数。目标函数相对于学习速率的负梯度并由其缩放。当模型收敛到局部最小值（梯度接近零）时训练结束，使用保留的数据测试训练后的模型，该数据在训练期间未使用。标准度量标准是测试准确性，即正确分类的保留的数据点的百分比，常用的优化器还有Adam优化器等。对于梯度下降算法，当要找到损失函数的最小值时，任取一个初始点，找到给定点的梯度，朝着梯度相反的方向，就能让函数值下降的最快，因为梯度的方向就是函数之变化最快的方向。因此，通过梯度下降算法，反复求取梯度，就能到达局部的最小值。 全局模型更新各用户进行了本地模型训练后，将模型参数传递给服务器，由服务器进行全局模型更新。全局模型更新的方法有很多种，如同步梯度更新、模型平均等。 对于同步梯度更新的协作学习，在每次迭代中，每个参与者都从中央服务器得到全局模型，并根据他的一批训练数据进行更新，将更新发送到服务器。服务器等待所有参与者的梯度更新，然后使用随机梯度下降汇总的更新应用于全局模型。 对于模型平均的联合学习，在每个回合中，第k个参与者使用其整个大小为nk的训练数据集（即全局可见的更新不是基于批次，而是基于参与者的整个数据集），在当前模型上本地执行SGD步骤。每个参与者将结果模型提交给服务器，该服务器计算加权平均值。服务器在保留的数据集上评估生成的各个模型，并在性能停止改善时停止训练。 两种全局模型更新方法的收敛速度在很大程度上取决于学习任务和超参数（如参与者的数量和数据批次的大小），同时，二者都能达到较高的效率，其中同步梯度更新的协作学习只能共享用户的小部分梯度信息，故基于模型平均的联合学习更为常见。","link":"/2023/01/06/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E4%B8%80/"},{"title":"联邦学习（二）","text":"本篇文章为联邦学习系列的第二篇。主要讲解机器学习中的一个新型方向——联邦学习（Federated Learning, FL）。联邦学习是一种新的机器学习框架，在满足隐私保护和数据安全的同时，使数据拥有方能够共同拥有和交换数据，搭建一个更加稳定、高效的系统。本文主要介绍纵向联邦学习（Vertical Federated Learning, VFL）以及一部分纵向联邦学习的隐私保护问题，本文章以分析论文的方式进行介绍。 论文1：VFL综述论文**“Vertical Federated Learning: Challenges, Methodologies and Experiments” ** IEEE Network 2022: VFL的具体步骤： Step1: 私有集交集(Private set intersection)。在模型训练之前，框架需要找到所有参与者(即来宾组织和宿主组织)服务的公共标识符(id)来对齐训练数据样本，称为私有集交集(private set intersection, PSI)或安全实体对齐。PSI是一个安全的多方协议，它允许多个参与者在他们的数据中找出可用的公共id。广泛采用的PSI技术包括哈希、多项式求值和转移. Step2: 底层模型正向传播(Bottom model forward propagation)。在确定了所有参与者的对齐样本之后，每一个参与者将使用基于其底层(本地)模型的本地数据完成一个向前传播过程。这种正向传播过程除了没有计算损失值外，与传统训练类似。 Step3: 正向输出传输(Forward output transmission.)。每个参与者将其底层模型的输出传输到标签所有者。直观地说，正向输出包含局部神经网络的中间结果，能够将原始属性转换为特征。这样的传输过程可能会泄露参与者的隐私信息。因此，应该利用先进的隐私保护方法，如差分隐私(DP)，以解决潜在的隐私风险，但可能会产生额外的通信成本和计算复杂性。 Step4: 顶部模型正向传播(Top model forward propagation)。标签所有者根据收集到的所有参与者的输出，根据顶层模型和标签计算损失函数值。 Step5: 顶部模型反向传播(Top model backward propagation)。标签所有者进行反向传播，计算两个梯度: 1)顶层模型的模型参数; 2)转发每个参与者的输出。使用顶级模型的梯度，标签所有者可以计算每批样品的平均梯度，并更新其模型。 Step6: 反向输出传输(Backward output transmission)。正向输出的梯度被发送回每个来宾参与者。可以注意到，所需的通信成本(传输比特)通常比Step2中的要小得多，因为它们是梯度而不是中间输出。 Step7: 底部模型向后传播(Bottom model backward propagation)。每个参与者根据本地数据和来自标签所有者的正向输出的梯度计算其底部模型参数的梯度，然后更新其底部模型。 VFL的安全隐私问题：现有VFL模型的隐私和安全风险研究不足。在VFL中，参与者需要获得一致的样本空间，来自其他参与者的成员推断攻击可能是多余的。在VFL中，对抗参与者只控制联邦模型的一部分，该联邦模型不能独立运行，并且只能访问自己的底层模型的梯度。然而，通过分析交换的消息，即中间输出和梯度，参与者可以从其他参与者推断客户端的属性，如标签推断攻击和私有数据泄漏。 ​ 保护每个参与者所拥有的标签的隐私应该是VFL的基本要求，因为标签可能是高度敏感的，例如，一个人是否患有某种类型的疾病。在某些特殊情况下，来自宿主组织的梯度也可以直接泄漏标签信息。此外，还证明了从共享梯度恢复批处理数据是可用的。我们还可以注意到攻击方法在不同的数据类型中是不同的。例如，表格数据在学习之前通常需要进行嵌入，从嵌入的属性中获取私有信息很困难。然而，对手能否利用VFL中交换的消息恢复原始属性值仍是一个有待研究的问题。 可能的防御措施： 安全框架：Differential privacy(DP)、Secure multi-party computing(SMC)、Homomorphic encryption(HE) 论文2：VFL的隐私保护——标签推断攻击（Label Inference Attack）论文 “Label Inference Attacks Against Vertical Federated Learning” Security 2022 第一个VFL下的标签推断攻击。 场景：在VFL中，有n≥2个用户参与训练，且有一个用户拥有数据的真实标签，一个用户为攻击者。每个用户都有各自数据的部分特征（可以理解为，样本集相同但特征集不同），用户都有自己的bottom model。共采用了两种不同场景：①VFL without model splitting：中央服务器不进行模型的训练，而是简单的将各个用户的输出结果进行汇总，并得到最终的输出；②VFL with model splitting：中央服务器有特定的模型top model（也就是我们说的全局模型），同时也拥有标签信息，服务器进行模型的训练，并聚合各个用户的特征输出，并回传梯度信息。其实我们通常将第二种情况看作，中央服务器的训练就在带标签的用户上进行，或者说就是指该用户，因为该用户控制着中央服务器。 攻击者为不具有标签数据的某一用户，被攻击者为具有标签的用户，攻击者试图获取标签信息。 攻击者信息：①由于攻击者为参与者，攻击者拥有自己的数据信息（只有x没有y）和本地模型，还有模型每轮训练后中央模型传递的梯度信息。②部分少量辅助数据信息i.e. a few dozens of auxiliary labeled samples，在实际情况中，这部分数据是可以获取的。③攻击者感兴趣的样本x，用于最后推断x的标签，x可以是任何能够得到的样本，不仅仅是原始拥有的训练数据。 攻击者目标：推断出给定数据的标签值（包括训练数据和感兴趣的数据）。摘自原文： Note that the adversary’s goal is to infer the labels of any interested samples, not just the ones in the training dataset. 于是这篇文章根据不同情况，设计了三种不同的标签推断方法。 \\1) 被动微调训练好的底层模型作为攻击模型，输入待测样本实现推断； \\2) 主动参与训练，提出一种恶意优化方案，得到攻击模型，输入待测样本实现推断； \\3) 进行直接标签推断，通过理论推导，全局训练的每一轮中，攻击者通过收到的梯度符号来直接判断标签是否正确，实现推断。可实现100%成功率。 论文3：VFL的隐私保护——属性推断攻击（Feature Inference Attack）论文 “Feature Inference Attack on Model Predictions in Vertical Federated Learning” ICDE 2021 第一个VFL下的属性推断攻击。 场景：VFL，用户个数n≥2，其中一个为active party，拥有真实标签，其余的为passive party，联邦学习的全局模型训练在active party上完成，并将参数回传给各个用户，与label inference②相同。 攻击者为active party，被攻击者为target passive party（没有标签的用户中的一个用户），攻击者甚至可以拉拢其它所有passive party对target passive party进行属性推断。 攻击者信息：①攻击者拥有自己的数据信息，即特征值xadv，②由于攻击者为主动方，故还拥有标签信息y、VFL各用户的模型参数θ = (θadv, θtar)、全局模型的输出v，③关于其它用户的粗略信息（如数据分布，数据类型，属性名称等），这个也是正常的，因为主动方会经常需要这些信息来证明训练模型的有效性，④攻击者不知道其它用户的具体数据值。 攻击者目标：推断目标用户的属性值。摘自原文： The adversary Padv is given the VFL model parameters θ, the prediction output v, and the feature values xadv that belongs to himself. Padv’s goal is to infer the feature values of Ptarget, i.e., ​ xtarget = A(xadv; v; θ) (1) 于是这篇文章设计了攻击模型A，在只知道上述信息的情况下，实现了VFL的属性推断。 简单学习一下实现过程：提出了三种攻击方式，分别作用于两种常用模型和通用模型解法 1) Equality Solving Attack 针对逻辑回归模型LR 攻击方通过收集VFL预测结果和Active party和Passive Party的半边模型参数聚合更新结果和feature推断估计Passive party的feature信息。推导了相应的公式，见论文Equ.(7)(8)。 2) Path Restriction Attack 针对决策树模型DT 攻击方可以根据自己的部分特征信息(蓝色方框) 限制树模型中可能的路径(灰色-蓝色箭头)，结合预测类别结果1进一步限制决策路径(蓝色-红色箭头)，可以推测目标方的属性(绿色方框)，见论文图Fig.2。 3) GRN(generative regression network) Attack 针对通用模型，包括复杂模型NN、RF等 攻击方在进行VFL模型训练时进行对GRN的训练，在前向传播阶段，单独训练VFL模型，进行loss反向传播阶段，更新VFL model参数时共同训练生成模型GRN。对于GRN模型，攻击者收集目标方的属性信息生成伪造的目标样本，具体的，攻击者根据自己的已有特征集和部分随机变量，估计出目标用户的未知特征集。 论文4：论文3的升级版论文**“Comprehensive Analysis of Privacy Leakage in Vertical Federated Learning During Prediction“ **Proceedings on Privacy Enhancing Technologies 2022 对论文3进行了更严格的要求，并提升了性能。 场景：与论文3相同，攻击者信息有较大差别。这里主要学习了解论文说的黑盒和白盒情况。 VFL的框架如下图所示，通常情况下，各个本地的模型采用LR模型，模型参数为θact和θpas，z为输出特征向量，全局模型输出为 c = ξ (z) = ξ (f (xact, θact) + f (xpas, θpas))，最后 c 会返回到active party中。 攻击者信息：论文3中为白盒情况：由于攻击者为active party，攻击者能够拥有全部模型的模型参数，包括 θact和θpas，因此公式(1)可以写作： ​ xpas = Awb (xadv; v; θact; θpas) (2) 论文4设计了黑盒情况：攻击者不知道其余用户本地模型的参数信息，但拥有少量其余用户的输入数据(即辅助数据auxiliary data)，因此公式(1)改为： ​ xpas = Abb (xadv; v; θact; xaux; vaux) (3)","link":"/2023/01/06/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E4%BA%8C/"},{"title":"论文常用句式","text":"本篇文章讲解了英文论文写作的常用句式，包括常用词语，常用句式和常用细节等，主要涉及到机器学习和隐私保护方向论文的写作。 常用词语1. exploit：运用、利用 Our EncoderMI exploits the overfitting of the image encoder towards its training data. 2. overfitting：过拟合 n. the overfitting of … adj. an overfitted image … 3. pre-training of model：模型预训练 v. uses the public data to pre-train the model. 4. private/sensitive：隐私的/敏感的 to determine if the data is private/sensitive. 5. confidence score vector：置信向量 posteriority：后验 feature vector：特征向量 construct a vector 6. scenario：情况、条件 ~ case We assume an inferrer has a black-box access to a pre-trained image encoder, which is the most difficult and general scenario. 7. module：模块、部分 ~ part An important module in contrastive learning is data augmentation. 8. state-of-the-art：最先进的 we generalize early stopping, which is a state-of-the-art overfitting-preventionbased countermeasure against membership inference to classifiers. 9. binary classifier：二分类器 multiple classifier：多分类器 10. extract：提取、获取 extract membership features and construct an inference training dataset. 11. ground truth：真实情况、理想情况、标准答案 for each target encoder, we have 10,000 ground truth members and 10,000 ground truth non-members. 12. model architecture：模型结构 We adopt the same architecture (i.e., ResNet18) for a shadow encoder. 13. otherwise****：否则，表示对立面 ~ while We adopt ResNet18 for a shadow encoder if the inferrer knows the architecture of the target encoder and use VGG-11 with batch normalization otherwise. 14. metrics：评价指标 We set accuracy, precision, and recall as our evaluation metrics. 15. ratio：比率 The accuracy of a method is the ratio of the ground truth members/non-members correctly predicted by the method. 16. cosine similarity：余弦相似度 All contrastive learning algorithms use cosine similarity to measure similarity between two feature vectors. 17. curves：曲线 The curves are obtained via tuning the classification thresholds in the three inference classifiers to produce different precisions and recalls. 常用句式1. 成员推断攻击定义： 1）given an input and a black-box access to an image encoder, EncoderMI aims to infer whether the input is in the training dataset. 2. 我们的方法有着很好的效果： 1）Our results show that EncoderMI can achieve high accuracy, precision, and recall. 2） 3. 之前的研究主要集中于做…： 1）Existing studies on contrastive learning mainly focus on how to train a better image encoder such that it can achieve better performance on the downstream tasks. 2）Existing membership inference methods are mainly designed for classifiers. For example, … 3）Existing membership inference methods are insufficient. 4. …的应用是…： 1）Membership inference in contrastive learning has two important applications. The first application of membership inference is that a data owner can use a membership inference method to audit whether his/her (public) data was used to pre-train image encoders. 2）The first step of our EncoderMI is to train a shadow encoder whose ground truth members/nonmembers are known to the inferrer. 5. 有着相同的数据集分布： 1）the shadow dataset has the same (a different) distribution from the pre-training dataset. 6. 我们将在后面的一节进行讨论： 1）we will discuss in Section 4； 7. 我们用 … 来表示 … ： 1）We use a triplet B = (P, E, T) to denote the three dimensions of the inferrer’s background knowledge. 我们用一个三维元组来表示推断者拥有的背景知识 8. 数据集分割： 1）We randomly split a shadow dataset into two disjoint sets, i.e., shadow member dataset and shadow non-member dataset, each of which contains 10,000 images. [each of which：其中的每一个] 9. 网络的描述： 1）We use a fully connected neural network with two hidden layers as our vector-based classifier. 2）We adopt the following default parameters for our method. 10. baseline 对比句式： 1）We compare our methods with the following five baseline methods … In this baseline method, we … 11. 表格内容描述： 1）Table 2, 5 (in Appendix), and 6 (in Appendix) show the accuracy, precision, and recall of our methods under the 8 different types of background knowledge for CIFAR10, STL-10, and Tiny-ImageNet datasets, 12. 图像内容描述 1）Figure 1b shows the impact of the number of augmented inputs 𝑛 on the accuracy of our methods for CIFAR10. 13. 曲线趋势描述： 1）Our results show that precision drops slightly as recall increases up to around 0.9, and then drops sharply as recall further increases. 14. 具体指标粗略描述 1）EncoderMI-V achieves higher accuracy as the inferrer has access to more background knowledge, and we have the same observation for EncoderMI-S and EncoderMI-T in most cases. 15. 具体指标细致描述 1）For instance, EncoderMI-V achieves 96.5% accuracy when the inferrer knows all the three dimensions of background knowledge while achieving 88.7% accuracy when the inferrer does not know any of them for Tiny-ImageNet dataset. 常用细节1. 在这项工作中：in this work；in our work；in our method 2. 常用动词（we为主语）： [判断]：decide；determine；judge；infer；consider；predict； **[证明]**：confirm； **[发现]**：find；perform；observe；note； **[提出]**：propose； **[展示]**：show； **[假设]**：assume； **[生成、得到]**：get；create **[进行、实施]**：do；conduct；process；implement **[作用、应用]**：apply；operate **[看待]**：treat；think；suspect(猜想) **[构建、构造]**：construct、build **[选择、选取]**：select、choose **[设置、设计]**：set、design **[对比、比较]**：compare、contrast **[表示、代表]**：denote、represent （attacker为主语）： **[查询、访问]**：query **[了解]**：know **[欺骗]**：cheat；deceive 3. 常用形容词： **[有效的]**：effective；efficient；valid **[足够的]**：sufficient；enough **[脆弱的]**：vulnerable 4. 常用连接词： **[粗略的说]**：roughly speaking；for simplicity **[通常来说]**：generally speaking **[特别地]**：in particular；particularly；specially **[例如]**：for example；for instance **[此外]**：moreover；in addition；besides **[因此]**：as a result；therefore **[默认情况下]**：by default 5. 测试常用词： close to：接近；around：接近；increases up：上升；drop：下降 the reason is that：理由是 be viewed as：被看作 to some extent：在一定程度下 respectively.：分别地 6. 一些简写 i.e. ：也就是、即； e.g. ：例如；s.t. ：使得","link":"/2022/12/23/%E8%AE%BA%E6%96%87%E5%B8%B8%E7%94%A8%E5%8F%A5%E5%BC%8F/"},{"title":"论文阅读笔记(Surfree)","text":"本篇文章为《Surfree: a fast surrogate-free black-box attack》(CVPR 2021) 阅读笔记。 该论文提出了一种新的对抗样本生成方法。与梯度无关，也不需要估计梯度，全靠理论推导，利用了决策边界的几何属性，在更少的查询量的条件下得到较好的对抗样本。 Surfree: a fast surrogate-free black-box attack (CVPR 2021) 该论文提出了一种新的对抗样本生成方法。与梯度无关，也不需要估计梯度，全靠理论推导，利用了决策边界的几何属性，在更少的查询量的条件下得到较好的对抗样本。 基本流程：首先构建超平面，通过旋转角度搜索更近的对抗样本，再通过二分法细化角度。如果第二步找不到更近的对抗样本，则重新采样方向构建另一个超平面去寻找。（见算法1） ①初始化：该算法需要一个初始化的点，通过目标攻击或非目标攻击生成对抗样本点。方法与我们的类似：nontarget：加噪，target：取对应数据集中的点，再二分法。 ②搜索新方向：第k次迭代中，原始样本和当前对抗样本连线向量u­k，使用DCT基产生一个伪随机向量tk，将tk与和uk前k-1次产生的方向做施密特正交化，正交后的方向向量为vk，即本次产生的新方向。（见算法2） ③搜索：在当前方向v**k和u­k所构成的平面内，由当前给定的最大角度θmax，乘以系数，来试探点Z*(θmax*T)是否为对抗样本（点Z*(θ)就是指与向量的角度为θ的处于该圆弧上的点，具体含义和内容见本论文，参考图2），一旦发现对抗样本图片搜索立即停止。否则缩小θmax重新生成一个vk进行上述搜索。（由于决策边界的法向量未知，则需要从大幅震荡使用+和-进行交替测试，碰到对抗性的样本就停止）；也可以0、θ*/2、θ*为节点，采用插值的方法估计最优θ；（参考图3） ④二分法搜索：找到角度θ以及符号后，用二分法搜索θ再细化t步，最后增大θmax。","link":"/2022/12/25/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-surfree/"},{"title":"论文阅读笔记(Dataset Inference)","text":"本篇文章为《DATASET INFERENCE: OWNERSHIP RESOLUTION IN MACHINE LEARNING 》(ICLR 2021) 阅读笔记。该论文提出了数据集推断的思想，通过训练数据集与测试数据集到决策边界距离的差异性，获取特征值，实现数据集推断。 《DATASET INFERENCE: OWNERSHIP RESOLUTION IN MACHINE LEARNING 》(ICLR 2021) 该论文提供了一种能与我们方法完全匹配的场景。需要通过计算点到决策边界的距离，进而进行特征值获取，实现数据集推断。因此需要生成离原始样本最近的对抗样本。而且此文章采用的黑盒方法过于简单，我们可以进行优化。 该文章主要思想：提出了数据集推断，用来进行模型的窃取攻击的防御，具体地，判断某一可疑模型是否使用了目标模型的部分隐私数据，来进行模型训练。 该文章具体步骤：（其中Embedding特征值的计算就是点到决策边界的距离计算） 1.将受害者的私有数据集和公有数据集进行标记：Sv-&gt;b=0; S-&gt;b=1 2.任取部分受害者的私有数据和公有数据，进行fv下Embedding特征值的计算。并将特征值作为输入x，对应的成员标签(b)作为y，训练回归模型gv(类似于成员推断攻击的二分类模型，只不过加了一个评分，同时修改了损失函数使得成员数据对应的评分小)。该回归模型gv的作用：给定一个样本在可疑模型 F 计算的特征值，模型输出一个概率(认为该条数据包含fv隐私信息的置信度) \\3. 进行假设检验HypothesisTesting。取m条受害者的私有数据和公有数据，计算可疑模型fA*下的Embedding特征值，并传入gv计算置信度，将m个数据的置信度构成向量c=(c0…cm)和cv。检验无效假设H0:μ&lt;μv，计算p值，通过设定阈值α，若p＜α，则H0被拒绝，模型被盗。 一些笔记： 一、模型窃取攻击的主要类型： 1.模型提取。对手利用对模型： (1.a)预测向量的访问(如API)，来重现模型的副本； (1.b)使用受害者模型作为标记预言，从初始未标记数据集上训练他们的模型。 2.访问用于训练受害者模型的数据集本身。并通过： (2.a)提取受害者模型； (2.b)从头训练来训练自己的模型。 3.对受害者模型的完全访问权，但不能访问数据集。 (3.a)对受害者模型进行微调， (3.b)采用受害者模型进行无数据蒸馏。","link":"/2022/12/25/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-dataset-inference/"},{"title":"论文阅读笔记(数据所有权系列)","text":"本篇文章为数据所有权相关的论文笔记。包括数据集的IP认证(Dataset Inference)，DL模型的IP认证(IPGuard)和DL模型的知识蒸馏(Knowledge Distillation)。我们系统的介绍了这三种方法，同时在理论基础、实现方法、实验环境、实验内容和实验结果等方面进行了对比。 Dataset Inference主要思想：提出了数据集推断，用来进行模型窃取攻击的防御，具体地，判断某一可疑模型是否使用了目标模型的部分隐私数据，来进行模型的训练。 具体步骤：（其中Embedding特征值的计算就是点到决策边界的距离计算） 1.将受害者的私有数据集和公有数据集进行标记：Sv-&gt;b=0; S-&gt;b=1 2.任取部分受害者的私有数据和公有数据，进行fv下Embedding特征值的计算。并将特征值作为输入x，对应的成员标签(b)作为y，训练回归模型gv(类似于成员推断攻击的二分类模型，只不过加了一个评分，同时修改了损失函数使得成员数据对应的评分小)。该回归模型gv的作用：给定一个样本在可疑模型 F 计算的特征值，模型输出一个概率(认为该条数据包含fv隐私信息的置信度) （Embedding特征值的计算：提出了白盒和黑盒两种，但不够精细化） 3.进行假设检验HypothesisTesting。取m条受害者的私有数据和公有数据，计算可疑模型fA*下的Embedding特征值，并传入gv计算置信度，将m个数据的置信度构成向量c=(c0…cm)和cv。检验无效假设H0:μ&lt;μv，计算p值，通过设定阈值α，若p＜α，则H0被拒绝，模型被盗。 实验环境： Datasets - Target Models CIFAR10 – WRD-28-10 CIFAR100 – WRD-28-10 攻击方式： ①模型提取，预测向量的访问；(Model exaction using unlabeled data and victim confidence) ②模型提取，仅使用标签；(Model exaction using unlabeled data and victim labels) ③访问数据集，提取受害者模型；(Data distillation) ④访问数据集，重新训练自己的模型；(Different model) ⑤对受害者模型进行微调；(Fine tuning) ⑥对受害者模型进行无数据蒸馏；(Data-free distillation/Zero shot learning) ⑦独立模型（对比实验）。(Train a teacher model on a separate dataset) 生成对抗样本的方式： ①White ②Black 评价指标： ①Δμ = μ – μv：置信度均值之差 ②p-value：无效假设H发生概率； 实验内容：（1 2为正文, 3 4 5为附录） 1.数据集推断整体性能评估：固定m，计算每种攻击下的Δμ和p-value值。 （攻击①-⑦; CIFAR10/CIFAR100; Black/White; m=10） 2.检验所需样本个数m对数据集推断的影响：改变m，计算p-value的变化。 （攻击①-⑥; CIFAR10/CIFAR100; Black/White; m=0-50） 3.生成距离特征size大小（也就是计算该点到几条决策边界的距离）对数据集推断的影响：改变Embedding Size，计算p-value的变化。（攻击①-⑥; CIFAR10/CIFAR100; Black; m=15/30/45/60/75/90） 4.补充了另外两个数据集（SVHN/Imagenet）的实验整体性能表：固定m，计算每种攻击下的Δμ和p-value值。（SVHN:攻击①-⑦; Imagenet:攻击③-④; Black; m=10） 5.双方私有数据集重叠对性能影响（作为一种新的攻击方式）：改变fraction overlap，计算p-value的变化。（SVHN; Black; m=10; fraction overlap=0.0/0.3/0.5/0.7/1.0） 整体性能： (实验1) CIFAR10-WRD-28-10 CIFAR100 – WRD-28-10 (实验4) ImageNet IPGuard主要思想：提出了IPGuard，用来保护深度网络的知识产权。具体地，判断某一可疑模型是否是目标模型的后处理版本（盗版）。 具体步骤：（其中footprint的生成就需要使用对抗样本技术） 1.取n个点，随机/就近取一条决策边界作为target label，采用优化方式生成对抗样本，将这些对抗样本（nearest samples）和他们对应的标签（target label）作为footprint； （优化方法为： ，需要白盒条件且不够精细化） 2.生成多种可疑模型，包括阳性（盗版）和阴性（正常）模型，将模型对nearest samples进行预测，与target label进行比较，计算匹配率。 实验环境： Datasets - Target Models CIFAR10 – ResNet20 CIFAR100 – WRN-22-4 Imagenet – ResNet50 攻击方式： 1.阳性模型 ①微调最后一层全连接层；(Fine-tune last layer) ②微调所有层；(Fine-tune all layer) ③重新训练最后一层；(Retrain last layer) ④重新训练所有层；(Retrain all layer) ⑤权重修剪；(Weight pruning) ⑥过滤器修剪；(Filter pruning) 2.阴性模型 ⑦同结构模型；（同结构不同初始化） ⑧不同结构模型； ⑨随机森林模型。 生成对抗样本的方式： ①初始化样本：随机/选训练集数据 ②找target label：随机/取最近的 ③对抗攻击：Random/FGSM/IGSM/CW/IPGuard 评价指标： ①匹配率：得到模型预测输出后，可疑模型预测数据点与目标分类器预测数据点标签匹配的分数。（阳性模型的分数高，阴性模型的分数低） ②ARUC：鲁棒性与唯一性曲线围成的面积。其中：阳性模型的匹配率代表鲁棒性，阴性模型的匹配率代表唯一性。 ③测试准确率：模型的测试准确率。 实验内容：（只有正文） 1.各种模型的测试准确率；（目标模型+可疑模型） 2.整体性能情况：所有情况下最优参数对应的ARUC的值； （CIFAR10/CIFAR100/ImageNet; Random/FGSM/IGSM/CW/IPGuard） 3.整体性能情况：各种攻击方式和各种对抗样本生成方式下，匹配率的值； （攻击①-⑨; CIFAR10/CIFAR100/ImageNet; FGSM/IGSM/CW/IPGuard） 4.FGSM、IGSM、CW对抗攻击中超参数对ARUC的影响。我们应该讨论我们方法超参数的影响； 5.不同数据集下，不同对抗攻击方法需要的时间； （Random/CIFAR10/CIFAR100/ImageNet; FGSM/IGSM/CW/IPGuard; n=100） 整体性能： （实验三） CIFAR10-ResNet20 CIFAR100-WRN-22-4 （实验三） ImageNet-ResNet50 （实验二）实验三是计算的匹配率，实验二是ARUC Knowledge Distillation主要思想：利用对抗性攻击来发现支持决策边界的样本，从而实现知识蒸馏。具体的，提出了一种对抗攻击方法（类似deepfool），在决策边界处得到对抗样本（BSSs），使得知识蒸馏后的模型决策边界能够接近原本的模型分类边界。 具体步骤：（其中BSSs的生成就需要使用对抗样本技术） 1.挑选N个原始点（base sample）以及对应的对抗标签（target label）。1）样本选择方法：选出能够被teacher和student均预测为该类的样本，个数为C，若C小于N，则用这C个样本，若C大于N，则在C中选出teacher与student预测概率相差最大的N个样本；2）标签选择方法：选取距离该样本最近的决策边界。 2.进行对抗攻击生成BSSs。方法为：优化损失函数，并进行更新，类似Deepfool。 其中b为原始class，k为目标class。 3.设计模型蒸馏损失函数，进行模型蒸馏，优化student。其中J为entropy function：J(a; b) =- aTlogb。 实验环境： Datasets – Target Models(Teacher) – Student CIFAR10 – ResNet26 – ResNet8 ResNet14 ResNet20 ImageNet – ResNet32 – ResNet8 Tiny ImageNet – ResNet42 – ResNet10 攻击方式： 知识蒸馏Knowledge distillation。 蒸馏方式：Proposed和FSP + Proposed，还有一些对比实验（Original/Hinton）。 生成对抗样本的方式： 见具体步骤1. 对抗攻击：Baseline/Random/noise L2 minimize/FGSM/DeepFool/Proposed 评价指标： ①测试准确率：模型的测试准确率。 ②蒸馏后得到的student的决策边界与teacher决策边界的相似度：MagSim和AngSim。 实验内容：（只有正文） 1.整体性能情况：不同方法蒸馏后的student测试准确率对比； （CIFAR10/ImageNet/Tiny; Proposed/FSP + Proposed；BSSs） 2.对抗样本对知识蒸馏的影响； （CIFAR10; Baseline/Random/noise L2 minimize/FGSM/DeepFool/Proposed） 3.不同方法下的相似度情况； （CIFAR10; DSSs; Original/Hinton/Proposed） 4.超参数的影响（选取样本个数、选取方式等）； 整体性能：","link":"/2022/12/25/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E6%89%80%E6%9C%89%E6%9D%83/"},{"title":"java基础（八）","text":"本系列主要进行java语言的介绍，其中本篇文章介绍java的高级特性——java反射机制。具体讲解java的反射概念和实现，以及反射的应用：动态代理设计模式。 java反射机制关于java.lang.Class的理解： 1.类的加载过程： 程序经过javac.exe命令（即编译）以后，会生成一个或多个字节码文件（.class结尾）； 接着我们用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例； 2.换句话说，Class的实例就对应着一个运行时类； 3.加载到内存的运行时类，会缓存一定时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。 获取Class实例的方式：123456789Class clazz1 = Person.class； //调用运行时类的属性：.classPerson p1 = new Person();Class clazz2 = p1.getClass(); //通过运行时类的对象，调用getClass()方法Class clazz3 = Class.forName(&quot;包名.Person&quot;); //调用Class的静态方法：forName(String classPath);ClassLoader classLoader = 文件名.class.getClassLoader();Class clazz4 = classLoader.loadClass(&quot;包名.Person&quot;); //使用类的加载器：ClassLoader，此方式了解即可 通过反射创建对应运行时类的对象：newInstance(): 调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器 要想此方法正常创建运行时类的对象，要求： 1.运行时类必须提供空参的构造器； 2.空参的构造器的访问权限得够。通常设置为public。 在javabean中要求提供一个public的空参构造器。原因： 1.便于通过反射，创建运行时类对象； 2.便于子类继承父类时，默认调用super()时，保证父类有此构造器。 12345678//例子：Class clazz = Person.class;Object obj = clazz.newInstance(); //obj即为Person类的对象//Person obj = (Person) clazz.newInstance(); //进行强转，结果一样//若添加泛型：Class&lt;Person&gt; clazz = Person.class;Person obj = clazz.newInstance(); //添加泛型后相当于得到的对象一定是Person类的 获取运行时类的属性、方法、构造器的结构：获取运行时类的属性结构： getFields()：获取当前运行时类及其所有父类中声明为public访问权限的属性； getDeclaredFields()：获取当前运行时类中声明的所有属性。（不包含父类中声明的属性）; 获取运行时类的方法结构： getMethods()：获取当前运行时类及其所有父类中声明为public访问权限的方法； getDeclaredMethods()：获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）; 获取构造器结构： getConstructors()：获取当前运行时类中声明public的构造器； getDeclaredConstructors()：获取当前运行时类中声明的所有构造器； 调用运行时类的属性、方法、构造器：如何操作运行时类中的指定的属性： 1234567891011121314151617181920Class clazz = Person.class;//创建运行时类的对象Person p = (Person) clazz.newInstance(); //p即为Person类的对象//1. 获取指定的属性//getDeclaredFields(String fieldname)：获取指定的属性//Field id = clazz.getFields(&quot;id&quot;); //getFields(String name)：只能获取public的属性，不采用Field name = clazz.getDeclaredFields(&quot;name&quot;); //2. 保证当前属性可访问name.setAccessible(true); //操作非public属性时需要添加，保证当前属性可访问//3. 设置当前属性的值//set()：参数1：指明设置哪个对象的属性；参数2：将此属性值设置为多少name.set(p, &quot;Tom&quot;); //4. 获取当前属性的值//get()：参数：获取哪个对象的属性值。注：正常为Object类型，为基本数据类型时，打印需要强转System.out.println(name.get(p)); 如何操作运行时类中的指定的方法： 12345678910111213141516171819Class clazz = Person.class;//创建运行时类的对象Person p = (Person) clazz.newInstance(); //p即为Person类的对象//1. 获取指定的某个方法//getDeclaredMethod()，参数1：指明获取的方法名称；参数2：指明获取方法的形参列表，因为可能会有多个同名方法Method show = clazz.getDeclaredMethod(&quot;show&quot;, String.class);//2. 保证当前方法可访问show.setAccessible(true); //3. 给指定的某个方法赋值//invoke()，参数1：方法的调用者；参数2：给方法形参赋值的实参//invoke()方法的返回值即为对应类中调用方法的返回值，若没有返回值，则返回nullObject returnValue = show.invoke(p, &quot;CHN&quot;); //类似于之前的String nation = p.show(&quot;CHN&quot;)System.out.println(returnValue); //注：若为静态方法，则invoke的第一个参数为Person.class，也可以写成None，因为加载时就知道静态方法；静态属性同理 如何操作运行时类中的指定的构造器：（使用较少） 1234567891011121314Class clazz = Person.class;//1.获取指定的构造器//getDeclaredConstructor()：参数：指明构造器的参数列表Constructor constructor = clazz.getDeclaredConstructor(String.class);//2.保证此构造器是可访问的constructor.getAccessible(true);//3.调用此构造器创建运行时类的对象Person per = (Person) constructor.newInstance(&quot;Tom&quot;); //默认为ObjectSystem.out.println(per); //注：上述是调用有参构造器时使用，并进行类的实例化；若调用无参构造器，采用Person p = (Person) clazz.newInstance()即可。 反射的应用：动态代理– 特别重要 Spring的底层用的就是这个 代理设计模式的原理： 使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 之前为大家讲解过代理机制的操作，属于静态代理，特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最好可以通过一个代理类完成全部的代理功能； 动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。动态代理使用场合：1.调试；2.远程方法调用； 动态代理相比于静态代理的优点：抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。 动态代理举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/**对于动态代理，对于代理模式，需要有接口、被代理类、代理类。代理类要改成动态**///定义接口 -- 即一种规范interface Human{ String getBelief; void eat(String food);}//被代理类 -- 实现该接口class SuperMan implements Human(){ @Override public String getBelief(){ return &quot;I believe I can fly!&quot;; } @Override public void eat(String food){ System.out.println(&quot;我喜欢吃&quot;+food); }}/*要想实现动态代理，要解决两个问题：问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象；问题二：当通过代理类的对象调用方法时，如何动态的去调用被代理类中的同名方法。*///动态创建一个与被代理类实现接口一样的类，代理对被代理类的执行；//这个类不是具体的一个类，是会根据具体的对象变化的类；如果是具体的类，就变成了静态代理//生成一个代理工厂，用于动态的生成代理类class ProxyFactor{ //调用此方法，返回一个代理类的对象，解决问题一 public static Object getProxyInstance(Object obj){ //obj为被代理类的对象 //采用反射中的Proxy类，构建一个代理的实例 //要求体现在三个参数中：与被代理类加载器一致，与被代理类的实现接口一致，动态的调用方法 MyInvocationHandler handler = new MyInvocationHandler(); handler.bind(obj); //传入被代理类的对象 return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler); }}//实现动态性class MyInvocationHandler implements InvocationHandler{ private Object obj; //需要使用被代理类的对象进行赋值 //对obj对象进行赋值 public void bind(Object obj){ this.obj = obj; } //作用：当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke() //将被代理类要执行的方法a的功能就声明在invoke()中 @override public Object invoke(Object proxy, Method method, Object[] args){ //method：即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法 //obj：被代理类的对象 Object returnValue = method.invoke(obj, args); //上述方法的返回值，就作为当前类中invoke()方法的返回值 return returnValue; }}//主测试类public class ProxyTest { public static void main(String[] args){ //1.创建被代理类对象 SuperMan superMan = new SuperMan(); //2.创建代理类对象proxyInstance Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan); //返回值是Object，但实际上是Human //3.实现方法，实际上自动调用了代理类的invoke方法 //其中三个参数值分别为：(Object proxy：代理类对象proxyInstance；Method method：调用方法getBelief；Object[] args：方法实参null/&quot;四川麻辣烫&quot;) //即：当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法 //这两个方法实际上是被代理类SuperMan的方法，而我们通过代理类来调用，但又找不到具体的代理类（即代理类的对象没有显式创建），因此实现了动态代理 String belief = proxyInstance.getBelief(); proxyInstance.eat(&quot;四川麻辣烫&quot;); //因此：只需要提供被代理类（如SuperMan）和被代理类实现的接口（如Human），会自动的生成代理类对象（proxyInstance），去代理实现被代理类中的方法。 }}","link":"/2023/01/19/java%E5%9F%BA%E7%A1%80%E5%85%AB/"},{"title":"java基础（七）","text":"本系列主要进行java语言的介绍，其中本篇文章介绍java的高级特性——网络编程。计算机网络是指把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便的相互传递信息、共享硬件、软件、数据信息等资源。而网络编程的目的是直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。 本篇文章会从通信的两大要素：IP和端口号、网络协议的方面进行java网络编程的介绍。 网络编程计算机网络：把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便的相互传递信息、共享硬件、软件、数据信息等资源。 网络编程的目的：直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。 通信要素一：IP和端口号 IP：唯一的表示Internet上的计算机（通信实体）； 在JAVA中使用InetAddress类代表IP； IP 分类：IPv4 和 IPv6；万维网 和 局域网； 域名：www.baidu.com…； 本地回路地址：127.0.0.1 ，对应着localhost。 举例 IP 地址的实例化： 123InetAddress inet1 = InetAddress.getByName(&quot;192.168.10.14&quot;);InetAddress inet2 = InetAddress.getByName(&quot;www.baidu.com&quot;);InetAddress inet3 = InetAddress.getLocalHost(); 端口号：标识正在计算机上运行的进程；不同的进程有不同的端口号； 端口号被规定为一个16位整数0~65535； 端口号与 IP 地址的组合得出一个Socket套接字。 通信要素二：网络通信协议网络通信协议：计算机网络中实现通信必须有一些约定，即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等指定标准。 TCP 和 UDP： TCP协议: 使用TCP协议前，须先建立TCP连接，形成传输数据通道； 传输前，采用“三次握手”方式，点对点通信，是可靠的； TCP协议进行通信的两个应用进程:客户端、服务端； 在连接中可进行大数据量的传输； 传输完毕，需释放已建立的连接（“四次挥手”），效率低。 UDP协议: 将数据、源、目的封装成数据包，不需要建立连接； 每个数据报的大小限制在64K内； 发送不管对方是否准备好，接收方收到也不确认，故是不可靠的； 可以广播发送； 发送数据结束时无需释放资源，开销小，速度快。 TCP生活案例：打电话；UDP案例：发短信、发电报。 TCP的三次握手和四次挥手： 实现TCP的网络编程： 例子：客户端发送信息给服务端，服务端将数据显示在控制台上 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//客户端public void client() throws IOException{ //1.创建Socket对象，指明服务器端的ip和端口号 InetAddress inet = InetAddress.getByName(&quot;127.0.0.1&quot;); //为**服务端**的端口号 Socket socket = ne w Socket(inet, 8899); //创建socket ip+端口号 //2.获取一个输出流，用于输出数据 OutputStream os = socket.getOutputStream(); //3.写出数据的操作 os.write(&quot;你好，我是客户端&quot;.getBytes()); //4.资源的关闭 os.close(); socket.close()} //服务端public void server() throws IOException{ //1.创建服务器端的Socket对象，指明自己的端口号 ServerSocket ss = new Socket(8899); //创建socket ip(用服务端自己的ip)+端口号 //2.调用accept方法，表示接收来自于客户端的socket Socket socket = ss.accept(); //3.获取输入流 InputStream is = socket.getInputStream(); //4.读取输入流中的数据 //使用ByteArrayOutputStream类进行读取，避免采用String方式直接读取出现字符的乱码情况 ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer = new byte[5]; int len; while((len = is.read(buffer)) != -1)){ baos.write(buffer, 0, len); //String str = new String(buffer, 0, len); //System.out.println(str); } System.out.Println(baos.toString()); //显示内容 //5.资源关闭 baos.close(); is.close(); socket.close(); ss.close();} 注意：1. 上述代码的异常需要用try-catch-finally处理，类似于之前的IO编程； ​ 2. 运行时需要先启动服务端，再运行客户端去连接； ​ 3. 客户端与服务端的连接除了自定义的方式，还可以采用浏览器+Tomcat服务器的方式实现，javaweb中用得多。（如自己git bash中hexo server中的 localhost:4000 网站，即为此方式实现的） 实现UDP的网络编程： 12345678910111213141516171819202122232425262728293031323334//发送端public void sender() throws IOException{ //1.创建socket对象 DatagramSocket socket = new DatagramSocket(); //2.设置要发送的数据报 String str = &quot;我是UDP方式发送的数据&quot;; byte[] data = str.getBytes(); //转化为字节数据 InetAddress inet = InetAddress.getByName(&quot;127.0.0.1&quot;); DatagramPacket packet = new DatagramPacket(data, 0, data.length, inet, 9090); //为接收端的ip和端口号 //3.发送数据 socket.send(packet); //4.资源关闭 socket.close();}//接收端public void receiver() throws IOException{ //1.创建socket对象 DatagramSocket socket = new DatagramSocket(9090); //2.设置要接收的数据报 byte[] buffer = new buffer[100]; DatagramPacket packet = new DatagramPacket(data, 0, buffer.length); // 自己的ip和端口号就不用写了 //3.接收数据报 socket.receive(packet); System.out.Println(new String(packet.getData(), 0, packet.getLength())); //显示内容 //4.资源关闭 socket.close();} URL网络编程 URL(Uniform Resource Locator)：统一资源定位符，它表示Internet上某一资源的地址； 它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源； 通过URL我们可以访问Internet上的各种网络资源，比如最常见的 www，ftp站点。浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源； URL的基本结构由5部分组成： &lt;传输协议&gt;:/&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表&gt; 例如：http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123 参数列表格式：参数名=参数值&amp;参数名=参数值… 例子：用URL类实现Tomcat服务器上的图片下载，并保存到本地。 123456789101112131415161718192021//1.配置urlURL url= new URL(&quot;http://localhost:8000/examples/beauty.jpg&quot;);HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();urlConnection.connect();//2.配置流InputStream is = urlConnection.getInputStream(); //输入流：从Tombat服务器中输入FileOutputStream fos = new FileOutputStream(&quot;beauty1.jpg&quot;); //输出流：保存为本地文件//3.进行读取和写入byte[] buffer = new byte[1024];int len;while((len = is.read()) != -1){ fos.write(buffer, 0, len);}System.out.println(&quot;下载完成！&quot;);//4.关闭资源is.close();fos.close();urlConnecton.disconnect();","link":"/2023/01/19/java%E5%9F%BA%E7%A1%80%E4%B8%83/"},{"title":"JDBC","text":"本篇文章介绍JDBC的相关内容。SUN公司为了简化开发人员的（对数据库的统一）操作，提供了一个（Java操作数据库的）规范，俗称JDBC。这些规范的实现由具体的厂商去做；而对于开发人员来说，我们只需要掌握JDBC接口的操作即可。具体实现时，需要在java中导入mysql-connector-java.jar包，同时需要使用java.sql和javas.sql。 JDBC，数据库，java程序的关系 JDBC程序的例子1234567891011121314151617181920212223242526272829303132333435public static void main(String[] args) throws ClassNotFoundException，SQLException { //1．加载驱动 class.forName(&quot;com.mysql.jdbc.Driver&quot;);//固定写法，加载驱动 //2. 用户信息和url //useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true String url = &quot;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&quot;; String username = &quot;root&quot;; String password = &quot;123456&quot;; //3. 连接成功,数据库对象Connection代表数据库 Connection connection = DriverManager.getConnection(url，username，password); //4. 执行SQL的对象 Statement 执行sql的对象 Statement statement = connection.createStatement(); //5. 执行SQL的对象去执行SQL，可能存在结果，查看返回结果 String sql = &quot;SELECT * FROM users&quot;; //要执行的SQL语句 //返回的结果集，结果集中封装了我们全部的查询出来的结果 ResultSet resultSet = statement.executeQuery(sql); while (resultSet.next()){ //以链表形式存放 System.out.println(&quot;id=&quot;+resultSet.getObject(columnLabel: &quot;id&quot;)); System.out.println(&quot;name=&quot;+resultSet.getObject(columnLabel: &quot;NAME&quot;)); System.out.println(&quot;pwd=&quot;+resultSet.getObject(columnLabel: &quot;PASSWORD&quot;)); System.out.println(&quot;email=&quot;+resultSet.getObject(columnLabel: &quot;email&quot;)); System.out.println(&quot;birth=&quot;+resultSet.getObject(columnLabel: &quot;birthday&quot;)); } //6. 释放连接 resultSet.close(); statement.close(); connection.close();//耗资源，用完关掉！} statement对象JDBC中的statement对象用于向数据库发送SQL语句，想完成对数据库的增删改查，只需要通过这个对象向数据库发送增删改查语句即可。 Statement对象的executeUpdate方法，用于向数据库发送增、删、改的sql语句，executeUpdate执行完后，将会返回一个整数（即增删改语句导致了数据库几行数据发生了变化）。 Statement.executeQuery方法用于向数据库发送查询语句，executeQuery方法返回代表查询结果的ResultSet对象。 PrepareStatement对象此外，可以用PrepareStatement代替Statement，来防止SQL注入的问题。 具体方法：将sql语句中的值用？代替，再用set方法进行赋值。 PrepareStatement能够防止SQL注入的本质，把传递进来的参数当作字符，假设其中存在转义字符，则会直接转义，如 ‘ 。 1234567-- PrepareStatement对象使用方法conn = DriverManager.getConnection(url，username，password);string sql = &quot;select * from users where `NAME`=? and `PASSWORD`=?&quot;;st = conn.prepareStatement(sql);st.setString(parameterlndex: 1,username);st.setString(parameterlndex: 2,password); 事务的JDBC实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static void main (string[] args） { connection conn = null; PreparedStatement st = null; ResultSet rs = null; try { // ------------数据库配置------------ //加载驱动 class.forName(&quot;com.mysql.jdbc.Driver&quot;);//固定写法，加载驱动 //用户信息和url //useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true String url = &quot;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&quot;; String username = &quot;root&quot;; String password = &quot;123456&quot;; //连接成功，数据库对象Connection代表数据库 conn = DriverManager.getConnection(url，username，password); // -----------事务配置----------- //1. 关闭数据库的自动提交，自动会开启事务 conn.setAutocommit(false)；//开启事务 //2. 设置事务内容 String sql1 = &quot;update account set money = money-100 where name = 'A'&quot;; st = conn. prepareStatement(sql1); st.executeUpdate(); int x = 1/0; //报错，如果报错，即会回滚，即sql1和sql2都无法实现 String sql2 = &quot;update account set money = money+100 where name = 'B '&quot;; st = conn.prepareStatement(sql2); st.executeUpdate(); //3. 业务完毕，提交事务 conn.commit(); system.out.println(&quot;成功!&quot;); } catch (SQLException e) { //如果失败，则默认回滚 //try { //conn.rollback(); //如果失败则回滚事务 //} catch (SQLException e1) { //e1.printStackTrace();} e.printStackTrace(); } finally{ // 关闭资源，此处省略了异常处理，实际上需要进行异常处理，如if re!=null:.... re.close(); st.close(); conn.close(); }}","link":"/2023/01/25/JDBC/"},{"title":"MySQL学习（一）","text":"本系列主要进行MySQL数据库的学习介绍，其中本篇文章介绍MySQL的一些基本概念和基本操作，包括初识数据库，基本的命令行操作，和对数据库的部分操作（数据库的创建、表的创建）等。 初识MySQL什么是数据库数据库（DB, DataBase） 概念：数据仓库，软件，安装在操作系统（Windows, Linux, Mac…）之上！使用SQL语句，可以存储大量的数据； 作用：存储数据，管理数据。 数据库分类关系型数据库：（SQL） Mysql, Oracle, Sql, Server, DB2…； 通过表和表之间，行和列之间的关系进行数据的存储；（学院信息表，考勤表…） 非关系型数据库：（NoSQL） Not Only Redis, MongDB； 非关系型数据库，对象存储，通过对象的自身的属性来决定。 DBMS（数据库管理系统） 数据库的管理软件，科学有效的管理我们的数据，维护和获取数据； MySQL本质上是一个数据库管理系统。 sqlyog的使用创建数据库：选择字符集character为utf8，排列规则collate为utf8_general_ci； 每一个sqlyog的执行操作，本质就是对应了一个sql，可以在软件的历史记录中查看。 基本的命令行操作123456789101112131415161718192021222324252627mysql -uroot -p123456 --连接数据库update mysql.user set authentication_string=password('123456') where user='root' and Host='localhost'; -- 修改密码flush privileges; -- 刷新权限------------------------------------------------------------------------------------- 所有的语句都使用；结尾show databases; -- 查看所有数据库use school; -- 切换数据库 use+数据库名show tables; -- 查看数据库中的所有的表describe student; -- 显示数据库中表的信息 describe+表名create database westos; -- 创建一个数据库 create database+数据库名exit; -- 退出连接-- 单行注释 （SQL本来的注释）/* （SQL的多行注释）helloasdas*/ 数据库xxx语言（CURD增删改查）：DDL 定义；DML 操作；DQL 查询；DCL控制 操作数据库操作数据库 &gt; 操作数据库中的表 &gt; 操作数据库中表的数据 ==MySQL中的关键字不分大小写== 操作数据库（了解）1. 创建数据库 CREATE DATABASE [IF NOT EXISTS] westros; 2.添加数据库 DROP DATABASE [IF EXISTS] westros; 3.删除数据库 – 如果表名或字段名是一个特殊字符，就需要带 USE school; 4.查看数据库 SHOW DATABASES; 数据库的列类型（了解）数值： tinyint 十分小的数据 1个字节 smallint 较小的数据 2个字节 mediumint 中等大小的数据 3个字节 int 标准的整数 4个字节 常用 对应java的int bigint 较大的数据 8个字节 float 浮点数 4个字节 double 浮点数 8个字节 decimal 字符串形式的浮点数 金融计算的时候一般使用 字符串： char 字符串，固定大小 0-255 varchar 可变字符串 0-65535 常用 对应java的String tinytext 微型文本 2^8-1 text 文本串 2^16-1 保存大文本 时间日期： data YYYY-MM-DD 日期格式 time HH:mm:ss 时间格式 datetime YYYY-MM-DD HH:mm:ss 最常用的时间格式 timestamp 时间戳，1970.1.1到现在的毫秒数，也较为常用 year 年份表示 null： 没有值，未知 注意：不要使用null进行运算，结果为null 数据库的字段属性（重点）Unsigned: 无符号的整数； 声明了该列不能声明为负数 zerofill： 0填充的； 不足的位数，使用0来填充。如int(3)：5…005 自增： 自动在上一条记录中加一（默认）； 通常用来设置唯一的主键——index，必须是整数类型； 可自定义设计主键自增的起始值和步长。 非空 null / not null： 假设设置为not null ，如果不给它赋值，就会报错； null，如果不填写值，默认就是null 默认： 设置默认的值； 如：sex，默认值为男，如果不指定该列的值，则会有默认的值 拓展： 每一个表，都必须存在以下五个字段。未来做项目用的，表示一个记录存在意义。 id：主键；version：乐观锁；is_delete：伪删除；gmt_create：创建时间；gmt_update：修改时间 创建数据库表（重点）例子：创建一个表student，包含id，名称，性别等字段 12345678910111213141516-- 通常字段都加上``，避免出现特殊字符-- 表名后用英文括号()-- 字符串用单引号括起来-- 表中所有语句后面加英文逗号，最后一个不用加-- AUTO_INCREMENT自增-- PRIMARY KEY 主键，一般一个表只有一个唯一的主键CREATE TABLE IF NOT EXISTS `student`(`id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '学号',`name` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '姓名',`password` VARCHAR(20) DEFAULT '123456' COMMENT '密码',`sex` VARCHAR(2) NOT NULL DEFAULT '女' COMMENT '性别',`birthday` DATETIME DEFAULT NULL COMMENT '出生日期',PRIMARY KEY(`id`) )ENGINE=INNODB DEFAULT CHARSET=utf8`student` 格式： CREATE TABLE [IF NOT EXISTS] 表名 ( 字段名 列类型 [属性] [索引] [注释], 字段名 列类型 [属性] [索引] [注释], …… 字段名 列类型 [属性] [索引] [注释] )[表类型] [字符集设置] [注释] 查看创建数据库的语句：SHOW CREATE DATABASE school 查看数据表的定义语句：SHOW CREATE TABLE student 不会写的时候可以用来看代码。 显示表的结构：DESC student 数据表的类型关于数据库引擎： INNODB：默认使用。安全性高，事物的处理强，支持多表多用户操作； MYISAM：早些年使用。节约空间，速度较快。 在物理空间的位置： 所有的数据库均存在data文件夹中，本质还是文件的存储。 数据库引擎在物理文件上的区别： INNODB在数据库表中只有一个*.frm文件，以及上级目录下的ibdata1文件； MYISAM对应的文件有：*.frm –表结构定义文件；*.MYD –数据文件；*.MYI –索引文件 修改和删除数据库表123456789101112131415161718192021-- **修改表的字段：**-- 修改表名：ALTER TABLE 旧表名 RENAME AS 新表名ALTER TABLE teacher RENAME AS teacher1-- 增加表的字段 ALTER TABLE 表明 ADD 字段名 列属性ALTER TABLE teacher1 ADD age INT(11)-- 修改表的字段（重命名，修改约束）-- ALTER TABLE 表名 MODIFY 字段名 列属性ALTER TABLE teacher1 MODIFY age VARCHAR(11) -- 修改约束，用MODIFY-- ALTER TABLE 表名 CHANGE 旧名字 新名字 列属性ALTER TABLE teacher1 CHANGR age age1 INT(1) -- 字段重命名，用CHANGE-- **删除表的字段：**-- ALTER TABLE 表名 DROP 要删除的字段ALTER TABLE teacher1 DROP age1 --DROP用来删除**删除表：（如果表存在）**DROP TABLE IF EXISTS teacher1 注：所有的创建和删除操作尽量加上判断，以免报错","link":"/2023/01/25/MySQL%E4%B8%80/"},{"title":"MySQL学习（三）","text":"本系列主要进行MySQL数据库的学习介绍，其中本篇文章介绍MySQL的其它概念，包括事务，索引，权限管理和备份，规范数据库设计等。 事务什么是事务：要么都成功，要么都失败 将一组SQL放在一个批次中执行 事务原则：ACID原子性，一致性，隔离性，持久性 原子性：这些步骤要么一起成功，要么一起失败，不能只发生一个动作。例子：A和B转账； 一致性：事务在完成后，符合逻辑运算；即事务前后的数据完整性要保持一致； 持久性：事务没有提交，恢复到原状；事务已经提交，持久化数据库。即事务结束后的数据不随着外界原因导致数据丢失； 隔离性：多个用户并发访问数据库时，数据库为每一个用户开启的服务，不能被其它事务的操作数据所干扰；即事务之间要相互隔离。 未正常隔离的话，会导致一些问题： 脏读：事务同时进行，其中一个事务读取到另外一个事务还没有提交的数据； 不可重复读：在一个事务内读取表的某一行数据，多次读取结果不同。（这个不一定是错误，只是某些场合不对）； 虚读（幻读）：是指在一个事务内读取到了别的事物插入的数据，导致前后读取不一致。 123456789101112131415161718192021222324252627282930-- ------------------------------事务例子-------------------------------------SET autocommit = 0 -- 关闭SET autocommit = 1 -- 开启（默认的）-- 手动处理事务SET autocommit = 0 -- 关闭自动提交-- 事务开启START TRANSACTION -- 标记一个事务的开始，从这个之后的sql都在同一个事务内-- 要执行的一组事务INSERT XXXINSERT XXXUPDATE XXX-- .....-- 提交：持久化COMMIT-- 回滚：回到原来的样子ROLLBACK-- 事务结束SET autocommit = 1 -- 开启自动提交-- 设置保存点（了解） 可选SAVEPOINT 保存点名 -- 设置一个事务的保存点ROLLBACK TO SAVEPOINT 保存点名 -- 回滚到保存点RELEASE SAVEPOINT 保存点名 -- 撤销保存点 索引MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。 索引的分类： 在一个表中，主键索引只能有一个，而唯一索引可以有多个 主键索引（PRIMARY KEY） 唯一标识：主键不可重复，只能有一个列作为主键 唯一索引（UNIQUE KEY） 避免重复的列出现，唯一索引可以重复，多个列都可以标识为唯一索引 常规索引（KEY/INDEX） 默认的，可以用index或key关键字来设置 全文索引（FULLTEXT） 在特定的数据引擎下才有，MyISAM； 快速定位数据。 12345678910111213141516171819202122232425262728293031323334353637383940-- ------------------------------索引例子--------------------------------------- 1.创建表时增加索引-- 2.创建完毕后，增加索引-- 显示所有的索引信息SHOW INDEX FROM student-- 增加一个索引，此处增加全文索引 4式：索引名（列名）ALTER TABLE student ADD FULLTEXT INDEX `studentname`(`studentname`)-- 分析sql执行的状况 EXPLAINEXPLAIN SELECT * FROM student -- 非全文索引SELECT * FROM student WHERE MATCH(`studentname`) AGAINST('张') -- 全文索引-- 测试索引-- sql也可以用来编程-- 插入100万条数据DELIMITER $$ -- 写函数之前必须要写，当作标志CREATE FUNCTION mock_data()RETURN INTBEGIN -- 函数体 DECLARE num INT DEFAULT 1000000; DECLARE i INT DEFAULT 0; WHILE i&lt;num DO -- 插入语句 INSERT ... SET i = i+1; END WHILEEND;-- 创建一个索引-- 命名方式：CREATE INDEX 索引名 on 表(字段)CREATE INDEX id_student_phone ON student(`phone`)-- 进行查询，当数据量很大时索引能够提升很大的性能-- 因为创建索引时内部为一个树结构，能够很快实现遍历SELECT * FROM student WHERE `phone`='13800002222' 总结：索引在小数据量的时候，用处不大；但是在大数据的时候，区别十分明显。 索引原则： 索引不是越多越好； 不要对经常变动的数据增加索引； 小数据量的表不需要加索引； 索引一般加在常用来查询的字段上。 索引的数据结构： Hash 类型的索引 Btree：Innodb默认的数据结构 权限管理和备份用户管理123456789101112131415161718192021222324-- ---------------------------数据库用户管理---------------------------------- 创建用户 CREATE USER 用户名 identified BY '密码'CREATE USER tzh666 IDENTIFIED BY '123456'-- 修改当前用户密码SET PASSWORD = PASSWORD('123456')-- 修改指定用户密码SET PASSWORD FOR tzh666 = PASSWORD('111111')-- 重命名： 原名字 to 新名字RENAME USER tzh666 TO tianzehao-- 用户授权 ALL PRIVILEGES: 全部权限，库，表-- ALL PRIVILEGES：除了GRANT其它都有，即不能给别的用户授权GRANT ALL PRIVILEGES ON *.* TO tianzehao-- 查看指定用户的权限SHOW GRANTS FOR tianzehao SHOW GRANTS FOR root@localhost -- 撤销权限 REVOKE 哪些权限，在哪个库撤销，给谁撤销REVOKE ALL PRIVILEGES ON *.* FROM tianzehao 数据库备份为什么要备份： 保证重要的数据不丢失； 数据转移 MySQL数据库备份的方式： 直接拷贝物理文件； 在Sqlyog这种可视化工具中手动导出； 使用命令行导出 mysqldump命令行使用。 导出一张表：mysqldump -h主机 -u用户名 -p 密码 数据库 表名 &gt; 物理磁盘位置； 导出多张表：mysqldump -h主机 -u用户名 -p 密码 数据库 表1 表2 表3 &gt; 物理磁盘位置； 导入数据库所有文件：mysqldump -h主机 -u用户名 -p 密码 数据库 &gt; 物理磁盘位置； 命令行导入：登录的情况下，切换到指定的数据库。具体方法：source 备份文件路径 规范数据库设计为什么要进行数据库设计当数据库比较复杂时，就需要设计了。 糟糕的数据库设计： 数据冗余，浪费空间； 数据库的插入和删除都会麻烦、异常（屏蔽使用物理外键）； 程序的性能差。 良好的数据设计： 节省内存空间； 保证数据库的完整性； 方便我们开发系统。 软件开发中，关于数据库的设计： 分析需求：分析业务和需要处理的数据库的需求； 概要设计：设计关系图 E-R图。 数据库设计三大范式为什么要进行数据规范化： 信息重复，更新异常，插入异常，删除异常 第一范式（1NF）： 要求数据库表的每一列都是不可分割的原子数据项。 原子性：保证每一列不可再分。 第二范式（2NF）： 前提：满足第一范式 确保数据库表的每一列都和主键相关，而不能值与主键的某一部分相关。即每张表只描述一件事情。 第三范式（3NF）： 前提：满足第二范式 确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 规范性和性能的问题： 阿里的规范：关联查询的表不得超过三张表 考虑商业化的需求和目标，（成本，用户体验）数据库的性能更加重要； 在规范性能的问题的时候，需要适当的考虑一下规范性； 故意给某些表增加一些冗余的字段（从多表查询中变为单表查询）； 故意增加一些计算列（从大数据量降低为小数据量的查询）","link":"/2023/01/25/MySQL%E4%B8%89/"},{"title":"MySQL学习（二）","text":"本系列主要进行MySQL数据库的学习介绍，其中本篇文章介绍MySQL的数据管理，包括外键的介绍、数据库操作语言（DML），数据查询语言（DQL）等。 MySQL数据管理外键（了解）不采用物理外键，避免数据库过多造成困扰，因此不建议使用。 最佳实现方案： 数据库就是单纯的表，只有行（数据）和列（字段）； 我们想使用多张表的数据，想使用外键，采用程序去实现。 DML语言（全部记住）DML语言：数据操作语言 1. 添加INSERT： 12345678910-- 插入语句-- INSERT INTO 表名(字段名1, 字段名2, 字段名3) values ('值1', '值2', '值3', ...)-- 由于主键自增，我们可以省略 -- 如果不写表的字段，则会一一匹配；因此一般写插入语句，一定要数据和字段一一对应INSERT INTO`student`(`name`, `password`, `sex`) VALUES ('张三', '111111', '男')-- 插入多条语句-- INSERT INTO 表名(字段名1, 字段名2, 字段名3) values ('值1', '值2', '值3'), ('值1', '值2', '值3')INSERT INTO `student`(`name`) VALUES ('王五'), ('李四') 语法：INSERT INTO 表名(字段名1, 字段名2, 字段名3) values (‘值1’, ‘值2’, ‘值3’, …) 注意： 字段和字段之间用英文逗号隔开； 字段是可以省略的，但字段和值要一一对应，且不能少； 可以同时插入多条数据，但values后面的值需要英文逗号隔开。 2. 修改UPDATE： 123456789-- 修改学员名字UPDATE `student` SET `name`='狂神' WHERE `id`=3-- 不指定条件的话，会改动所有表UPDATE `student` SET `name`='长江7号'-- 修改多个属性，逗号隔开UPDATE `student` SET `name`='狂神', `password`='123456' WHERE `id`=3 语法：UPDATE 表名 SET column_name=value, [column_name=value…] WHERE [条件] （column_name=value, [column_name=value…]表明要修改的字段和要修改的值，可以一次修改多个字段） 条件语句：where 子句 ； 子句包括：运算符，id等于某个值/大于/某个区间，如：id&lt;5，id between 2 and 5(闭合), id=2 or id=5, `name`=’张三’ and `sex`=`女` 注意： column_name是数据库的列，尽量带上 ； value可以是一个值，也可以是一个变量； 条件语句用于筛选，如果没有条件语句，则会筛选所有的列； 多个设置的属性之间，使用英文逗号隔开。 3. 删除DELETE： 语法：DELETE FROM 表名 WHERE [条件] 清空数据表： TRUNCATE 表名：完全清空一个数据库表，表的结构和索引约束不会变 TRUNCATE和DELETE相同点：都能删除数据，都不会改变表的结构； TRUNCATE和DELETE不同点： TRUNCATE会重新设置，自增列、计数器会归零；不会影响事务 DELETE不会重新设置，不会影响自增； 了解即可（采用DELETE删除）：重启数据库，现象： lnnoDB引擎：自增列会从1开始(存在内存当中的，断电即失)； MylSAM引擎：继续从上一个自增量开始(存在文件中的，不会丢失) 4. 了解：MD5加密 在插入或更新时进行，如： INSERT INTO`student`(`name`,`password`, `sex`) VALUES (‘张三’, MD5(‘111111’), ‘男’) 如何校验： 将用户传递进来的密码，进行md5加密，然后对比加密后的值，如： SELECT * FROM `student` WHERE `name`=’张三’ and `password`=MD5(‘111111’) DQL查询数据（最重点） 注：顺序很重要 DQL：Data Query Language 数据查询语言 所有的查询都要用它 Select； 简单的查询，复杂的查询都能做； 数据库中最核心的语言，最重要的语句，使用频率最高的语句。 指定查询字段123456789101112-- 查询全部的学生 SELECT 字段 FROM 表SELECT * FROM student-- 查询指定字段SELECT `StudentNo`, `StudentName` FROM student -- 别名 给结果起一个名字 AS 可以给字段起别名，也可以给表起别名SELECT `StudentNo` AS 学号, `StudentName` AS 学生姓名 FROM student-- 函数 Concat(a,b) 连接字符串SELECT CONCAT('姓名：', StudentName) AS 新名字 FROM student 语法：SELECT 字段…. FROM 表名 有的时候，列名字不是那么的见名知意，可以起别名。语法：字段名/表名 AS 别名 去重：DISTINCT 作用：去除SELECT语句查询出来的结果中重复的数据，重复的数据只显示一条 12SELECT DISTINCT `StudentNo` FROM result -- 查询有哪些同学参加了考试，去重 数据库的列（表达式）： 1234567SELECT VERSION() -- 查询系统版本（函数）SELECT 100*3-1 AS 计算结果 -- 用来计算（表达式）SELECT @@auto_increment_increment -- 查询自增的步长（变量）-- 学员考试成绩+1分 查看SELECT `StudentNo`, `StudentResult`+1 AS '提分后' FROM result 数据库中的表达式：文本值，列，函数，null，计算表达式，系统变量… SELECT 查询表达式语法：SELECT 表达式 FROM 表 where条件子句作用：检索数据中符合条件的值。 搜索的条件由一个或多个表达式构成，返回值为布尔类型。 逻辑运算符：and(&amp;&amp;) or(||) not(!) 尽量使用英文； 模糊查询：比较运算符 is null – 如果操作符为null，结果为真； is not null – 如果操作符不为null，结果为真； between a and b – 如果值在a和b之间，结果为真； a like b – SQL匹配，如果a匹配b，则结果为真；like可以与%，_等符号结合（见例子）； a in (a1, a2..) – 假设a在a1，或者a2…中，则结果为真；in后面为具体的一个或多个值。 例子：– where的使用 1234567-- 查询考试成绩在95~100分之间的学生SELECT `StudentNo`, `StudentResult` FROM result WHERE `StudentResult`&gt;=95 AND `StudentResult`&lt;=100-- 查询姓张的同学-- like结合 %（代表0到任意个字符） _（一个字符） 类似与正则表达式SELECT `studentno`, `studentname` FROM `student` WHERE `studentname` LIKE '张%' 联表查询 JOIN … ON…例子：联表查询 多个表一起 JOIN 1234567891011121314151617181920212223242526272829-- 查询参加了考试的同学（学号，姓名，科目编号，分数）/* 思路：1.分析需求，分析查询的字段来自哪些表--student和result2.确定使用那种连接查询--七种3.确定交叉点（两个表中哪些数据是相同的）--studentno判断条件：student表中的studentno = result表中的studentno*/-- 注意，交叉处要具体指出查询的是哪个表，不然会出现模棱两可的错误，因此此处为s/r.`studentno`SELECT s.`studentno`, `studentname`, `subjectno`, `studentresult`FROM student AS s INNER JOIN result AS rON s.`studentno`=r.`studentno` SELECT s.`studentno`, `studentname`, `subjectno`, `studentresult`FROM student AS s RIGHT JOIN result AS rON s.`studentno`=r.`studentno`-- 此处不能左连接，会出现在s中不在r中的值被查询到-- SELECT r.`studentno`, `studentname`, `subjectno`, `studentresult`-- FROM student AS s LEFT JOIN result AS r-- ON s.`studentno`=r.`studentno`-- 查询缺考的同学（学号，姓名，科目编号，分数）SELECT r.`studentno`, `studentname`, `subjectno`, `studentresult`FROM student AS s LEFT JOIN result AS rON s.`studentno`=r.`studentno`WHERE `studentresult` IS NULL 总结： inner join：如果表中有一个匹配的值，就返回该值； left join：会从左表中返回所有的值，即使右表中没有匹配； right join：会从左表中返回所有的值，即使右表中没有匹配； 语法： – join on 连接查询；–join where 等值查询 多张表联表： 123456789101112131415161718192021-- 查询参加了考试的同学（学号，姓名，科目名，分数）/* 思路：1.分析需求，分析查询的字段来自哪些表--student和result和subject2.确定使用那种连接查询--七种3.确定交叉点（两个表中哪些数据是相同的）--studentno判断条件：student表中的studentno = result表中的studentno result表中的subjectno = subject表中的subjectno */SELECT s.`studentno`, `studentname`, `subjectname`, `studentresult`FROM student AS sRIGHT JOIN result AS rON s.`studentno` = r.`studentno`INNER JOIN `subject` AS subON r.`subjectno` = sub.`subjectno`-- 技巧-- 我要查询哪些数据 select ...-- 从哪几个表中查 from 表 XXX join 连接的表 on 交叉条件-- 假设存在多个表的查询，则先查询两张表再慢慢增加 自连接： 自己的表和自己的表连接，核心：一张表拆成两张一样的表即可 例子：– 联表查询 查询父子信息 1234SELECT a.`categoryName` AS '父栏目', b.`categoryName` AS '子栏目'FROM `category` AS a, `category` AS bWHERE a.`categoryid` = b.`pid` 分页LIMIT 和排序ORDER BY排序语法：– ORDER BY 通过哪个字段排序 怎么排 其中，排序方式为升序（ASC）和降序（DESC） 分页：为了缓解数据库压力，给人的体验更好 分页语法: LIMIT 起始值, 页面的大小 前端用： 第N页： LIMIT (N-1)*pagesize, pagesize 子查询子查询方式：多个SELECT嵌套，执行顺序为由里向外 例子：子查询 查询高等数学-1 的所有考试结果（学号，科目编号，成绩）降序排列 1234567891011121314151617-- 方式一：连接查询SELECT `studentno`, s.`subjectno`, `studentresult`FROM `result` AS rINNER JOIN `subject` AS sON s.`subjectno` = r.`subjectno`WHERE `subjectname` = '高等数学-1'ORDER BY `studentresult` DESC-- 方式二：子查询SELECT `studentno`, `subjectno`, `studentresult`FROM `result` WHERE `subjectno` = (SELECT `subjectno` FROM `subject`WHERE `subjectname` = '高等数学-1' )ORDER BY `studentresult` DESC MySQL函数123456789101112131415161718192021222324252627282930313233343536373839-- ------------ 常用函数 ---- ----------SELECT ABS(-8) -- 绝对值SELECT CEILING(9.4) -- 向上取整SELECT FLOOR(9.4) -- 向下取整SELECT RAND() -- 返回0-1随机数SELECT SIGN(-5) -- 返回参数的符号 0~0 负数~-1 正数~1-- 字符串函数SELECT CHAR_LENGTH('123456789')SELECT CONCAT('我','爱','你')SELECT INSERT('我爱编程', 2, 1, '超级热爱') -- 插入替换，从某个位置开始替换某个长度 --我超级热爱编程-- 时间和日期SELECT CURRENT_DATE() -- 获取当前日期SELECT NOW() -- 获取当前时间SELECT LOCALTIME() -- 获取本地时间SELECT SYSDATE() -- 获取系统时间-- ------------ 聚合函数 ---- ------------ COUNT()计数；SUM()求和；AVG()平均值；MAX()最大值… SELECT COUNT(`studentname`) FROM student -- COUNT(字段)，查询字段记录数 会忽略所有的nullSELECT COUNT(*) FROM student -- COUNT(*)，不会忽略所有的nullSELECT COUNT(1) FROM student -- COUNT(1)，不会忽略所有的null 分组和过滤 GROUP BY … [HAVING]123456789-- 查询不同课程的平均分，最高分，最低分，平均分大于80-- 核心：根据不同的课程分组SELECT `subjectname`, AVG(`studentresult`) AS average, MAX(`studentresult`), MIN(`studentresult`)FROM result AS rINNER JOIN `subject` AS subON r.`subjectno` = sub.`subjectno`GROUP BY r.`subjectno` -- 通过什么字段来分组HAVING average &gt; 80 -- 过滤分组后的记录必须满足的次要条件","link":"/2023/01/25/MySQL%E4%BA%8C/"},{"title":"MyBatis（四）","text":"本系列主要进行MyBatis框架的学习介绍，其中本篇文章介绍MyBatis中多对一和一对多的处理。 多对一处理举例说明： 多个学生，对应一个老师； 对于学生这边而言，关联… 多个学生，关联一个老师【多对一】； 对于老师而言，集合… 一个老师，有很多学生【一对多】 测试环境搭建 导入Lombok，实体类编写偷懒； 新建实体类 Teacher Studednt； 建立Mapper接口； 建立Mapper.xml文件； 在核心配置文件中绑定我们的Mapper接口或者文件； 测试查询是否能够成功。 实体类创建： 12345678910111213141516@Datapublic class Student{ private int id; private String name; //学生需要关联一个老师 private Teacher teacher;}@Datapublic class Teacher{//老师就是单纯的老师 private int id; private String name;} 按照查询嵌套处理1234567891011121314151617181920212223&lt;!--思路：1.查询所有的学生信息；2.根据查询出来学生的tid，寻找对应的老师；-类似于**子查询**--&gt;&lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt; select * from student&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;!--复杂的属性，需要单独处理对象：association集合：collection--&gt; &lt;!--嵌套了另一个select语句，实现联表查询--&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacher&quot; resultType=&quot;Teacher&quot;&gt; select * from teacher where id=#{id}&lt;/select&gt; 按照结果嵌套处理123456789101112131415161718192021&lt;!--思路：1.查询所有的学生信息；2.根据查询出来学生的tid，寻找对应的老师；-类似于**联表查询**--&gt;&lt;select id=&quot;getStudent2&quot; resultMap=&quot;StudentTeacher2&quot;&gt; select s.id sid,s.names name,t.name tname from student s,teacher t where s.tid=t.id&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 推荐使用第二种，即按结果嵌套查询，变化sql实现复杂功能。 一对多处理比如：一个老师拥有多个学生，对于老师而言，就是一对多。 实体类创建： 1234567891011121314151617@Datapublic class Student{ private int id; private String name; //学生是单纯的学生 private int tid;}@Datapublic class Teacher{ private int id; private String name; //一个老师对应多个学生 private List&lt;Student&gt; students;} 按照查询嵌套处理12345678910111213&lt;!--按查询嵌套查询--&gt;&lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt; select * from teacher where id=#{tid}&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt; &lt;collection property=&quot;students&quot; column=&quot;id&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getStudentByTeacherId&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt; select * from student where tid=#{tid}&lt;/select&gt; 按照结果嵌套处理123456789101112131415161718&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent2&quot;&gt; select s.id sid,s.name sname,t.name tname,t.id tid from student s,teacher t where s.tid=t.id and t.id=#{tid}&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;Teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;!--javaType=&quot;&quot;：指定属性的类型，对于集合中的泛型信息（此处为List&lt;Student&gt;），我们使用ofType获取--&gt; &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 总结： 1.关联- association【多对一】； 2.集合- collection【一对多】; 3.javaType &amp; ofType javaType 用来指定实体类中属性的类型; ofType用来指定映射到List或者集合中的pojo类型，泛型中的约束类型! 注意点: 保证SQL的可读性，尽量保证通俗易懂； 注意一对多和多对一中，属性名和字段的问题! 如果问题不好排查错误，可以使用日志，建议使用Log4j","link":"/2023/02/03/MyBatis%E5%9B%9B/"},{"title":"MyBatis（一）","text":"本系列主要进行MyBatis框架的学习介绍，其中本篇文章介绍MyBatis的一些基本概念和基本操作，包括初识MyBatis，第一个MyBatis程序的搭建，和基本的增删改查操作等。 初识MyBatis什么是MyBatis MyBatis 是一款优秀的持久层框架； 它支持定制化 SQL、存储过程以及高级映射； MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集； MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO (Plain Old Javaobjects，普通老式 Java 对象）为数据库中的记录； MyBatis原本本是apache的一个开源项目iBatis，2010年这个项目由apache software foundation迁移到了google code，并且改名为MyBatis； 2013年11月迁移到Github。 持久化数据持久化： 持久化就是将程序的数据在持久状态和瞬时状态转化的过程； 内存：断电即失； 数据库(Jdbc)，io文件持久化； 生活案例：冷藏，罐头…。 为什么需要需要持久化？ 有一些对象，不能让他丢掉； 内存太贵了。 持久层 完成持久化工作的代码块； 层的界限十分明显。 为什么需要Mybatis 帮助程序猿将数据存入到数据库中； 方便； 传统的JDBC代码太复杂了。简化。框架。自动化； 不用Mybatis也可以。更容易上手。技术没有高低之分； 优点：简单易学。灵活； 实现了sql和代码的分离。提高了可维护性； 提供映射标签，支持对象与数据库的orm字段关系映射； 提供对象关系映射标签，支持对象关系组建维护； 提供xml标签，支持编写动态sql。 第一个MyBatis程序搭建环境新建项目： 新建一个普通的maven项目； 删除src目录； 导入maven依赖 创建一个模块 编写mybatis核心配置文件：mybatis-config.xml 1234567891011121314151617181920212223&lt;?xmlversion=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPEconfigurationPUBLIC&quot;-//mybatis.org//DTDConfig3.0//EN&quot;&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transaction Managertype=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写mybatis工具类：MybatisUtils.class 12345678910111213141516171819202122//获取sqlSessionFactory对象-&gt;获取sqlSession实例public class MybatisUtils{ private static SqlSessionFactory sqlSessionFactory;//提升作用域，在方法下使用 //一初始就加载了 static{ try{ //使用Mybatis第一步：获取sqlSessionFactory对象 String resource = &quot;mybatis-config.xml&quot;; InputStreaminputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = newSqlSessionFactoryBuilder().build(inputStream); } catch(IOExceptione){ e.printStackTrace(); } } //从SqlSessionFactory中获得SqlSession的实例。 //SqlSession提供了在数据库执行SQL命令所需的所有方法 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); }} 编写代码 实体类：User.class Dao接口：UserDao.impl 1234public interface UserDao{ List&lt;User&gt; getUserList();} 接口实现类：由原来的UserDaoImpl转变为一个Mapper配置文件：UserMapper.xml` 123456789101112131415&lt;?xmlversion=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPEmapperPUBLIC&quot;-//mybatis.org//DTDMapper3.0//EN&quot;&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;&lt;mapper namespace=&quot;dao.UserDao&quot;&gt; &lt;!--select查询语句--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;pojo.User&quot;&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt; Junit测试注意点，一个报错： org.apache.ibatis.binding.BindingException: Type interface com.kuang.dao.UserDao is not known to the MapperRegistry. MapperRegistry是什么? 核心配置文件中注册mappers的文件。 测试文件：UserDaoTest.class 123456789101112131415161718@Testpublic void test(){ //1.获得sqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //2.执行SQL //方式一：getMapper UserDaomapper = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = mapper.getUserList(); for(Useruser:userList){ System.out.println(user); } //关闭SqlSession sqlSession.close();} CRUD增删改查namespacenamespace中的包名要和Dao/mapper接口的包名一致。 如：namespace为dao.UserMapper，绑定了UserMapper接口。 select选择，查询语句； id：就是对应namespace中的方法名； resultType：SQL语句执行的返回值； parameterType：参数类型 具体步骤： 12345678910111213141516171819202122//1.编写接口//根据id查询用户User getUserById(int id);//2.编写xml配置文件，即对应mapper中的sql语句&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;pojo.User&quot;&gt; select * from mybatis.user where id=#{id}&lt;/select&gt;//3.测试@Testpublic void getUserById(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); //查询id为1的用户 User userById = mapper.getUserById(1); System.out.println(userById); sqlSession.close();} insert123456&lt;!--对象中的属性可以直接取出来--&gt;&lt;insert id=&quot;addUser&quot; parameterType=&quot;pojo.User&quot;&gt; &lt;!--传递参数为对象时，语句中参数要和对象中的属性一一对应--&gt; insert into mybatis.user(id,name,pwd) values (#{id},#{name},#{pwd})&lt;/insert&gt; update1234&lt;update id=&quot;updateUser&quot; parameterType=&quot;pojo.User&quot;&gt; update mybatis.user set name=#{name}, pwd=#{pwd} where id=#{id}&lt;/update&gt; delete1234&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from mybatis.user where id=#{id}&lt;/delete&gt; 注意：增删改需要提交事务！ 万能Map假设我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！ 例子：对addUser的修改：只插入有两个字段的对象 1234567891011121314151617181920212223242526272829303132//接口定义int addUser2(Map&lt;String,Object&gt; map);//配置文件&lt;!--传递参数为map时，语句中参数要和对象中的属性不需要对应，可以随意取名，对应为map的key--&gt;&lt;!--同时，参数可以仅为数据库字段的部分值--&gt;&lt;insert id=&quot;addUser2&quot; parameterType=&quot;map&quot;&gt; insert into mybatis.user(id,name) values(#{userId},#{userName})&lt;/insert&gt;//测试函数public void addUser2Test(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); //此处的名称userId和userName要与配置文件中key的名称一致 //设置插入内容 map.put(&quot;userId&quot;,5); map.put(&quot;userName&quot;,&quot;小明&quot;); intres = mapper.addUser2(map); if(res&gt;0){ System.out.println(&quot;插入成功！&quot;); } //提交事务 sqlSession.commit(); sqlSession.close();} 注意： Map传递参数，直接在sql中取出key即可（即sql语句中#{}中的参数与测试时map添加的参数保持一致即可）； 对象传递参数，直接在sql中取对象的属性即可（即sql语句中#{}中的参数要与对象属性一一对应）； 只有一个基本类型参数的情况下，可以直接在sql中取到，就不用再写parameterType了； 多个参数的话，用Map，或者注解。 模糊查询如：查找名字中带有”李”字的用户 123456&lt;!--java代码执行时，传递通配符&quot;% %&quot;&quot;--&gt;List&lt;User&gt; userList = mapper.getUserLike(&quot;%李%&quot;)；&lt;--!sql拼接中使用通配符&quot;% %&quot;--&gt;select * from mybatis.user where name like &quot;%&quot;#{value}&quot;%&quot; 一般情况下用不到，通常在业务中会遇到。","link":"/2023/02/03/MyBatis%E4%B8%80/"},{"title":"MyBatis（三）","text":"本系列主要进行MyBatis框架的学习介绍，其中本篇文章介绍MyBatis中ResultMap，日志的使用，和采用注解开发等知识。 ResultMap解析用于：解决属性名和字段名不一致的问题。 属性名：用户类（User）中声明的属性； 字段名：Mysql创建的表中的列名。 例如：在之前的例子中，类User中的属性名是passward而不是pwd，那么mapper配置文件应改为： 1234567891011121314151617&lt;!--结果集映射--&gt;&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!--column: 数据库中的字段，property: 实体类中的属性--&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getUserById&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user where id = #{id}&lt;/select&gt;&lt;!--代替了原来的:--&gt;&lt;select id=&quot;getUserById&quot; resultType=&quot;User&quot;&gt; select * from mybatis.user where id = #{id}&lt;/select&gt; 总结： resultMap元素是MyBatis中最重要最强大的元素； ResultMap的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了；（即：ResultMap只需要用于属性名和字段名不一致的情况，一致的情况就不需要使用了） ResultMap最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。（即：使用ResultMap时，只需要列出不一致的属性） 日志日志工厂如果一个数据库操作，出现了异常，我们需要进行排错。 以前：sout，debug… 现在：日志工厂 使用方法：在resource中的配置文件中进行settings设置。 日志类型包含： SLF4J LOG4j【掌握】 LOG4j2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING【掌握】 NO_LOGGING STDOUT_LOGGING： 标准的日志类型，不需要进行配置。 12345&lt;settings&gt; &lt;!--标准的日志工厂实现--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt; Log4j什么是Log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件； 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程； 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 配置方法： 导包 配置log4j.properties文件 配置为log4j为日志的实现（settings中的配置） 简单使用： 1.在要使用Log4j的类中，导入包 import org.apache.log4j.Logger； 2.设置日志对象，参数为当前类的class： ​ static Logger logger= Logger.getLogger(UserDaoTest.class)； 3.日志级别 info debug error….一般用info表示提示，如： ​ logger.info(“进入了log4jTest”); 注解开发使用注解开发使用注解开发实际上是面向接口编程。 面向接口的编程的优点：解耦，可拓展，提高复用… 具体步骤： 123456789101112//1.注解在接口上实现@select(&quot;select * from user&quot;)List&lt;User&gt; getUsers();//2.需要在核心配置文件中绑定接口!&lt;!--绑定接口--&gt;&lt;mappers&gt; &lt;mapper class=&quot;dao.userMapper&quot;/&gt;&lt;/mappers&gt;//3.测试 本质：反射机制；底层：动态代理 CRUD实现具体代码见代码文件，与之前类似。 注意：我们必须要讲接口注册绑定到我们的核心配置文件中！ 我们可以在工具类创建的时候实现自动提交事务！ 1234public static sqlSession getsqlSession(){ return sqlSessionFactory.openSession(true);} 关于@Param()注解： 基本类型的参数或者String类型，需要加上； 引用类型不需要加； 如果只有一个基本类型的话，可以忽略，但是建议大家都加上； 我们在SQL中引用的就是我们这里的@Param(“uid”)中设定的属性名。 Lombok用于省略实体类的一些通用操作，如get,set,toString方法等… 使用步骤： 1.安装lombok插件； 2.导入lombok的jar包； 3.在实体类上加注解即可。 常用的有： @Data: 无参构造get，set，toString，equals，hashcode @AllArgsConstructor：生成有参构造器 @NoArgsConstructor：无参构造器","link":"/2023/02/03/MyBatis%E4%B8%89/"},{"title":"MyBatis（二）","text":"本系列主要进行MyBatis框架的学习介绍，其中本篇文章介绍MyBatis的配置解析，包括核心配置文件，环境变量，属性，类型别名，映射器，生命周期和作用域等。 配置解析核心配置文件 mybatis-config.xml； mybatis的配置文件包含了会深深影响Mybatis行为的设置和属性信息； 环境变量（environments） MyBatis可以配置成适应多种环境； 不过要记住：尽管可以配置多个环境，但每个SqlSessionFactory实例只能选择一种环境； 要学会使用配置多套运行环境，用default进行环境的选择； Mybatis默认的事务管理器就是JDBC，连接池: POOLED 属性（properties）我们可以通过properties属性来实现引用配置文件； 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置；（db.properties） 编写一个配置文件db.properties 123driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;;useUnicode=true&amp;;characterEncoding=UTF-8 在核心配置文件中引入： 123456&lt;!--引入外部配置文件--&gt;&lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/properties&gt; 注意： 可以直接引入外部文件； 可以在其中增加一些属性配置； 如果两个文件有同一个字段，优先使用外部配置文件的。（即如果db.properties也写了username和password，以db中的为准） 类型别名（typeAliases） 类型别名可为 Java 类型设置一个缩写名字； 存在的意义仅在于用来降低全限定类名书写的冗余。 123456789101112&lt;!--方式一：直接给实体类起别名--&gt; &lt;typeAliases&gt; &lt;typeAliastype=&quot;pojo.User&quot;alias=&quot;User&quot;/&gt;&lt;/typeAliases&gt;&lt;!--方式二：指定一个包名MyBatis 会在包名下面搜索需要的Java Bean，比如：扫描实体类的包，它的默认别名就为这个类的类名，首字母小写。--&gt;&lt;typeAliases&gt; &lt;!--也可以通过包的方式起别名，名称为这个类的类名，首字母小写的结果，此处为user--&gt; &lt;packagename=&quot;pojo&quot;/&gt;&lt;/typeAliases&gt; 注意： 在实体类比较少的时候，使用第一种方式。如果实体类十分多，建议使用第二种； 第一种可以DIY别名，第二种不行，如果非要改，需要在实体类上加别名，例如： 12345@Alias(&quot;user&quot;) public class User{ ...} 映射器（mappers）MapperRegistry：注册绑定我们的Mapper文件。 有两种映射器的配置方法： 12345678910111213141516&lt;!--方式一：直接使用resource路径：[推荐使用方式一]--&gt;&lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册--&gt;&lt;mappers&gt; &lt;mapper resource=&quot;dao/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!--方式二：使用接口同名的类class进行配置--&gt;&lt;mappers&gt; &lt;mapper class=&quot;dao.UserMapper&quot;/&gt;&lt;/mappers&gt;&lt;!--方式三：使用扫描包package进行注入绑定--&gt;&lt;mappers&gt; &lt;package name=&quot;dao&quot;/&gt;&lt;/mappers&gt; 方法二和方法三注意点： 接口和他的Mapper配置文件必须同名； 接口和他的Mapper配置文件必须在同一个包下； 注意：class时为类名，用 . ，resource时为xml的路径，用 / 。 生命周期和作用域生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的并发问题。 生命周期： SqlSessionFactoryBuilder: 一旦创建了SqlSessionFactory，就不再需要它了； 局部变量 SqlSessionFactory： 说白了就是可以想象为：数据库连接池； SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例； 因此SqlSessionFactory的最佳作用域是应用作用域；（即全局变量） 最简单的就是使用单例模式或者静态单例模式。 SqlSession： 是连接到连接池的一个请求! SqlSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。（创建实例时使用，实例使用完毕时关闭） 用完之后需要赶紧关闭，否则资源被占用！ SqlSessionFactory和SqlSession的关系：一个SqlSessionFactory工厂可以创建多个SqlSession类，每个类最多用于一个线程；一个sqlSession实例可以创建多个Mapper，用于执行指令。这里的每一个Mapper，就代表一个具体的业务。","link":"/2023/02/03/MyBatis%E4%BA%8C/"},{"title":"MyBatis（五）","text":"本系列主要进行MyBatis框架的学习介绍，其中本篇文章介绍MyBatis中动态SQL语句的实现，以及缓存的相关知识。 动态SQL什么是动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句。 如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 动态SQL的元素主要包括： if –条件判断 choose (when, otherwise) –类似switch trim (where, set) –实现智能去and（where中） 和逗号（update语句的set中），trim为自动去除前后缀，具体使用见官网 foreach –用于SQL语句中使用了in的情况 所谓的动态SQL，本质上还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码。 SQL片段： 有的时候，我们可能会将一些功能的部分抽取出来，方便复用。 采用&lt;sql&gt;进行定义，用&lt;include&gt;进行引用。 注意事项： 最好基于单表i来定义SQL片段； 不要存在&lt;where&gt;标签。 常用的动态SQL：if, where, set 动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了。 建议：先在Mysql中写出完整的SQL，再对应的去修改为动态SQL实现通用即可。 缓存简介通常，查询会连接数据库，耗资源。 一次查询的结果，给他暂存在一个可以直接取到的地方 –&gt;也就是 内存：缓存 我们再次查询相同数据的时候，直接走缓存，就不用走数据库了。 什么是缓存[Cache]？ 存在内存中的临时数据； 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库数据文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题； 为什么使用缓存? 减少和数据库的交互次数，减少系统开销，提高系统效率。 什么样的数据能使用缓存? 经常查询并且不经常改变的数据。（也就是经常用于读操作的数据） 不经常查询或者经常改变的数据，不建议使用缓存。（也就是用于写操作的数据） Mybatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存，缓存可以极大的提升查询效率； MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存； 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）。二级缓存需要手动开启和配置，它是基于namespace级别的缓存； 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存。 一级缓存 一级缓存也叫本地缓存： 与数据库同一次会话期间查询到的数据会放在本地缓存中； 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库; 缓存失效的情况： 查询不同的东西 增删改操作，可能会改变原来的数据，所以必定会刷新缓存 查询不同的Mapper.xml 手动清理缓存 小结：一级缓存默认是开启的，只在一次SqlSession中有效，也即为拿到连接到关闭连接这个阶段。 一级缓存相当于一个Map。 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存； 二级缓存是基于namespace级别的缓存，一个名称空间，对应一个二级缓存； 工作机制： 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中; 当新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存(map)中; 使用步骤： 123456789101112131415161718&lt;!--1.开启全局缓存--&gt;&lt;!--显式的开启全局缓存，默认为开启--&gt;&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;!--2.在要使用二级缓存的Mapper中开启--&gt;&lt;!--在当前的Mapper.xml中使用二级缓存--&gt;&lt;cache/&gt;&lt;!--也可以自定义参数--&gt;&lt;!--在当前的Mapper.xml中使用二级缓存--&gt;&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt;&lt;!--3.测试--&gt;&lt;!--问题：我们需要将实体类序列化，否则会报错。caused by: java.io.NotserializableException: pojo.User、序列化方法：public class User implements Serializable{…} --&gt; 小结: 只要开启了二级缓存，在同一个Mapper下就有效； 所有的数据都会先放在一级缓存中； 只有当会话提交，或者关闭的时候，才会提交到二级缓存中。（即一级缓存结束了，才会有二级缓存） 缓存原理 缓存顺序：当用户执行一个SQL语句时： 先看二级缓存有没有对应的缓存信息； 再看一级缓存有没有对应的缓存信息； 如果都没有，则查询数据库。","link":"/2023/02/04/MyBatis%E4%BA%94/"},{"title":"Spring（一）","text":"本系列主要进行Spring框架的学习介绍，Spring框架是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架。其中本篇文章进行Spring的简介，包括Spring的介绍，IOC的推导和第一个Spring框架程序的搭建和IOC创建对象的方式等。 Spring简介spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架。 官网：https://spring.io/projects/spring-framework#overview 官方下载地址：http://repo.spring.io/release/org/springframework/spring GitHub：https://github.com/spring-projects/spring-framework 需要导的包： 1234567891011121314&lt;!-- https: //mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https: //mvnrepository.com/artifact/org.springframework/spring-jdbc--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 优点 spring是一个开源的免费的框架（容器）； spring是一个轻量级的、非入侵式的框架； 控制反转（IOC），面向切面编程（AOP）； 支持事务的处理，对框架整合的支持。 总结：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架。 缺点：发展了太久之后，违背了原来的理念，配置十分繁琐。 IOC理论推导代码架构： UserDao接口 UserDaoImpl实现类 UserService业务接口 UserServiceImpl业务实现类 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码。如果程序代码量十分大，修改一次的成本代价十分昂贵。 我们使用一个set接口实现，已经发生了革命性的变化。 123456private userDao userDao;//利用set进行动态实现值的注入!public void set userDao(userDao userDao) { this.userDao = userDao;} 之前，程序是主动创建对象，控制权在程序猿手上； 在使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象； 用户可以根据自身的需求，使用不同的情况，而不需要程序员在业务层上进行修改了。 这种思想，从本质上解决了问题，程序员不用再去管理对象的创建了，系统的耦合性大大降低，可以更加专注于业务的实现上。这是IOC的原型。 IOC本质： 控制反转loC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现loC的一种方法，也有人认为DI只是loC的另一种说法。没有loC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是loC容器，其实现方法是依赖注入(Dependency Injection,Dl)。 Hello Spring1. 编写实体类Hello； 12345678910111213141516public class Hello{ private String str; public String getStr(){ return str; } public void setStr(Stringstr){ this.str=str; } @Override public String toString(){ return &quot;Hello{&quot;+&quot;str='&quot;+str+'\\''+'}'; }} 2.编写Spring配置文件beans.xml； 1234567891011&lt;!--使用Spring来创建对象，在Spring中这些都称为Bean类型变量名 = new 类型();Hello hello = new Hello();id=变量名class=new的对象property相当于给对象中的属性设置一个值--&gt;&lt;bean id=&quot;hello&quot; class=&quot;pojo.Hello&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt;&lt;/bean&gt; 3.编写测试函数 123456789public static void main(String[] args){ //获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //我们的对象现在都在Spring中管理了，我们要使用，直接去里面取出来就可以了 Hello hello = (Hello)context.getBean(&quot;hello&quot;); System.out.println(hello.toString());} 总结： 1.Hello对象是由Spring创建的； 2.Hello对象的属性是由Spring容器设置的； 3.这个过程就叫控制反转： 控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。 反转：程序本身不创建对象，而变成被动的接收对象。 依赖注入：就是利用set方法来进行注入的。 4.IOC是一种编程思想，由主动的编程变成被动的接收； 5.到了现在,我们彻底不用再程序中去改动了，要实现不同的操作，只需要在xmI配置文件中进行修改，所谓的IoC, 一句话搞定：对象由Spring来创建，管理，装配。 IOC创建对象的方式1.使用无参构造创建对象，默认！ 2.假设我们要用有参构造创建对象。 123456789101112131415&lt;!--有参构造器创建对象 下标赋值--&gt;&lt;bean id=&quot;hello&quot; class=&quot;pojo.Hello&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;Summer&quot;/&gt;&lt;/bean&gt;&lt;!--有参构造器创建对象 类型赋值--&gt;&lt;bean id=&quot;hello&quot; class=&quot;pojo.Hello&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;Summer&quot;/&gt;&lt;/bean&gt;&lt;!--有参构造器创建对象 参数名赋值--&gt;&lt;bean id=&quot;hello&quot; class=&quot;pojo.Hello&quot;&gt; &lt;constructor-arg name=&quot;str&quot; value=&quot;Autumn&quot;/&gt;&lt;/bean&gt; 在配置文件加载的时候，容器中管理的对象就已经初始化了。即：不管是否使用，都先初始化好了，用的时候直接拿来用就行。 （Spring容器可以看作婚庆公司，有很多人的名单，看中了谁就选谁）","link":"/2023/02/07/Spring%E4%B8%80/"},{"title":"Spring（五）","text":"本系列主要进行Spring框架的学习介绍，Spring框架是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架。其中本篇文章将Spring与Mybatis进行整合，并介绍事务的有关内容。 整合MyBatis步骤： 1.导入相关jar包： junit、mybatis、mysql、spring、aop、mybatis-spring 2.编写配置文件 3.测试 回忆mybatis1.编写实体类 2.编写核心配置文件 3.编写接口 4.编写Mapper.xml 5.测试 Mybatis-spring1.编写数据源配置 2.sqlSessionFactory 3.sqlSessionTemplate 4.给接口加实现类 5.将自己写的实现类注入到spring中 6.测试使用 具体见代码，代码编写顺序（上面6点的拓展）： 1.导入依赖； 2.编写pojo下的实体类（如User）； 3.编写对应实体类在mapper下的接口（如UserMapper），以及配置文件（如UserMapper.xml）； 123456789101112//接口public interface UserMapper{List&lt;User&gt;selectUser();}//xml&lt;mapper namespace=&quot;mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectUser&quot; resultType=&quot;user&quot;&gt; select * from user; &lt;/select&gt;&lt;/mapper&gt; 4.整合mybatis：编写mybatis配置文件，编写spring配置文件（包含了上面的1-3）； mybatis-config.xml: 12345678&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt; &lt;!--其实可以完全省略了，但通常在mybatis配置文件中留下别名typeAliases和设置settings--&gt; &lt;typeAliases&gt; &lt;packagename=&quot;pojo&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; spring-dao.xml: 123456789101112131415161718192021222324&lt;!--DataSource:使用Spring的数据源替换Mybatis的配置我们这里使用spring提供的jdbc--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt;&lt;!--sqlSessionFactory的创建--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--绑定Mybatis配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;&lt;/bean&gt;&lt;!--SqlSessionTemplate其实就是我们使用的sqlSession--&gt;&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!--只能用构造器注入sqlSessionFactory，因为它没有set方法--&gt; &lt;constructor-argindex=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt; 5.编写实现类（如UserMapperImpl）； 123456789101112131415public class UserMapperImpl implements UserMapper{//在原来，我们的所有操作都使用sqlSession来执行//而现在，我们使用SqlSessionTemplate类private SqlSessionTemplate sqlSession;public void set SqlSession(SqlSessionTemplate sqlSession){ this.sqlSession=sqlSession;}//要实现的功能public List&lt;User&gt; selectUser(){ UserMapper mapper=sqlSession.getMapper(UserMapper.class); return mapper.selectUser();} 6.编写总的配置文件applicationContext.xml，即将实现类注入到spring中； 123456&lt;import resource=&quot;spring-dao.xml&quot;/&gt;&lt;bean id=&quot;useMapper&quot; class=&quot;mapper.UserMapperImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt; 7.测试 声明式事务回顾事务 要么都成功，要么都失败； 事务在项目开发中，十分重要，涉及到数据的一致性问题； 确保完整性和一致性； 事务ACID原则：原子性，一致性，隔离性，持久性。 spring中的事务管理声明式事务管理：AOP实现 配置于spring-dao.xml中 123456789101112131415161718192021&lt;!--配置声明式事务--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--结合aop实现事务的织入--&gt;&lt;!--配置事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!--给哪些方法配置事务name--&gt; &lt;!--配置事务的传播特性propagation 可以不管，默认就是REQUIRED--&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--配置事务切入--&gt;&lt;aop:config&gt; &lt;aop:point cutid=&quot;txPointCut&quot; expression=&quot;execution(*mapper.UserMapperImpl.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt;&lt;/aop:config&gt; 编程式事务管理：需要在代码中，进行事务的管理 为什么需要事务？ 如果不配置事务，可能存在数据提交不一致的情况； 如果不在spring中配置声明式事务，就需要在代码中，手动进行配置； 事务能够保证数据安全，在项目开发中，十分重要，涉及到数据的一致性问题。 例子：假设delete的sql代码出现问题 1234567891011public List&lt;User&gt; selectUser(){ User user=new User(7,&quot;小田&quot;,&quot;777777&quot;); UserMapper mapper=sqlSession.getMapper(UserMapper.class); mapper.addUser(user); mapper.deleteUser(7); return mapper.selectUser();} 如果不处理事务，那么会导致使用add功能而不使用delete功能； 处理了事务之后，delete程序出问题了，add功能也不会成功使用，保证了数据的一致性。","link":"/2023/02/07/Spring%E4%BA%94/"},{"title":"Spring（三）","text":"本系列主要进行Spring框架的学习介绍，Spring框架是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架。其中本篇文章进行对Spring的进一步讲解，包括Bean的自动装配，使用注解开发，使用java方式配置Spring等。 Bean的自动装配自动装配是Spring满足bean依赖的一种方式； Spring会在上下文种自动寻找，并自动给bean装配属性。 在Spring中有三种装配的方式： 在xml种进行显式的配置； 在java种显式的配置； 隐式的自动装配bean【重要】 测试环境搭建：一个人有两个宠物 12345678&lt;bean id=&quot;cat&quot; class=&quot;pojo.Cat&quot;/&gt;&lt;bean id=&quot;dog&quot; class=&quot;pojo.Dog&quot;/&gt;&lt;bean id=&quot;person&quot; class=&quot;pojo.Person&quot;&gt; &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt; &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;&lt;/bean&gt; 自动装配byName,byType自动装配： 123456789101112131415&lt;bean id=&quot;cat&quot; class=&quot;pojo.Cat&quot;/&gt;&lt;bean id=&quot;dog&quot; class=&quot;pojo.Dog&quot;/&gt;&lt;!--自动装配autowirebyName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的beanid（需要id相同）byType:会自动在容器上下文中查找，和自己对象属性类型相同的的bean（需要类型唯一）--&gt;&lt;bean id=&quot;person&quot; class=&quot;pojo.Person&quot; autowire=&quot;byType&quot;&gt; &lt;!--bean id=&quot;person&quot; class=&quot;pojo.Person&quot; autowire=&quot;byName&quot;--&gt; &lt;!--&lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;--&gt; &lt;!--&lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;--&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;&lt;/bean&gt; 小结： byName的时候，需要保证所有的bean的id唯一，并且这个bean的id需要和自动注入的属性的set方法的值一致； byType的时候，需要保证所有的bean的class唯一，并且这个bean的class需要和自动注入的属性的类型一致。 使用注解实现自动装配要使用注解须知： 导入约束； 配置注解的支持。 @AutoWired：默认为byType方式，如果找不到就byName 直接在属性上使用即可，也可以在set方法上使用； 使用@AutoWired就不用编写set方法了，前提是你这个自动装配的属性在IOC（Spring）容器中存在，且符合名字byName； 科普：@Nullale：字段标记了这个注解，则该字段可以为空；@AutoWired(required=false)：若属性为false，则说明这个对象可以为空（null）。 如果@AutoWired自动装配的环境比较复杂，自动装配无法通过一个注解（@AutoWired）完成时，我们可以使用@Qualifier(value=”xxx”)去配合@AutoWired使用，指定唯一一个bean对象的注入。 @Resource：默认为byName方式，如果找不到就byType，不需要导入Spring，但效率稍微低一些 如果字段名id与属性名不同，如id=”cat123”，属性为cat，则使用方式为： 1234567@AutoWired@Qualifier(value=&quot;cat123&quot;)private Cat cat;@Resource(name=&quot;cat123&quot;)private Cat cat; 使用注解开发 在spring4之后，使用注解必须要导入aop包； 使用注解需要导入context约束，并配置注解的支持。 bean的创建和属性的注入： 12345678910//等价于&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;/&gt;//@Component组件@Componentpublic class User{ //相当于&lt;property name=&quot;name&quot; value=&quot;秦疆&quot;/&gt; //@Value属性值，也可以作用于set方法上 @Value(&quot;秦疆&quot;) public String name;} 衍生的注解： @Component有几个衍生注解，我们在web开发中，会按照mvc三层架构分层： dao 【@Repository】 service 【@service】 controller 【@controller】 这四个注解功能都是一样的，都是代表将某个类注册到Spring中，并装配Bean。 作用域： 1234@scope(&quot;prototype&quot;)//相当于scope=&quot;prototype&quot;public class User{…} 小结： xml与注解： xml更加万能，适用于任何场合，维护简单方便； 注解不是自己类就使用不了，维护相对复杂。 xml与注解最佳实践： xml用来管理bean； 注解只负责完成属性的注入； 我们在使用的过程中，只需要注意一个问题：必须让注解生效，即需要开启注解的支持。 使用java方式配置Spring纯java，不再使用beans.xml配置文件了，而是采用了一个配置类。 实体类：User.class 配置文件：MyConfig.class，可以有多个，用@Import导入 12345678910111213141516//@Configuration也会被Spring容器托管，注册到容器中，因为这个本来就是一个Component//@Configuration代表这是一个配置类，等价于beans.xml@Configuration@ComponentScan(&quot;pojo&quot;)@Import(MyConfig2.class)public class MyConfig{ //注册一个bean，就相当于之前的bean标签 //这个方法的名字，就相当于bean标签的id属性 //这个方法的返回值，就相当于bean标签的class属性 //即等价于&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;/&gt; @Bean public User user(){ return new User();//就是返回要注入到bean的对象 }} 测试类： 1234567public static void main(String[] args){ //如果完全使用了配置类去做，我们就只能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载 ApplicationContext context=new AnnotationConfigApplicationContext(MyConfig.class); User user=(User) context.getBean(&quot;user&quot;);//取配置类中的方法名 System.out.println(user.getName());}","link":"/2023/02/07/Spring%E4%B8%89/"},{"title":"Spring（四）","text":"本系列主要进行Spring框架的学习介绍，Spring框架是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架。其中本篇文章进行具体AOP的讲解，首先会介绍代理模式，之后会进行AOP的具体介绍。 代理模式为什么学习代理模式，因为这是Spring AOP的底层。 角色分析： 抽象角色：一般会使用接口或者抽象类来解决； 真实角色：被代理的角色； 代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作； 客户：访问代理对象的人。即main方法。 代理模式（静态代理）的好处: 可以使真实角色的操作更加纯粹!不用去关注一些公共的业务； 公共业务就交给代理角色，实现了业务的分工； 公共业务发生扩展的时候，方便集中管理。 （静态代理）缺点: 一个真实角色就会产生一个代理角色； 代码量会翻倍，开发效率会变低。 动态代理标准格式： 两个重要类： InvocationHandler：调用处理程序（invoke）并返回结果； Proxy：提供了创建动态代理类和实例的静态方法，用于生成动态代理实例。 代理模式（动态代理）的好处: 可以使真实角色的操作更加纯粹!不用去关注一些公共的业务； 公共业务就交给代理角色，实现了业务的分工； 公共业务发生扩展的时候，方便集中管理； 一个动态代理类代理的是一个接口，一般就是对应的一类业务； 一个动态代理类可以代理多个类，只要是实现了同一个接口即可。 AOP什么是AOP在不影响原始类的情况下，实现业务增强。 AOP(Aspect Oriented Programming)：面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 主要思想： aop在Spring中的作用提供声明式事务；允许用户自定义切面 几个概念： 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等…. 可以将功能添加到主要功能的周围 切面(Aspect)：横切关注点被模块化的特殊对象。即，它是一个类，如日志类，； 通知(Advice)：切面必须要完成的工作。即，它是类中的一个方法； 目标(Target)：被通知对象，即为真实角色； 代理(Proxy)：向目标对象应用通知之后创建的对象，即为代理角色； 切入点(PointCut)：切面通知执行的“地点”的定义，即切入的位置； 连接点(JointPoint)：与切入点匹配的执行点。 AOP本质上是动态代理，只不过在Spring中，目标和代理Spring帮我们做了。 使用Spring实现AOP使用aop需要导依赖，和导包 方式一：使用Spring的API接口【主要是SpringAPI接口实现】 日志类： 12345678910//放日志，采用MethodBeforeAdvice接口public class Log implements MethodBeforeAdvice{ //method:要执行的目标对象的方法 //args:参数 //target:目标对象 public void before(Method method,Object[] args,Object target) throws Throwable{ System.out.println(target.getClass().getName()+&quot;的&quot;+method.getName()+&quot;被执行了&quot;); }} 配置文件： 12345678910111213141516&lt;!--注册beans--&gt;&lt;bean id=&quot;userService&quot; class=&quot;service.UserServiceImpl&quot;/&gt;&lt;bean id=&quot;log&quot; class=&quot;log.Log&quot;/&gt;&lt;bean id=&quot;afterLog&quot; class=&quot;log.AfterLog&quot;/&gt;&lt;!--方式一：使用原生API接口--&gt;&lt;!--配置aop，导入aop的配置--&gt;&lt;aop:config&gt; &lt;!--切入点：expression:表达式, execution(要执行的位置,***)--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(*service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--执行环绕增加，实现切面--&gt; &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;&lt;/aop:config&gt; 方式二：自定义类实现AOP【主要是切面定义】 自定义类： 12345678910//方式二：使用自定义日志类实现AOPpublic class DiyPointCut{ public void before(){ System.out.println(&quot;=============方法执行前==============&quot;); } public void after(){ System.out.println(&quot;=============方法执行后==============&quot;); }} 配置文件： 1234567891011121314&lt;!--方式二：自定义类--&gt;&lt;bean id=&quot;diy&quot; class=&quot;diy.DiyPointCut&quot;/&gt; &lt;aop:config&gt; &lt;!--自定义切面，ref要引用的类--&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(*service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--通知--&gt; &lt;aop:before method=&quot;before&quot;pointcut-ref=&quot;point&quot;/&gt; &lt;aop:after method=&quot;after&quot;pointcut-ref=&quot;point&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 方式三：使用注解实现 自定义类： 12345678910111213141516171819202122//方式三：使用注解方式实现AOP@Aspect //标注这个类是一个切面public class AnnotationPointCut{ @Before(&quot;execution(*service.UserServiceImpl.*(..))&quot;) public void before(){ System.out.println(&quot;=============方法执行前==============&quot;); } @After(&quot;execution(*service.UserServiceImpl.*(..))&quot;) public void after(){ System.out.println(&quot;=============方法执行后==============&quot;); } //在环绕增强中，定义连接点 @Around(&quot;execution(*service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable{ System.out.println(&quot;=============环绕前==============&quot;); Object proceed=jp.proceed(); System.out.println(&quot;=============环绕后==============&quot;); }} 配置文件： 123&lt;bean id=&quot;annotationPointCut&quot; class=&quot;diy.AnnotationPointCut&quot;/&gt;&lt;aop:aspectj-autoproxy/&gt; //使用注解配置","link":"/2023/02/07/Spring%E5%9B%9B/"},{"title":"Spring（二）","text":"本系列主要进行Spring框架的学习介绍，Spring框架是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架。其中本篇文章进行Spring的配置介绍和依赖注入（DI）特性。 Spring配置别名（Alias）别名：取一个额外的名字，如果添加了别名，我们也可以使用别名获取到这个对象。此外，使用了别名后，原来的名字仍然可以使用。 12&lt;alias name=&quot;hello&quot; alias=&quot;helloNew&quot;/&gt; Bean的配置id : bean 的唯一标识符， 也就是相当于我们学的对象名； class：bean 对象所对应的全限定名：包名+类型； name：也是别名，而且name可以同时取多个别名，用逗号 分号 空格都可以隔开 import一般用于团队开发使用，可以将多个配置文件导入合并为一个 依赖注入构造器注入见第4章 Set方式注入【重点】 依赖注入：本质是Set注入 依赖：bean对象的创建依赖于容器； 注入：bean对象的所有属性，由容器来注入。 环境搭建： 1.构建复杂类 1234567891011public class Address{ private String address; public String getAddress(){ return address; } public void setAddress(Stringaddress){ this.address=address; }} 2.构建目标类 12345678910111213public class Student{ private String name; private Address address; private String[] books; private List&lt;String&gt; hobbies; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; get set…} 3.beans.xml配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;bean id=&quot;address&quot; class=&quot;pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;西安&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;pojo.Student&quot;&gt; &lt;!--普通值注入，value--&gt; &lt;property name=&quot;name&quot; value=&quot;琴疆&quot;/&gt; &lt;!--Bean注入，ref--&gt; &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt; &lt;!--数组注入--&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--List--&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;看电影&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--Map--&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;身份证&quot; value=&quot;123121231313123132&quot;/&gt; &lt;entry key=&quot;银行卡&quot; value=&quot;111111111111111111&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--Set--&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;PUBG&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--null--&gt; &lt;property name=&quot;wife&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;!--Properties--&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driver&quot;&gt;20190525&lt;/prop&gt; &lt;prop key=&quot;url&quot;&gt;男&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 4.测试 12345678910111213141516171819public static void main(String[]args){ ApplicationContext context=new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Student student=(Student) context.getBean(&quot;student&quot;); System.out.println(student.toString()); /* Student{ name='琴疆', address=Address{address='西安'}, books=[红楼梦,水浒传,三国演义], hobbies=[听歌,看电影], card={身份证=123121231313123132,银行卡=111111111111111111}, games=[LOL,PUBG], wife='null', info={password=123456,url=男,driver=20190525,username=root} } */} 拓展方式注入我们可以使用p命名空间和c命名空间的方式进行注入。 1234567&lt;!--p命名空间注入，可以直接注入属性的值--&gt;&lt;!--p其实就是properties--&gt;&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot; p:name=&quot;秦疆&quot; p:age=&quot;18&quot;/&gt;&lt;!--c命名空间注入，可以直接注入属性的值--&gt;&lt;bean id=&quot;user2&quot; class=&quot;pojo.User&quot; c:name=&quot;狂神&quot; c:age=&quot;18&quot;/&gt; 注意点： p命名空间和c命名空间不能直接使用，需要导入xml约束； p命名空间需要存在无参构造器，而c命名空间需要存在有参构造器。 bean的作用域1.单例模式（默认） 每一个bean创建均为一个对象。 123456&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot; c:name=&quot;狂神&quot; c:age=&quot;18&quot; scope=&quot;singleton&quot;/&gt;User user1 = (User) context.getBean(&quot;user&quot;);User user2 = (User) context.getBean(&quot;user&quot;);即有：user1==user2 2.原型模式 每次从容器中getBean时，都会产生一个新的对象。 123456&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot; c:name=&quot;狂神&quot; c:age=&quot;18&quot; scope=&quot;prototype&quot;/&gt;User user1 = (User) context.getBean(&quot;user&quot;);User user2 = (User) context.getBean(&quot;user&quot;);即有：user1!=user2 3.其余的模式均为了解。 request，session，application，只能在web开发种使用到。","link":"/2023/02/07/Spring%E4%BA%8C/"},{"title":"SpringMVC（一）","text":"本系列主要进行SpringMVC框架的学习介绍，Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。其中本篇文章进行SpringMVC的前端知识，包括MVC的介绍和Servlet的实现等。 回顾MVC什么是MVCMVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 MVC结构的主要框架： Model2时代 主要流程： 用户发请求； Servlet接收请求数据，并调用对应的业务逻辑方法； 业务处理完毕，返回更新后的数据给servlet； servlet转向到JSP，由JSP来渲染页面； 响应给前端更新后的页面。 职责分析： Controller：控制器 取得表单数据；调用业务逻辑；转向指定的页面 Model：模型 处理业务逻辑；保存数据的状态 View：视图 显示页面 回顾Servlet核心步骤： 1.新建一个Maven工程当做父工程，导入pom依赖；并建立一个Moudle，添加Web app的支持。 2.编写一个Servlet类，用来处理用户的请求 1234567891011121314151617181920212223242526272829//实现Servlet接口public class HelloServlet extends HttpServlet { @Override //继承了Servlet相关类，就需要重写doGet和doPost两种方法 protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //接收请求，取得参数 String method = req.getParameter(&quot;method&quot;); if (method.equals(&quot;add&quot;)){ req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;); } if (method.equals(&quot;delete&quot;)){ req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了delete方法&quot;); } //业务逻辑 // …..这里没有业务逻辑…. //视图跳转 req.getRequestDispatcher(&quot;/WEB-INF/jsp/page.jsp&quot;).forward(req,resp); //跳转到前端页面中，并继续传递请求 } @Override //实现复用，调用doGet中的方法 protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); }} 3.编写page.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建page.jsp 12345&lt;!--直接显示消息即可--&gt;&lt;body&gt; ${msg}&lt;/body&gt; 4.在web的配置文件：web.xml中注册Servlet 1234567891011&lt;servlet&gt;&lt;!--名称可以随便写，但要上下一致--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--请求名称，即在路径中加入/hello就能进入Servlet类的请求中，并跳转到page.jsp页面--&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 5.配置Tomcat，并启动测试 http://localhost:8999/springmvc_01_servlet_war_exploded/hello?method=add http://localhost:8999/springmvc_01_servlet_war_exploded/hello?method=delete","link":"/2023/02/10/SpringMVC%E4%B8%80/"},{"title":"SpringMVC（三）","text":"本系列主要进行SpringMVC框架的学习介绍，Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。其中本篇文章进行SpringMVC的各部分模块分析，包括控制器，结果跳转方式，数据处理方式，restful风格，乱码处理等。 模块分析控制器Controller 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现； 控制器负责解析用户的请求并将其转换为一个模型（model）； 在Spring MVC中一个控制器类可以包含多个方法（但访问路径不能相同）。 实现Controller接口： Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； 123456//实现该接口的类获得控制器功能public interface Controller { //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;} 使用注解@Controller： @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 注解@RequestMapping的介绍： @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 结果跳转方式ModelAndView：（配置版代码就是使用这个） 设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面。 页面 : {视图解析器前缀} + viewName +{视图解析器后缀} ServletAPI：（最开始的Servlet就是使用这个） 通过设置ServletAPI , 不需要视图解析器。 1、通过HttpServletResponse进行输出； 2、通过HttpServletResponse实现重定向； 3、通过HttpServletResponse实现转发。 SpringMVC：（注解版代码就是使用这个） 即使用注解+视图解析器（也可以不要，但需要采用完整路径） 4.3 数据处理–处理提交的数据提交的域名称和处理方法的参数名一致：直接提交 1234567//提交数据：http://localhost:8080/hello?name=kuangshen@RequestMapping(&quot;/hello&quot;)public String hello(String name){ System.out.println(name); return &quot;hello&quot;;} 提交的域名称和处理方法的参数名不一致：添加注解@RequestParam 12345678//@RequestParam(&quot;username&quot;) : username提交的域的名称//提交数据：http://localhost:8080/hello?username=kuangshen@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name){ System.out.println(name); return &quot;hello&quot;;} 提交的是一个对象： 要求提交的表单域和对象的属性名一致，参数使用对象即可 1234567//提交数据：http://localhost:8080/hello?name=kuangshen&amp;id=1&amp;age=15@RequestMapping(&quot;/user&quot;)public String user(User user){ System.out.println(user); return &quot;hello&quot;;} 数据处理–数据显示到前端 通过ModelAndView – 配置版本 通过ModelMap – 与Model类似，继承了LinkedMap ，功能多一些 通过Model – 注解版本 restful风格Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 风格介绍：用/来区分每一个响应，即使用路径变量。 使用路径变量的好处： 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换；同时可以约束访问参数，如果类型不一样，则访问不到对应的请求方法； 更加安全，不暴露后台函数的参数名称。 使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果。 如下：请求地址一样，但是功能可以不同。（采用了不同的请求方式） http://127.0.0.1/item/1 查询，GET http://127.0.0.1/item 新增，POST http://127.0.0.1/item 更新，PUT http://127.0.0.1/item/1 删除，DELETE 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 12345678910111213@Controllerpublic class RestFulController { //映射访问路径 @RequestMapping(&quot;/commit/{p1}/{p2}&quot;) public String index(@PathVariable int p1, @PathVariable int p2, Model model){ int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result); //返回视图位置 return &quot;test&quot;; }} 乱码问题SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置。 12345678910111213&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","link":"/2023/02/10/SpringMVC%E4%B8%89/"},{"title":"SpringMVC（二）","text":"本系列主要进行SpringMVC框架的学习介绍，Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。其中本篇文章进行SpringMVC的基本知识讲解，初步介绍了SpringMVC及其实现原理，同时搭建了第一个SpringMVC程序。 什么是SpringMVC概述Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 Spring MVC的特点： 轻量级，简单易学； 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 中心控制器Spring的web框架围绕DispatcherServlet设计，DispatcherServlet的作用是将请求分发到不同的处理器。**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。 SpringMVC的原理如下图所示： 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 SpringMVC执行原理（重要） 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 简要分析执行流程: 1.DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。我们假设请求的url为 : http://localhost:8080/SpringMVC/hello, 如上url拆分成三部分： http://localhost:8080: 服务器域名 SpringMVC: 部署在服务器上的web站点 hello: 表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 2.HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。代码中为 ‘/‘ 表示能够查找所有的控制器。 3.HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 4.HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 5.HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 6.Handler让具体的Controller执行。 7.Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 8.HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 9.DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 10.视图解析器将解析的逻辑视图名传给DispatcherServlet。 11.DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 12.最终视图呈现给用户。 第一个SpringMVC程序配置版1.新建一个Module， 添加web的支持，导入SpringMVC的依赖； 2.配置web.xml，注册DispatcherServlet： 12345678910111213141516171819202122&lt;!--配置DispatcherServlet：这个是SpringMVC的核心，即请求分发器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--DispatcherServlet需要绑定一个springmvc的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别-1--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!--/匹配所有的请求；（不包括.jsp）--&gt;&lt;!--/*匹配所有的请求；（包括.jsp）--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3.编写SpringMVC 的配置文件springmvc-servlet.xml： 123456789101112131415161718192021&lt;!--处理器映射器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;&lt;!--处理器适配器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;&lt;!--视图解析器:DispatcherServlet给他的ModelAndView1.获取ModelAndView的数据(&quot;HelloSpringMVC&quot;);2.解析ModelAndView的视图名字(&quot;hello&quot;);3.拼接视图名字，找到对应的视图(&quot;/WEB-INF/jsp/hello.jsp&quot;);4.将数据渲染到这个视图上--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt; &lt;!--前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!--后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;&lt;!--Handler--&gt;&lt;!--BeanNameUrlHandlerMapping配置bean，其它处理器可能不需要配置--&gt;&lt;bean id=&quot;/hello&quot; class=&quot;controller.HelloController&quot;/&gt; 4.编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView： 123456789101112131415public class HelloController implements Controller{ public ModelAndView handleRequest(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws Exception{ //ModelAndView模型和视图 ModelAndViewmv=newModelAndView(); //封装对象，放在ModelAndView中 mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC!&quot;); //封装要跳转的视图，放在ModelAndView中 mv.setViewName(&quot;hello&quot;);//:/WEB-INF/jsp/hello.jsp return mv; }} 5.将自己的类交给SpringIOC容器，注册bean： 123&lt;!--Handler--&gt;&lt;bean id=&quot;/hello&quot; class=&quot;com.kuang.controller.HelloController&quot;/&gt; 6.编写要跳转的页面hello.jsp： 1234&lt;body&gt; ${msg}&lt;/body&gt; 7.配置Tomcat启动测试。 代码执行流程（自己理解的）: 用户请求http：//localhost:8080/SpringMVC/hello，DispatcherServlet接收请求并拦截请求，解析出hello满足我们的要求（我们的要求是’/‘，即所有的请求都能接收，执行的是web.xml的servlet-mapper配置），同时执行web.xml中DispatcherServlet的配置； DispatcherServlet的配置需要绑定springmvc的配置文件，因此接下来会进行处理器映射器BeanNameUrlHandlerMapping的配置，和处理器适配器SimpleControllerHandlerAdapter的配置，见springmvc-servlet.xml，对hello进行解析，并适配到对应的类中，即Controller； Controller代码执行，封装数据和要跳转的视图，返回ModelAndView类的对象，见HelloController.java； 视图解析器ViewResolver解析ModelAndView，得到对应的数据，同时拼接视图路径，将数据渲染到视图上，见springmvc-servlet.xml。 注解版1.新建一个Module， 添加web的支持，导入SpringMVC的依赖； 2配置web.xml，同上 3.配置springmvc-servlet.xml： 12345678910111213141516&lt;!--自动扫描包，让指定包下的注解生效,由IOC容器统一管理--&gt;&lt;context:component-scan base-package=&quot;controller&quot;/&gt;&lt;!--让SpringMVC不处理静态资源--&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!--支持mvc注解驱动，免去了DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter实例的注入--&gt;&lt;mvc:annotation-driven/&gt;&lt;!--视图解析器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!--前缀--&gt; &lt;property name=&quot;prefix&quot;value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!--后缀--&gt; &lt;property name=&quot;suffix&quot;value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 4.编写我们要操作业务Controller： 12345678910111213@Controllerpublic class HelloController{ //url：localhost:8999/hello @RequestMapping(&quot;/hello&quot;) public String sayHello(Model model){ //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(&quot;msg&quot;,&quot;Hello,SpringMVC&quot;); //web-inf/jsp/test.jsp return&quot;test&quot;; }} 5.将自己的类交给SpringIOC容器，注册bean（省略）； 6.编写要跳转的页面hello.jsp，同上； 7.配置Tomcat启动测试。 注意：Controller 对应的类中： @Controller是为了让SpringIOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，路径为/hello，若类上也有@RequestMapping，则路径需要叠加； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称test，加上配置文件中的前后缀变成WEB-INF/jsp/test.jsp。 总结： 使用springMVC必须配置的三大件：处理器映射器、处理器适配器、视图解析器； 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置","link":"/2023/02/10/SpringMVC%E4%BA%8C/"},{"title":"SpringMVC（五）","text":"本系列主要进行SpringMVC框架的学习介绍，Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。其中本篇文章进行SSM（Spring-SpringMVC-MyBatis）框架的整合，编写了一个书籍管理的代码，实现书籍的查询等功能。包括：准备工作，MyBatis层的搭建，Spring层的搭建，SpringMVC层的搭建，功能实现等五个步骤。 SSM框架整合准备工作1.创建数据库。创建一个存放数据库的表books，并让IDEA关联数据库。 1234567891011121314151617CREATE DATABASE `ssmbuild`;USE `ssmbuild`;DROP TABLE IF EXISTS `books`;CREATE TABLE `books` (`bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT '书id',`bookName` VARCHAR(100) NOT NULL COMMENT '书名',`bookCounts` INT(11) NOT NULL COMMENT '数量',`detail` VARCHAR(200) NOT NULL COMMENT '描述',KEY `bookID` (`bookID`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES(1,'Java',1,'从入门到放弃'),(2,'MySQL',10,'从删库到跑路'),(3,'Linux',5,'从进门到进牢'); 2.基本环境搭建。 新建Maven项目 -&gt; 添加web支持 -&gt; 导入依赖（数据库相关mysql, c3p0；mybatis相关mybatis, mybatis-spring；spring相关spring-webmvc, spring-jdbc；servlet-jsp相关servlet-api, jsp-api, jstl；工具junit, lombok）-&gt; Maven资源过滤 -&gt; 建立基本框架（dao, pojo, service, controller） 解释：（自己理解的） dao层负责底层功能实现，如基本的增删改查操作，需要配置接口和对应的xml，编写sql语言； pojo层为对象类，即为要操作的对象，编写基本的属性和get set等方法； service层为业务层，对dao层的接口进行调用，需要配置相同的接口，以及实现类，同时进行set注入； controller层为控制层，用于前后端交互，对service层进行调用，接收前端的参数，进行后端功能的实现； Mybatis层1.编写数据库配置文件database.properties。 存储数据库基本信息。 12345jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=123456 2.编写mybatis的核心配置文件mybatis-config.xml。 主要进行别名和设置的编写，以及mapper的配置，其余的交给spring的配置文件。 123456789&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.kuang.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper resource=&quot;BookMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3.编写pojo层的实体类Books。 12345678910@Data@AllArgsConstructor@NoArgsConstructorpublic class Books { private int bookID; private String bookName; private int bookCounts; private String detail;} 4.编写dao层对应接口BookMapper及其配置文件BookMapper.xml。 这里以查询所有书籍为例，具体的见原代码。 1234567891011121314//接口public interface BookMapper { //查询全部Book,返回list集合 List&lt;Books&gt; queryAllBook();}//配置文件&lt;mapper namespace=&quot;com.kuang.dao.BookMapper&quot;&gt;&lt;!--查询全部Book--&gt; &lt;select id=&quot;queryAllBook&quot; resultType=&quot;Books&quot;&gt; SELECT * from ssmbuild.books &lt;/select&gt;&lt;/mapper&gt; 5.编写service层的对应接口BookService和实现类BookServiceImpl。 对dao层进行调用，供controller层实现。 123456789101112131415161718//接口public interface BookService { List&lt;Books&gt; queryAllBook();}//实现类public class BookServiceImpl implements BookService { //调用dao层的操作，设置一个set接口，方便Spring管理 private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) { this.bookMapper = bookMapper; } public List&lt;Books&gt; queryAllBook() { return bookMapper.queryAllBook(); }} Spring层1.spring层整合mybatis层，编写配置文件spring-dao.xml。 主要流程： 配置数据库底层（数据库文件、连接池配置）； sqlSessionFactory对象的创建（注入连接池、关联mybatis配置文件）； dao层接口注入（采用MapperScannerConfigurer，直接进行Factory的注入和mapper的配置，就不用通过sqlSession对象的创建进行mapper 的配置了） 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!-- 配置整合mybatis --&gt;&lt;!-- 1.关联数据库文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;&lt;!-- 2.数据库连接池 --&gt;&lt;!--数据库连接池 dbcp 半自动化操作 不能自动连接 c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;&lt;/bean&gt;&lt;!-- 3.配置SqlSessionFactory对象 --&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;&lt;/bean&gt;&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;&lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;dao&quot;/&gt;&lt;/bean&gt; 2.spring层整合service层，编写配置文件spring-service.xml。 主要流程： 扫描service层的bean； 进行service层类的注入； 事务配置（需要注入数据库连接池）。 123456789101112131415&lt;!-- 扫描service相关的bean --&gt;&lt;!--自动扫描包，让指定包下的注解生效,由IOC容器统一管理--&gt;&lt;context:component-scan base-package=&quot;service&quot; /&gt;&lt;!--BookServiceImpl注入到IOC容器中--&gt;&lt;bean id=&quot;BookServiceImpl&quot; class=&quot;service.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt;&lt;/bean&gt;&lt;!-- 配置事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; SpringMVC层1.编写配置文件web.xml。 主要包括DispatcherServlet的配置，和MVC过滤器的配置。 1234567891011121314151617181920212223242526272829303132333435&lt;!--DispatcherServlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--encodingFilter--&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!--Session过期时间--&gt;&lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt;&lt;/session-config&gt; 2.编写springmvc的配置文件spring-mvc.xml。 主要流程： 开启注解驱动和静态资源默认配置（省去了适应期和映射器的配置）； 配置视图解析器（这个一定要配）； 扫描controller层相关bean。 123456789101112131415161718&lt;!-- 配置SpringMVC --&gt;&lt;!-- 1.开启SpringMVC注解驱动 --&gt;&lt;mvc:annotation-driven /&gt;&lt;!-- 2.静态资源默认servlet配置--&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;&lt;!-- 4.扫描web相关的bean --&gt;&lt;!--自动扫描包，让指定包下的注解生效,由IOC容器统一管理--&gt;&lt;context:component-scan base-package=&quot;controller&quot;/&gt; 3.Spring配置整合文件，applicationContext.xml 1234&lt;import resource=&quot;spring-dao.xml&quot;/&gt;&lt;import resource=&quot;spring-service.xml&quot;/&gt;&lt;import resource=&quot;spring-mvc.xml&quot;/&gt; 功能实现1.编写BookController类。 123456789101112131415@Controller@RequestMapping(&quot;/book&quot;)public class BookController { @Autowired @Qualifier(&quot;BookServiceImpl&quot;) private BookService bookService; @RequestMapping(&quot;/allBook&quot;) public String list(Model model) { List&lt;Books&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;, list); return &quot;allBook&quot;; }} 2.编写首页index.jsp，编写展示所有书籍的页面allBook.jsp，此处省略。 3.编写其它功能，如增删改等。最后配置Tomcat服务器进行运行（导入lib，配置Tomcat）。结束！","link":"/2023/02/10/SpringMVC%E4%BA%94/"},{"title":"SpringMVC（四）","text":"本系列主要进行SpringMVC框架的学习介绍，Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。其中本篇文章进行SpringMVC的一些拓展内容和前后端分离的知识介绍，包括Json，Ajax，拦截器，文件等。 JSONjson的有关内容具体见：https://mp.weixin.qq.com/s/RAqRKZJqsJ78HRrJg71R1g 什么是JSON JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛； 采用完全独立于编程语言的文本格式来存储和表示数据； 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言； 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： {“name”: “QinJiang”} {“age”: “3”} {“sex”: “男”} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 JSON 和 JavaScript 对象互转要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： 1234567var obj = JSON.parse('{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}');//结果是 {a: 'Hello', b: 'World'}//要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：var json = JSON.stringify({a: 'Hello', b: 'World'});//结果是 '{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}' Controller返回JSON数据为什么要这样做？为了得到JSON格式的数据，并交给前端使用。 Controller类： 12345678910111213141516171819@RestController //直接返回字符串，不走视图管理器public class UserController { //produces:指定响应体返回类型和编码 @RequestMapping(value = &quot;/json1&quot;) public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; }} springmvc-servlet.xml：添加防止json乱码的部分 123456789101112131415&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 注意：要记得导依赖，同时防乱码（springmvc配置文件中），具体见代码。 Ajax研究Ajax介绍 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）； AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术； 传统的网页(即不用AJAX技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页； 使用AJAX技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 jQuery实现Ajax例子1：检测ajax请求： 1.配置AjaxController 123456789101112@Controllerpublic class AjaxController { @RequestMapping(&quot;/a1&quot;) public void ajax1(String name , HttpServletResponse response) throws IOException { if (&quot;admin&quot;.equals(name)){ response.getWriter().print(&quot;true&quot;); }else{ response.getWriter().print(&quot;false&quot;); } }} 2.编写测试文件index.jsp，需要script导包 123456789101112131415161718192021&lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function a1(){ $.post({ url:&quot;${pageContext.request.contextPath}/a1&quot;, data:{'name':$(&quot;#txtName&quot;).val()}, success:function (data,status) { alert(data); alert(status); } }); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;%--onblur：失去焦点触发事件--%&gt; 用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; onblur=&quot;a1()&quot;/&gt;&lt;/body&gt; 3.启动Tomcat测试，打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求，即为后台返回给我们的结果 例子2：输入框提示功能： 1.配置AjaxController 12345678910111213141516171819202122232425@RestControllerpublic class AjaxController { @RequestMapping(&quot;/a3&quot;) public String ajax3(String name,String pwd){ String msg = &quot;&quot;; //模拟数据库中存在数据 if (name!=null){ if (&quot;admin&quot;.equals(name)){ msg = &quot;OK&quot;; }else { msg = &quot;用户名输入错误&quot;; } } if (pwd!=null){ if (&quot;123456&quot;.equals(pwd)){ msg = &quot;OK&quot;; }else { msg = &quot;密码输入有误&quot;; } } return msg; //由于@RestController注解，将msg转成json格式返回 }} 2.编写测试文件login.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;head&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script src=&quot;${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; &lt;!--Ajax监测--&gt; function a1(){ $.post({ url:&quot;${pageContext.request.contextPath}/a3&quot;, data:{'name':$(&quot;#name&quot;).val()}, success:function (data) { if (data.toString()=='OK'){ $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;); }else { $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); } $(&quot;#userInfo&quot;).html(data); } }); } function a2(){ $.post({ url:&quot;${pageContext.request.contextPath}/a3&quot;, data:{'pwd':$(&quot;#pwd&quot;).val()}, success:function (data) { if (data.toString()=='OK'){ $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;); }else { $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); } $(&quot;#pwdInfo&quot;).html(data); } }); } &lt;/script&gt;&lt;/head&gt;&lt;!--页面显示--&gt;&lt;body&gt; &lt;p&gt; 用户名:&lt;input type=&quot;text&quot; id=&quot;name&quot; onblur=&quot;a1()&quot;/&gt; &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 密码:&lt;input type=&quot;text&quot; id=&quot;pwd&quot; onblur=&quot;a2()&quot;/&gt; &lt;span id=&quot;pwdInfo&quot;&gt;&lt;/span&gt; &lt;/p&gt;&lt;/body&gt; 3.Tomcat服务器连接，网页测试 测试结果：能够实现动态请求响应，局部刷新。 鼠标离开输入框后，会判断输入内容是否满足要求，如果不满足，会进行提示。 拦截器和文件拦截器SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理。 开发者可以自己定义一些拦截器来实现特定的功能。 过滤器与拦截器的区别：拦截器是AOP思想的具体应用。 过滤器： servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器： 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 自定义拦截器：实现 HandlerInterceptor 接口。 1.定义拦截器类： 1234567891011121314151617181920public class MyInterceptor implements HandlerInterceptor { //在请求处理的方法之前执行 //如果返回true执行下一个拦截器 //如果返回false就不执行下一个拦截器 public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception { System.out.println(&quot;------------处理前------------&quot;); return true; } //在请求处理方法执行之后执行 public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { System.out.println(&quot;------------处理后------------&quot;); } //在dispatcherServlet处理后执行,做清理工作. public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { System.out.println(&quot;------------清理------------&quot;); }} 2.在springmvc的配置文件中配置拦截器： 123456789101112&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--/** 包括路径及其子路径--&gt; &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt; &lt;!--/admin/** 拦截的是/admin/下的所有--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--bean配置的就是拦截器--&gt; &lt;bean class=&quot;interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 3.编写Controller： 1234567891011//测试拦截器的控制器@Controllerpublic class InterceptorController { @RequestMapping(&quot;/interceptor&quot;) @ResponseBody public String testFunction() { System.out.println(&quot;控制器中的方法执行了&quot;); return &quot;hello&quot;; }} 前端index.jsp 12&lt;a href=&quot;${pageContext.request.contextPath}/interceptor&quot;&gt;拦截器测试&lt;/a&gt; 文件 如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver； 前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器。 文件上传的具体流程： 1.配置bean 123456789&lt;!--文件上传配置--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt; &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;&lt;/bean&gt; 2.编写前端界面 12345&lt;form action=&quot;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 3.Controller控制器 12345678910111213141516171819202122232425262728293031323334353637383940414243@Controllerpublic class FileController { //@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象 //批量上传CommonsMultipartFile则为数组即可 @RequestMapping(&quot;/upload&quot;) public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException { //获取文件名 : file.getOriginalFilename(); String uploadFileName = file.getOriginalFilename(); //如果文件名为空，直接回到首页！ if (&quot;&quot;.equals(uploadFileName)){ return &quot;redirect:/index.jsp&quot;; } System.out.println(&quot;上传文件名 : &quot;+uploadFileName); //上传路径保存设置 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); //如果路径不存在，创建一个 File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } System.out.println(&quot;上传文件保存地址：&quot;+realPath); InputStream is = file.getInputStream(); //文件输入流 OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流 //读取写出 int len=0; byte[] buffer = new byte[1024]; while ((len=is.read(buffer))!=-1){ os.write(buffer,0,len); os.flush(); } os.close(); is.close(); return &quot;redirect:/index.jsp&quot;; }} 文件下载的具体流程： 1、设置 response 响应头 2、读取文件 – InputStream 3、写出文件 – OutputStream 4、执行操作 5、关闭流 （先开后关） 1234567891011121314151617181920212223242526272829303132333435@RequestMapping(value=&quot;/download&quot;)public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception{ //要下载的图片地址 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); String fileName = &quot;基础语法.jpg&quot;; //1、设置response 响应头 response.reset(); //设置页面不缓存,清空buffer response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码 response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据 //设置响应头 response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;fileName=&quot;+URLEncoder.encode(fileName, &quot;UTF-8&quot;)); File file = new File(path,fileName); //2、读取文件--输入流 InputStream input=new FileInputStream(file); //3、写出文件--输出流 OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作 while((index= input.read(buff))!= -1){ out.write(buff, 0, index); out.flush(); } out.close(); input.close(); return null;} 前端页面： 1&lt;a href=&quot;/download&quot;&gt;点击下载&lt;/a&gt;","link":"/2023/02/10/SpringMVC%E5%9B%9B/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"元学习","slug":"元学习","link":"/tags/%E5%85%83%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"机器学习基础","slug":"机器学习基础","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"},{"name":"成员推断攻击","slug":"成员推断攻击","link":"/tags/%E6%88%90%E5%91%98%E6%8E%A8%E6%96%AD%E6%94%BB%E5%87%BB/"},{"name":"联邦学习","slug":"联邦学习","link":"/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"},{"name":"论文写作","slug":"论文写作","link":"/tags/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"},{"name":"论文阅读笔记","slug":"论文阅读笔记","link":"/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"MyBatis","slug":"MyBatis","link":"/tags/MyBatis/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/tags/SpringMVC/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"web基础","slug":"web基础","link":"/categories/web%E5%9F%BA%E7%A1%80/"},{"name":"机器学习","slug":"机器学习","link":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"编程基础","slug":"编程基础","link":"/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"论文写作","slug":"论文写作","link":"/categories/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"},{"name":"论文阅读笔记","slug":"论文阅读笔记","link":"/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"MyBatis","slug":"MyBatis","link":"/categories/MyBatis/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/categories/SpringMVC/"}],"pages":[]}